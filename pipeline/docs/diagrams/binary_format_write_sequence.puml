@startuml Binary Format Write Sequence
!theme plain
title Binary File Format - Write Process

actor User
participant "Pipeline Manager" as PM
participant "File Processor" as FP
participant "Compression Stage" as CS
participant "Encryption Stage" as ES
participant "File Writer" as FW
participant "Metadata Builder" as MB
participant "Output File" as OF

User -> PM: process_file(input.txt, output.adapipe)
activate PM

PM -> FP: initialize_processing()
activate FP

PM -> MB: create_header_builder()
activate MB
MB -> MB: set_original_filename("input.txt")
MB -> MB: calculate_original_checksum()
MB -> MB: set_app_version()
MB -> MB: set_format_version(1)

PM -> FW: open_output_file(output.adapipe)
activate FW

loop for each chunk
    PM -> FP: read_chunk(1MB)
    FP -> PM: chunk_data
    
    PM -> CS: compress_chunk(chunk_data)
    activate CS
    CS -> CS: apply_brotli_compression()
    CS -> MB: add_processing_step("Compression", "brotli", level=6, order=0)
    CS -> PM: compressed_chunk
    deactivate CS
    
    PM -> ES: encrypt_chunk(compressed_chunk)
    activate ES
    ES -> ES: generate_unique_nonce()
    ES -> ES: encrypt_with_aes256gcm()
    ES -> MB: add_processing_step("Encryption", "aes256gcm", order=1)
    ES -> PM: encrypted_chunk
    deactivate ES
    
    PM -> FW: write_chunk_format(nonce, data_length, encrypted_data)
    FW -> OF: [NONCE][DATA_LENGTH][ENCRYPTED_DATA]
    
    PM -> MB: increment_chunk_count()
end

PM -> MB: finalize_metadata()
MB -> MB: calculate_output_checksum()
MB -> MB: set_processing_timestamp()
MB -> PM: json_header

PM -> FW: write_footer(json_header)
FW -> OF: [JSON_HEADER]
FW -> OF: [HEADER_LENGTH] (4 bytes)
FW -> OF: [FORMAT_VERSION] (2 bytes) 
FW -> OF: [MAGIC_BYTES] ("ADAPIPE\0")

FW -> PM: write_complete
deactivate FW

PM -> User: ProcessingResult
deactivate PM
deactivate FP
deactivate MB

note right of OF
Final file structure:
[CHUNK_1][CHUNK_2]...[CHUNK_N]
[JSON_HEADER][HEADER_LENGTH]
[FORMAT_VERSION][MAGIC_BYTES]
end note

@enduml
