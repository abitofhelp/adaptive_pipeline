@startuml Binary Format Class Diagram
!theme plain
title Binary File Format - Class Structure

package "Binary Format" {
    class FileHeader {
        +app_version: String
        +format_version: u16
        +original_filename: String
        +original_size: u64
        +original_checksum: String
        +output_checksum: String
        +processing_steps: Vec<ProcessingStep>
        +chunk_size: u32
        +chunk_count: u32
        +processed_at: DateTime<Utc>
        +pipeline_id: String
        +metadata: HashMap<String, String>
        --
        +new(filename: String, size: u64, checksum: String): FileHeader
        +add_compression_step(algorithm: &str, level: u32): Self
        +add_encryption_step(algorithm: &str, key_derivation: &str): Self
        +with_chunk_info(size: u32, count: u32): Self
        +with_output_checksum(checksum: String): Self
        +to_bytes(): Result<Vec<u8>>
        +from_bytes(data: &[u8]): Result<(Self, usize)>
        +verify_output_integrity(file_data: &[u8]): Result<bool>
        +validate_restored_file(restored_data: &[u8]): Result<bool>
        +get_restoration_steps(): Vec<&ProcessingStep>
        +validate(): Result<()>
    }

    class ProcessingStep {
        +step_type: ProcessingStepType
        +algorithm: String
        +parameters: HashMap<String, String>
        +order: u32
        --
        +new(step_type: ProcessingStepType, algorithm: String): Self
        +with_parameter(key: String, value: String): Self
        +get_parameter(key: &str): Option<&String>
    }

    enum ProcessingStepType {
        Compression
        Encryption
        Custom(String)
    }

    class ChunkFormat {
        +nonce: [u8; 12]
        +data_length: u32
        +encrypted_data: Vec<u8>
        --
        +new(nonce: [u8; 12], data: Vec<u8>): Self
        +to_bytes(): Vec<u8>
        +from_bytes(data: &[u8]): Result<(Self, usize)>
        +validate(): Result<()>
    }

    class BinaryFileFormat {
        +magic_bytes: [u8; 8]
        +format_version: u16
        +header_length: u32
        +header: FileHeader
        +chunks: Vec<ChunkFormat>
        --
        +new(header: FileHeader): Self
        +add_chunk(chunk: ChunkFormat): Self
        +write_to_file(path: &Path): Result<()>
        +read_from_file(path: &Path): Result<Self>
        +validate_structure(): Result<()>
        +get_file_size(): u64
    }
}

package "I/O Operations" {
    trait BinaryWriter {
        +write_chunk(chunk: &ChunkFormat): Result<()>
        +write_footer(header: &FileHeader): Result<()>
        +finalize(): Result<()>
    }

    trait BinaryReader {
        +read_header(): Result<FileHeader>
        +read_chunk(): Result<Option<ChunkFormat>>
        +validate_file(): Result<bool>
        +seek_to_chunk(index: u32): Result<()>
    }

    class StreamingWriter {
        -file: File
        -bytes_written: u64
        -chunk_count: u32
        --
        +new(path: &Path): Result<Self>
        +write_chunk_data(nonce: &[u8], data: &[u8]): Result<()>
        +write_footer_data(header: &FileHeader): Result<()>
        +get_bytes_written(): u64
    }

    class StreamingReader {
        -file: File
        -file_size: u64
        -header: Option<FileHeader>
        -current_chunk: u32
        --
        +new(path: &Path): Result<Self>
        +read_footer(): Result<FileHeader>
        +read_next_chunk(): Result<Option<ChunkFormat>>
        +seek_to_beginning(): Result<()>
        +verify_integrity(): Result<bool>
    }
}

package "Validation" {
    class FileValidator {
        +validate_magic_bytes(data: &[u8]): Result<()>
        +validate_format_version(version: u16): Result<()>
        +validate_header_structure(header: &FileHeader): Result<()>
        +validate_chunk_format(chunk: &ChunkFormat): Result<()>
        +calculate_file_checksum(path: &Path): Result<String>
        +verify_restoration_integrity(original: &[u8], restored: &[u8]): Result<bool>
    }
}

' Relationships
FileHeader ||--o{ ProcessingStep : contains
ProcessingStep ||--|| ProcessingStepType : has
BinaryFileFormat ||--|| FileHeader : contains
BinaryFileFormat ||--o{ ChunkFormat : contains
StreamingWriter ..|> BinaryWriter : implements
StreamingReader ..|> BinaryReader : implements
BinaryFileFormat ..> FileValidator : uses
StreamingWriter ..> FileValidator : uses
StreamingReader ..> FileValidator : uses

note top of FileHeader
Footer-based format:
[CHUNKS][JSON_HEADER]
[HEADER_LENGTH][FORMAT_VERSION]
[MAGIC_BYTES]
end note

note top of ChunkFormat
Per-chunk format:
[NONCE][DATA_LENGTH]
[ENCRYPTED_DATA]
end note

@enduml
