<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stage Processing - Pipeline Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pipeline Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stage-processing"><a class="header" href="#stage-processing">Stage Processing</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>This chapter provides a comprehensive overview of the stage processing architecture in the adaptive pipeline system. Stages are the fundamental building blocks that transform data as it flows through a pipeline.</p>
<hr />
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#stage-types">Stage Types</a></li>
<li><a href="#stage-entity">Stage Entity</a></li>
<li><a href="#stage-configuration">Stage Configuration</a></li>
<li><a href="#stage-lifecycle">Stage Lifecycle</a></li>
<li><a href="#stage-execution-model">Stage Execution Model</a></li>
<li><a href="#stage-executor-interface">Stage Executor Interface</a></li>
<li><a href="#compatibility-and-ordering">Compatibility and Ordering</a></li>
<li><a href="#resource-management">Resource Management</a></li>
<li><a href="#usage-examples">Usage Examples</a></li>
<li><a href="#performance-considerations">Performance Considerations</a></li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
<li><a href="#testing-strategies">Testing Strategies</a></li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><strong>Stages</strong> are individual processing steps within a pipeline that transform file chunks as data flows from input to output. Each stage performs a specific operation such as compression, encryption, or integrity checking.</p>
<h3 id="key-characteristics"><a class="header" href="#key-characteristics">Key Characteristics</a></h3>
<ul>
<li><strong>Type Safety</strong>: Strongly-typed stage operations prevent configuration errors</li>
<li><strong>Ordering</strong>: Explicit ordering ensures predictable execution sequence</li>
<li><strong>Lifecycle Management</strong>: Stages track creation and modification timestamps</li>
<li><strong>State Management</strong>: Stages can be enabled/disabled without removal</li>
<li><strong>Resource Awareness</strong>: Stages provide resource estimation and management</li>
</ul>
<h3 id="stage-processing-architecture"><a class="header" href="#stage-processing-architecture">Stage Processing Architecture</a></h3>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────┐
│                        Pipeline                             │
│                                                             │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐           │
│  │  Stage 1   │  │  Stage 2   │  │  Stage 3   │           │
│  │ Checksum   │→ │ Compress   │→ │  Encrypt   │→ Output  │
│  │ (Order 0)  │  │ (Order 1)  │  │ (Order 2)  │           │
│  └────────────┘  └────────────┘  └────────────┘           │
│        ↑               ↑               ↑                    │
│        └───────────────┴───────────────┘                    │
│              Stage Executor                                 │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h3>
<ol>
<li><strong>Domain-Driven Design</strong>: Stages are domain entities with identity</li>
<li><strong>Separation of Concerns</strong>: Configuration separated from execution</li>
<li><strong>Async-First</strong>: All operations are asynchronous for scalability</li>
<li><strong>Extensibility</strong>: New stage types can be added through configuration</li>
</ol>
<hr />
<h2 id="stage-types"><a class="header" href="#stage-types">Stage Types</a></h2>
<p>The pipeline supports five distinct stage types, each optimized for different data transformation operations.</p>
<h3 id="stagetype-enum"><a class="header" href="#stagetype-enum">StageType Enum</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum StageType {
    /// Compression or decompression operations
    Compression,

    /// Encryption or decryption operations
    Encryption,

    /// Data transformation operations
    Transform,

    /// Checksum calculation and verification
    Checksum,

    /// Pass-through stage that doesn't modify data
    PassThrough,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stage-type-details"><a class="header" href="#stage-type-details">Stage Type Details</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Stage Type</th><th>Purpose</th><th>Examples</th><th>Typical Use Case</th></tr></thead><tbody>
<tr><td><strong>Compression</strong></td><td>Reduce data size</td><td>Brotli, Gzip, Zstd, Lz4</td><td>Minimize storage/bandwidth</td></tr>
<tr><td><strong>Encryption</strong></td><td>Secure data</td><td>AES-256-GCM, ChaCha20</td><td>Data protection</td></tr>
<tr><td><strong>Transform</strong></td><td>Modify structure</td><td>Format conversion</td><td>Data reshaping</td></tr>
<tr><td><strong>Checksum</strong></td><td>Verify integrity</td><td>SHA-256, SHA-512, Blake3</td><td>Data validation</td></tr>
<tr><td><strong>PassThrough</strong></td><td>No modification</td><td>Identity transform</td><td>Testing/debugging</td></tr>
</tbody></table>
</div>
<h3 id="parsing-stage-types"><a class="header" href="#parsing-stage-types">Parsing Stage Types</a></h3>
<p>Stage types support case-insensitive parsing from strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adaptive_pipeline_domain::entities::pipeline_stage::StageType;
use std::str::FromStr;

// Parse from lowercase
let compression = StageType::from_str("compression").unwrap();
assert_eq!(compression, StageType::Compression);

// Case-insensitive parsing
let encryption = StageType::from_str("ENCRYPTION").unwrap();
assert_eq!(encryption, StageType::Encryption);

// Display format
assert_eq!(format!("{}", StageType::Checksum), "checksum");
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn describe_stage(stage_type: StageType) -&gt; &amp;'static str {
    match stage_type {
        StageType::Compression =&gt; "Reduces data size",
        StageType::Encryption =&gt; "Secures data",
        StageType::Transform =&gt; "Modifies data structure",
        StageType::Checksum =&gt; "Verifies data integrity",
        StageType::PassThrough =&gt; "No modification",
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="stage-entity"><a class="header" href="#stage-entity">Stage Entity</a></h2>
<p>The <code>PipelineStage</code> is a domain entity that encapsulates a specific data transformation operation within a pipeline.</p>
<h3 id="entity-structure"><a class="header" href="#entity-structure">Entity Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PipelineStage {
    id: StageId,
    name: String,
    stage_type: StageType,
    configuration: StageConfiguration,
    enabled: bool,
    order: u32,
    created_at: chrono::DateTime&lt;chrono::Utc&gt;,
    updated_at: chrono::DateTime&lt;chrono::Utc&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="entity-characteristics"><a class="header" href="#entity-characteristics">Entity Characteristics</a></h3>
<ul>
<li><strong>Identity</strong>: Unique <code>StageId</code> persists through configuration changes</li>
<li><strong>Name</strong>: Human-readable identifier (must not be empty)</li>
<li><strong>Type</strong>: Strongly-typed operation (Compression, Encryption, etc.)</li>
<li><strong>Configuration</strong>: Algorithm-specific parameters</li>
<li><strong>Enabled Flag</strong>: Controls execution without removal</li>
<li><strong>Order</strong>: Determines execution sequence (0-based)</li>
<li><strong>Timestamps</strong>: Track creation and modification times</li>
</ul>
<h3 id="creating-a-stage"><a class="header" href="#creating-a-stage">Creating a Stage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adaptive_pipeline_domain::entities::pipeline_stage::{PipelineStage, StageConfiguration, StageType};
use std::collections::HashMap;

let mut params = HashMap::new();
params.insert("level".to_string(), "6".to_string());

let config = StageConfiguration::new("brotli".to_string(), params, true);
let stage = PipelineStage::new(
    "compression".to_string(),
    StageType::Compression,
    config,
    0  // Order: execute first
).unwrap();

assert_eq!(stage.name(), "compression");
assert_eq!(stage.stage_type(), &amp;StageType::Compression);
assert_eq!(stage.algorithm(), "brotli");
assert!(stage.is_enabled());
<span class="boring">}</span></code></pre></pre>
<h3 id="modifying-stage-state"><a class="header" href="#modifying-stage-state">Modifying Stage State</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stage = PipelineStage::new(
    "checksum".to_string(),
    StageType::Checksum,
    StageConfiguration::default(),
    0,
).unwrap();

// Disable the stage temporarily
stage.set_enabled(false);
assert!(!stage.is_enabled());

// Update configuration
let mut new_params = HashMap::new();
new_params.insert("algorithm".to_string(), "sha512".to_string());
let new_config = StageConfiguration::new("sha512".to_string(), new_params, true);
stage.update_configuration(new_config);

// Change execution order
stage.update_order(2);
assert_eq!(stage.order(), 2);

// Re-enable the stage
stage.set_enabled(true);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="stage-configuration"><a class="header" href="#stage-configuration">Stage Configuration</a></h2>
<p>Each stage has a configuration that specifies how data should be transformed.</p>
<h3 id="configuration-structure"><a class="header" href="#configuration-structure">Configuration Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StageConfiguration {
    pub algorithm: String,
    pub parameters: HashMap&lt;String, String&gt;,
    pub parallel_processing: bool,
    pub chunk_size: Option&lt;usize&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-parameters"><a class="header" href="#configuration-parameters">Configuration Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>algorithm</code></td><td>String</td><td>Algorithm name (e.g., "brotli", "aes256gcm")</td><td>"default"</td></tr>
<tr><td><code>parameters</code></td><td>HashMap</td><td>Algorithm-specific key-value parameters</td><td>{}</td></tr>
<tr><td><code>parallel_processing</code></td><td>bool</td><td>Enable parallel chunk processing</td><td>true</td></tr>
<tr><td><code>chunk_size</code></td><td>Option&lt;usize&gt;</td><td>Custom chunk size (1KB - 100MB)</td><td>None</td></tr>
</tbody></table>
</div>
<h3 id="compression-configuration"><a class="header" href="#compression-configuration">Compression Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut params = HashMap::new();
params.insert("level".to_string(), "9".to_string());

let config = StageConfiguration::new(
    "zstd".to_string(),
    params,
    true,  // Enable parallel processing
);
<span class="boring">}</span></code></pre></pre>
<h3 id="encryption-configuration"><a class="header" href="#encryption-configuration">Encryption Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut params = HashMap::new();
params.insert("key_size".to_string(), "256".to_string());

let config = StageConfiguration::new(
    "aes256gcm".to_string(),
    params,
    false,  // Sequential processing for encryption
);
<span class="boring">}</span></code></pre></pre>
<h3 id="default-configuration"><a class="header" href="#default-configuration">Default Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = StageConfiguration::default();
// algorithm: "default"
// parameters: {}
// parallel_processing: true
// chunk_size: None
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="stage-lifecycle"><a class="header" href="#stage-lifecycle">Stage Lifecycle</a></h2>
<p>Stages progress through several lifecycle phases from creation to execution.</p>
<h3 id="lifecycle-phases"><a class="header" href="#lifecycle-phases">Lifecycle Phases</a></h3>
<pre><code class="language-text">1. Creation
   ↓
2. Configuration
   ↓
3. Ordering
   ↓
4. Execution
   ↓
5. Monitoring
</code></pre>
<h3 id="1-creation-phase"><a class="header" href="#1-creation-phase">1. Creation Phase</a></h3>
<p>Stages are created with initial configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stage = PipelineStage::new(
    "compression".to_string(),
    StageType::Compression,
    StageConfiguration::default(),
    0,
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-configuration-phase"><a class="header" href="#2-configuration-phase">2. Configuration Phase</a></h3>
<p>Parameters can be updated as needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stage.update_configuration(new_config);
// updated_at timestamp is automatically updated
<span class="boring">}</span></code></pre></pre>
<h3 id="3-ordering-phase"><a class="header" href="#3-ordering-phase">3. Ordering Phase</a></h3>
<p>Position in pipeline can be adjusted:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stage.update_order(1);
// Stage now executes second instead of first
<span class="boring">}</span></code></pre></pre>
<h3 id="4-execution-phase"><a class="header" href="#4-execution-phase">4. Execution Phase</a></h3>
<p>Stage processes data according to its configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let executor: Arc&lt;dyn StageExecutor&gt; = /* ... */;
let result = executor.execute(&amp;stage, chunk, &amp;mut context).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="5-monitoring-phase"><a class="header" href="#5-monitoring-phase">5. Monitoring Phase</a></h3>
<p>Timestamps track when changes occur:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Created: {}", stage.created_at());
println!("Last modified: {}", stage.updated_at());
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="stage-execution-model"><a class="header" href="#stage-execution-model">Stage Execution Model</a></h2>
<p>The stage executor processes file chunks through configured stages using two primary execution modes.</p>
<h3 id="single-chunk-processing"><a class="header" href="#single-chunk-processing">Single Chunk Processing</a></h3>
<p>Process individual chunks sequentially:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn execute(
    &amp;self,
    stage: &amp;PipelineStage,
    chunk: FileChunk,
    context: &amp;mut ProcessingContext,
) -&gt; Result&lt;FileChunk, PipelineError&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong>Execution Flow:</strong></p>
<pre><code class="language-text">Input Chunk → Validate → Process → Update Context → Output Chunk
</code></pre>
<h3 id="parallel-processing"><a class="header" href="#parallel-processing">Parallel Processing</a></h3>
<p>Process multiple chunks concurrently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn execute_parallel(
    &amp;self,
    stage: &amp;PipelineStage,
    chunks: Vec&lt;FileChunk&gt;,
    context: &amp;mut ProcessingContext,
) -&gt; Result&lt;Vec&lt;FileChunk&gt;, PipelineError&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong>Execution Flow:</strong></p>
<pre><code class="language-text">Chunks: [1, 2, 3, 4]
         ↓  ↓  ↓  ↓
      ┌────┬───┬───┬────┐
      │ T1 │T2 │T3 │ T4 │  (Parallel threads)
      └────┴───┴───┴────┘
         ↓  ↓  ↓  ↓
Results: [1, 2, 3, 4]
</code></pre>
<h3 id="processing-context"><a class="header" href="#processing-context">Processing Context</a></h3>
<p>The <code>ProcessingContext</code> maintains state during execution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProcessingContext {
    pub pipeline_id: String,
    pub stage_metrics: HashMap&lt;String, StageMetrics&gt;,
    pub checksums: HashMap&lt;String, Vec&lt;u8&gt;&gt;,
    // ... other context fields
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="stage-executor-interface"><a class="header" href="#stage-executor-interface">Stage Executor Interface</a></h2>
<p>The <code>StageExecutor</code> trait defines the contract for stage execution engines.</p>
<h3 id="trait-definition"><a class="header" href="#trait-definition">Trait Definition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait StageExecutor: Send + Sync {
    /// Execute a stage on a single chunk
    async fn execute(
        &amp;self,
        stage: &amp;PipelineStage,
        chunk: FileChunk,
        context: &amp;mut ProcessingContext,
    ) -&gt; Result&lt;FileChunk, PipelineError&gt;;

    /// Execute a stage on multiple chunks in parallel
    async fn execute_parallel(
        &amp;self,
        stage: &amp;PipelineStage,
        chunks: Vec&lt;FileChunk&gt;,
        context: &amp;mut ProcessingContext,
    ) -&gt; Result&lt;Vec&lt;FileChunk&gt;, PipelineError&gt;;

    /// Validate if a stage can be executed
    async fn can_execute(&amp;self, stage: &amp;PipelineStage) -&gt; Result&lt;bool, PipelineError&gt;;

    /// Get supported stage types
    fn supported_stage_types(&amp;self) -&gt; Vec&lt;String&gt;;

    /// Estimate processing time for a stage
    async fn estimate_processing_time(
        &amp;self,
        stage: &amp;PipelineStage,
        data_size: u64,
    ) -&gt; Result&lt;std::time::Duration, PipelineError&gt;;

    /// Get resource requirements for a stage
    async fn get_resource_requirements(
        &amp;self,
        stage: &amp;PipelineStage,
        data_size: u64,
    ) -&gt; Result&lt;ResourceRequirements, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="basicstageexecutor-implementation"><a class="header" href="#basicstageexecutor-implementation">BasicStageExecutor Implementation</a></h3>
<p>The infrastructure layer provides a concrete implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BasicStageExecutor {
    checksums: Arc&lt;RwLock&lt;HashMap&lt;String, Sha256&gt;&gt;&gt;,
    compression_service: Arc&lt;dyn CompressionService&gt;,
    encryption_service: Arc&lt;dyn EncryptionService&gt;,
}

impl BasicStageExecutor {
    pub fn new(
        compression_service: Arc&lt;dyn CompressionService&gt;,
        encryption_service: Arc&lt;dyn EncryptionService&gt;,
    ) -&gt; Self {
        Self {
            checksums: Arc::new(RwLock::new(HashMap::new())),
            compression_service,
            encryption_service,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="supported-stage-types"><a class="header" href="#supported-stage-types">Supported Stage Types</a></h3>
<p>The <code>BasicStageExecutor</code> supports:</p>
<ul>
<li><strong>Compression</strong>: Via <code>CompressionService</code> (Brotli, Gzip, Zstd, Lz4)</li>
<li><strong>Encryption</strong>: Via <code>EncryptionService</code> (AES-256-GCM, ChaCha20-Poly1305)</li>
<li><strong>Checksum</strong>: Via internal SHA-256 implementation</li>
</ul>
<hr />
<h2 id="compatibility-and-ordering"><a class="header" href="#compatibility-and-ordering">Compatibility and Ordering</a></h2>
<p>Stages have compatibility rules that ensure optimal pipeline performance.</p>
<h3 id="recommended-ordering"><a class="header" href="#recommended-ordering">Recommended Ordering</a></h3>
<pre><code class="language-text">1. Input Checksum (automatic)
   ↓
2. Compression (reduces data size)
   ↓
3. Encryption (secures compressed data)
   ↓
4. Output Checksum (automatic)
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li>Compress before encrypting to reduce encrypted payload size</li>
<li>Checksum before compression to detect input corruption early</li>
<li>Checksum after encryption to verify output integrity</li>
</ul>
<h3 id="compatibility-matrix"><a class="header" href="#compatibility-matrix">Compatibility Matrix</a></h3>
<pre><code class="language-text">From \ To      | Compression | Encryption | Checksum | PassThrough | Transform
---------------|-------------|------------|----------|-------------|----------
Compression    | ❌ No       | ✅ Yes     | ✅ Yes   | ✅ Yes      | ⚠️ Rare
Encryption     | ❌ No       | ❌ No      | ✅ Yes   | ✅ Yes      | ❌ No
Checksum       | ✅ Yes      | ✅ Yes     | ✅ Yes   | ✅ Yes      | ✅ Yes
PassThrough    | ✅ Yes      | ✅ Yes     | ✅ Yes   | ✅ Yes      | ✅ Yes
Transform      | ✅ Yes      | ✅ Yes     | ✅ Yes   | ✅ Yes      | ⚠️ Depends
</code></pre>
<p><strong>Legend:</strong></p>
<ul>
<li>✅ Yes: Recommended combination</li>
<li>❌ No: Not recommended (avoid duplication or inefficiency)</li>
<li>⚠️ Rare/Depends: Context-dependent</li>
</ul>
<h3 id="checking-compatibility"><a class="header" href="#checking-compatibility">Checking Compatibility</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let compression = PipelineStage::new(
    "compression".to_string(),
    StageType::Compression,
    StageConfiguration::default(),
    0,
).unwrap();

let encryption = PipelineStage::new(
    "encryption".to_string(),
    StageType::Encryption,
    StageConfiguration::default(),
    1,
).unwrap();

// Compression should come before encryption
assert!(compression.is_compatible_with(&amp;encryption));
<span class="boring">}</span></code></pre></pre>
<h3 id="compatibility-rules"><a class="header" href="#compatibility-rules">Compatibility Rules</a></h3>
<p>The <code>is_compatible_with</code> method implements these rules:</p>
<ol>
<li><strong>Compression → Encryption</strong>: ✅ Compress first, then encrypt</li>
<li><strong>Compression → Compression</strong>: ❌ Avoid double compression</li>
<li><strong>Encryption → Encryption</strong>: ❌ Avoid double encryption</li>
<li><strong>Encryption → Compression</strong>: ❌ Cannot compress encrypted data effectively</li>
<li><strong>PassThrough → Any</strong>: ✅ No restrictions</li>
<li><strong>Checksum → Any</strong>: ✅ Checksums compatible with everything</li>
</ol>
<hr />
<h2 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h2>
<p>Stages provide resource estimation and requirements to enable efficient execution planning.</p>
<h3 id="resource-requirements"><a class="header" href="#resource-requirements">Resource Requirements</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct ResourceRequirements {
    pub memory_bytes: u64,
    pub cpu_cores: u32,
    pub disk_space_bytes: u64,
    pub network_bandwidth_bps: Option&lt;u64&gt;,
    pub gpu_memory_bytes: Option&lt;u64&gt;,
    pub estimated_duration: std::time::Duration,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="default-requirements"><a class="header" href="#default-requirements">Default Requirements</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ResourceRequirements::default()
// memory_bytes: 64 MB
// cpu_cores: 1
// disk_space_bytes: 0
// network_bandwidth_bps: None
// gpu_memory_bytes: None
// estimated_duration: 1 second
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-requirements"><a class="header" href="#custom-requirements">Custom Requirements</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let requirements = ResourceRequirements::new(
    128 * 1024 * 1024,  // 128 MB memory
    4,                   // 4 CPU cores
    1024 * 1024 * 1024, // 1 GB disk space
)
.with_duration(Duration::from_secs(30))
.with_network_bandwidth(100_000_000); // 100 Mbps
<span class="boring">}</span></code></pre></pre>
<h3 id="estimating-resources"><a class="header" href="#estimating-resources">Estimating Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let executor: Arc&lt;dyn StageExecutor&gt; = /* ... */;
let requirements = executor.get_resource_requirements(
    &amp;stage,
    10 * 1024 * 1024,  // 10 MB data size
).await?;

println!("Memory required: {}", Byte::from_bytes(requirements.memory_bytes));
println!("CPU cores: {}", requirements.cpu_cores);
println!("Estimated time: {:?}", requirements.estimated_duration);
<span class="boring">}</span></code></pre></pre>
<h3 id="scaling-requirements"><a class="header" href="#scaling-requirements">Scaling Requirements</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut requirements = ResourceRequirements::default();
requirements.scale(2.0);  // Double all requirements
<span class="boring">}</span></code></pre></pre>
<h3 id="merging-requirements"><a class="header" href="#merging-requirements">Merging Requirements</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut req1 = ResourceRequirements::default();
let req2 = ResourceRequirements::new(256_000_000, 2, 0);
req1.merge(&amp;req2);  // Takes maximum of each field
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="example-1-creating-a-compression-stage"><a class="header" href="#example-1-creating-a-compression-stage">Example 1: Creating a Compression Stage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adaptive_pipeline_domain::entities::pipeline_stage::{PipelineStage, StageConfiguration, StageType};
use std::collections::HashMap;

let mut params = HashMap::new();
params.insert("level".to_string(), "9".to_string());

let config = StageConfiguration::new(
    "zstd".to_string(),
    params,
    true,  // Enable parallel processing
);

let compression_stage = PipelineStage::new(
    "fast-compression".to_string(),
    StageType::Compression,
    config,
    1,  // Execute after input checksum (order 0)
)?;

println!("Created stage: {}", compression_stage.name());
println!("Algorithm: {}", compression_stage.algorithm());
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-creating-an-encryption-stage"><a class="header" href="#example-2-creating-an-encryption-stage">Example 2: Creating an Encryption Stage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut params = HashMap::new();
params.insert("key_size".to_string(), "256".to_string());

let config = StageConfiguration::new(
    "aes256gcm".to_string(),
    params,
    false,  // Sequential processing for security
);

let encryption_stage = PipelineStage::new(
    "secure-encryption".to_string(),
    StageType::Encryption,
    config,
    2,  // Execute after compression
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="example-3-building-a-complete-pipeline"><a class="header" href="#example-3-building-a-complete-pipeline">Example 3: Building a Complete Pipeline</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stages = Vec::new();

// Stage 0: Input checksum
let checksum_in = PipelineStage::new(
    "input-checksum".to_string(),
    StageType::Checksum,
    StageConfiguration::new("sha256".to_string(), HashMap::new(), true),
    0,
)?;
stages.push(checksum_in);

// Stage 1: Compression
let mut compress_params = HashMap::new();
compress_params.insert("level".to_string(), "6".to_string());
let compression = PipelineStage::new(
    "compression".to_string(),
    StageType::Compression,
    StageConfiguration::new("brotli".to_string(), compress_params, true),
    1,
)?;
stages.push(compression);

// Stage 2: Encryption
let mut encrypt_params = HashMap::new();
encrypt_params.insert("key_size".to_string(), "256".to_string());
let encryption = PipelineStage::new(
    "encryption".to_string(),
    StageType::Encryption,
    StageConfiguration::new("aes256gcm".to_string(), encrypt_params, false),
    2,
)?;
stages.push(encryption);

// Stage 3: Output checksum
let checksum_out = PipelineStage::new(
    "output-checksum".to_string(),
    StageType::Checksum,
    StageConfiguration::new("sha256".to_string(), HashMap::new(), true),
    3,
)?;
stages.push(checksum_out);

// Validate compatibility
for i in 0..stages.len() - 1 {
    assert!(stages[i].is_compatible_with(&amp;stages[i + 1]));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-4-executing-a-stage"><a class="header" href="#example-4-executing-a-stage">Example 4: Executing a Stage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adaptive_pipeline_domain::repositories::stage_executor::StageExecutor;

let executor: Arc&lt;dyn StageExecutor&gt; = /* ... */;
let stage = /* ... */;
let chunk = FileChunk::new(0, vec![1, 2, 3, 4, 5]);
let mut context = ProcessingContext::new("pipeline-123");

// Execute single chunk
let result = executor.execute(&amp;stage, chunk, &amp;mut context).await?;

println!("Processed {} bytes", result.data().len());
<span class="boring">}</span></code></pre></pre>
<h3 id="example-5-parallel-execution"><a class="header" href="#example-5-parallel-execution">Example 5: Parallel Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let chunks = vec![
    FileChunk::new(0, vec![1, 2, 3]),
    FileChunk::new(1, vec![4, 5, 6]),
    FileChunk::new(2, vec![7, 8, 9]),
];

let results = executor.execute_parallel(&amp;stage, chunks, &amp;mut context).await?;

println!("Processed {} chunks", results.len());
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="chunk-size-selection"><a class="header" href="#chunk-size-selection">Chunk Size Selection</a></h3>
<p>Chunk size significantly impacts stage performance:</p>
<div class="table-wrapper"><table><thead><tr><th>Data Size</th><th>Recommended Chunk Size</th><th>Rationale</th></tr></thead><tbody>
<tr><td>&lt; 10 MB</td><td>1 MB</td><td>Minimize overhead</td></tr>
<tr><td>10-100 MB</td><td>2-4 MB</td><td>Balance memory/IO</td></tr>
<tr><td>100 MB - 1 GB</td><td>4-8 MB</td><td>Optimize parallelization</td></tr>
<tr><td>&gt; 1 GB</td><td>8-16 MB</td><td>Maximize throughput</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut config = StageConfiguration::default();
config.chunk_size = Some(4 * 1024 * 1024);  // 4 MB chunks
<span class="boring">}</span></code></pre></pre>
<h3 id="parallel-processing-1"><a class="header" href="#parallel-processing-1">Parallel Processing</a></h3>
<p>Enable parallel processing for CPU-bound operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compression: parallel processing beneficial
let compress_config = StageConfiguration::new(
    "zstd".to_string(),
    HashMap::new(),
    true,  // Enable parallel
);

// Encryption: sequential often better for security
let encrypt_config = StageConfiguration::new(
    "aes256gcm".to_string(),
    HashMap::new(),
    false,  // Disable parallel
);
<span class="boring">}</span></code></pre></pre>
<h3 id="stage-ordering-impact"><a class="header" href="#stage-ordering-impact">Stage Ordering Impact</a></h3>
<p><strong>Optimal:</strong></p>
<pre><code class="language-text">Checksum → Compress (6:1 ratio) → Encrypt → Checksum
1 GB → 1 GB → 167 MB → 167 MB → 167 MB
</code></pre>
<p><strong>Suboptimal:</strong></p>
<pre><code class="language-text">Checksum → Encrypt → Compress (1.1:1 ratio) → Checksum
1 GB → 1 GB → 1 GB → 909 MB → 909 MB
</code></pre>
<p>Encrypting before compression reduces compression ratio from 6:1 to 1.1:1.</p>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<p>Per-stage memory usage:</p>
<div class="table-wrapper"><table><thead><tr><th>Stage Type</th><th>Memory per Chunk</th><th>Notes</th></tr></thead><tbody>
<tr><td>Compression</td><td>2-3x chunk size</td><td>Compression buffers</td></tr>
<tr><td>Encryption</td><td>1-1.5x chunk size</td><td>Encryption overhead</td></tr>
<tr><td>Checksum</td><td>~256 bytes</td><td>Hash state only</td></tr>
<tr><td>PassThrough</td><td>1x chunk size</td><td>No additional memory</td></tr>
</tbody></table>
</div>
<h3 id="cpu-utilization"><a class="header" href="#cpu-utilization">CPU Utilization</a></h3>
<p>CPU-intensive stages:</p>
<ol>
<li><strong>Compression</strong>: High CPU usage (especially Brotli level 9+)</li>
<li><strong>Encryption</strong>: Moderate CPU usage (AES-NI acceleration helps)</li>
<li><strong>Checksum</strong>: Low CPU usage (Blake3 faster than SHA-256)</li>
</ol>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-stage-naming"><a class="header" href="#1-stage-naming">1. Stage Naming</a></h3>
<p>Use descriptive, kebab-case names:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good
"input-checksum", "fast-compression", "secure-encryption"

// ❌ Bad
"stage1", "s", "MyStage"
<span class="boring">}</span></code></pre></pre>
<h3 id="2-configuration-validation"><a class="header" href="#2-configuration-validation">2. Configuration Validation</a></h3>
<p>Always validate configurations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stage = PipelineStage::new(/* ... */)?;
stage.validate()?;  // Validate before execution
<span class="boring">}</span></code></pre></pre>
<h3 id="3-optimal-ordering"><a class="header" href="#3-optimal-ordering">3. Optimal Ordering</a></h3>
<p>Follow the recommended order:</p>
<pre><code class="language-text">1. Input Checksum
2. Compression
3. Encryption
4. Output Checksum
</code></pre>
<h3 id="4-enabledisable-vs-remove"><a class="header" href="#4-enabledisable-vs-remove">4. Enable/Disable vs. Remove</a></h3>
<p>Prefer disabling over removing stages:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Preserve configuration
stage.set_enabled(false);

// ❌ Bad: Lose configuration
stages.retain(|s| s.name() != "compression");
<span class="boring">}</span></code></pre></pre>
<h3 id="5-resource-estimation"><a class="header" href="#5-resource-estimation">5. Resource Estimation</a></h3>
<p>Estimate resources before execution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let requirements = executor.get_resource_requirements(&amp;stage, file_size).await?;

if requirements.memory_bytes &gt; available_memory {
    // Adjust chunk size or process sequentially
}
<span class="boring">}</span></code></pre></pre>
<h3 id="6-error-handling"><a class="header" href="#6-error-handling">6. Error Handling</a></h3>
<p>Handle stage-specific errors appropriately:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match executor.execute(&amp;stage, chunk, &amp;mut context).await {
    Ok(result) =&gt; { /* success */ },
    Err(PipelineError::CompressionFailed(msg)) =&gt; {
        // Handle compression errors
    },
    Err(PipelineError::EncryptionFailed(msg)) =&gt; {
        // Handle encryption errors
    },
    Err(e) =&gt; {
        // Handle generic errors
    },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="7-monitoring"><a class="header" href="#7-monitoring">7. Monitoring</a></h3>
<p>Track stage execution metrics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let start = Instant::now();
let result = executor.execute(&amp;stage, chunk, &amp;mut context).await?;
let duration = start.elapsed();

println!("Stage '{}' processed {} bytes in {:?}",
    stage.name(),
    result.data().len(),
    duration
);
<span class="boring">}</span></code></pre></pre>
<h3 id="8-testing"><a class="header" href="#8-testing">8. Testing</a></h3>
<p>Test stages in isolation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_compression_stage() {
    let stage = create_compression_stage();
    let executor = create_test_executor();
    let chunk = FileChunk::new(0, vec![0u8; 1024]);
    let mut context = ProcessingContext::new("test");

    let result = executor.execute(&amp;stage, chunk, &amp;mut context).await.unwrap();

    assert!(result.data().len() &lt; 1024);  // Compression worked
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="issue-1-stage-validation-fails"><a class="header" href="#issue-1-stage-validation-fails">Issue 1: Stage Validation Fails</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Error: InvalidConfiguration("Stage name cannot be empty")
</code></pre>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ensure stage name is not empty
let stage = PipelineStage::new(
    "my-stage".to_string(),  // ✅ Non-empty name
    stage_type,
    config,
    order,
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-2-incompatible-stage-order"><a class="header" href="#issue-2-incompatible-stage-order">Issue 2: Incompatible Stage Order</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Error: IncompatibleStages("Cannot encrypt before compressing")
</code></pre>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check compatibility before adding stages
if !previous_stage.is_compatible_with(&amp;new_stage) {
    // Reorder stages
}
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-3-chunk-size-validation-error"><a class="header" href="#issue-3-chunk-size-validation-error">Issue 3: Chunk Size Validation Error</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Error: InvalidConfiguration("Chunk size must be between 1KB and 100MB")
</code></pre>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut config = StageConfiguration::default();
config.chunk_size = Some(4 * 1024 * 1024);  // ✅ 4 MB (valid range)
// config.chunk_size = Some(512);  // ❌ Too small (&lt; 1KB)
// config.chunk_size = Some(200_000_000);  // ❌ Too large (&gt; 100MB)
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-4-out-of-memory-during-execution"><a class="header" href="#issue-4-out-of-memory-during-execution">Issue 4: Out of Memory During Execution</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Error: ResourceExhaustion("Insufficient memory for stage execution")
</code></pre>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Reduce chunk size or disable parallel processing
let mut config = stage.configuration().clone();
config.chunk_size = Some(1 * 1024 * 1024);  // Reduce to 1 MB
config.parallel_processing = false;  // Disable parallel
stage.update_configuration(config);
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-5-stage-executor-not-found"><a class="header" href="#issue-5-stage-executor-not-found">Issue 5: Stage Executor Not Found</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Error: ExecutorNotFound("No executor for stage type 'CustomStage'")
</code></pre>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check supported stage types
let supported = executor.supported_stage_types();
println!("Supported: {:?}", supported);

// Use a supported stage type
let stage = PipelineStage::new(
    "compression".to_string(),
    StageType::Compression,  // ✅ Supported type
    config,
    0,
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-6-performance-degradation"><a class="header" href="#issue-6-performance-degradation">Issue 6: Performance Degradation</a></h3>
<p><strong>Symptom:</strong> Stage execution is slower than expected.</p>
<p><strong>Diagnosis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let requirements = executor.get_resource_requirements(&amp;stage, file_size).await?;
let duration = executor.estimate_processing_time(&amp;stage, file_size).await?;

println!("Expected duration: {:?}", duration);
println!("Memory needed: {}", Byte::from_bytes(requirements.memory_bytes));
<span class="boring">}</span></code></pre></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Enable parallel processing for compression stages</li>
<li>Increase chunk size for large files</li>
<li>Use faster algorithms (e.g., Lz4 instead of Brotli)</li>
<li>Check system resource availability</li>
</ul>
<hr />
<h2 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<p>Test individual stage operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_stage_creation() {
    let stage = PipelineStage::new(
        "test-stage".to_string(),
        StageType::Compression,
        StageConfiguration::default(),
        0,
    );
    assert!(stage.is_ok());
}

#[test]
fn test_stage_validation() {
    let stage = PipelineStage::new(
        "".to_string(),  // Empty name
        StageType::Compression,
        StageConfiguration::default(),
        0,
    );
    assert!(stage.is_err());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>Test stage execution with real executors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_compression_integration() {
    let compression_service = create_compression_service();
    let encryption_service = create_encryption_service();
    let executor = BasicStageExecutor::new(compression_service, encryption_service);

    let stage = create_compression_stage();
    let chunk = FileChunk::new(0, vec![0u8; 10000]);
    let mut context = ProcessingContext::new("test-pipeline");

    let result = executor.execute(&amp;stage, chunk, &amp;mut context).await.unwrap();

    assert!(result.data().len() &lt; 10000);  // Verify compression
}
<span class="boring">}</span></code></pre></pre>
<h3 id="property-based-tests"><a class="header" href="#property-based-tests">Property-Based Tests</a></h3>
<p>Test stage invariants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[quickcheck]
fn stage_order_preserved(order: u32) -&gt; bool {
    let stage = PipelineStage::new(
        "test".to_string(),
        StageType::Checksum,
        StageConfiguration::default(),
        order,
    ).unwrap();

    stage.order() == order
}
<span class="boring">}</span></code></pre></pre>
<h3 id="compatibility-tests"><a class="header" href="#compatibility-tests">Compatibility Tests</a></h3>
<p>Test stage compatibility matrix:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_compression_encryption_compatibility() {
    let compression = create_stage(StageType::Compression, 0);
    let encryption = create_stage(StageType::Encryption, 1);

    assert!(compression.is_compatible_with(&amp;encryption));
    assert!(encryption.is_compatible_with(&amp;create_stage(StageType::Checksum, 2)));
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>After understanding stage processing fundamentals, explore specific implementations:</p>
<h3 id="detailed-stage-implementations"><a class="header" href="#detailed-stage-implementations">Detailed Stage Implementations</a></h3>
<ol>
<li><strong><a href="compression.html">Compression</a></strong>: Deep dive into compression algorithms and performance tuning</li>
<li><strong><a href="encryption.html">Encryption</a></strong>: Encryption implementation, key management, and security considerations</li>
<li><strong><a href="integrity.html">Integrity Checking</a></strong>: Checksum algorithms and verification strategies</li>
</ol>
<h3 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h3>
<ul>
<li><strong><a href="persistence.html">Data Persistence</a></strong>: How stages are persisted and retrieved from the database</li>
<li><strong><a href="file-io.html">File I/O</a></strong>: File chunking and binary format for stage data</li>
<li><strong><a href="observability.html">Observability</a></strong>: Monitoring stage execution and performance</li>
</ul>
<h3 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h3>
<ul>
<li><strong><a href="../advanced/concurrency.html">Concurrency Model</a></strong>: Parallel stage execution and thread pooling</li>
<li><strong><a href="../advanced/performance.html">Performance Optimization</a></strong>: Benchmarking and profiling stages</li>
<li><strong><a href="../advanced/custom-stages.html">Custom Stages</a></strong>: Implementing custom stage types</li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><strong>Key Takeaways:</strong></p>
<ol>
<li><strong>Stages</strong> are the fundamental building blocks of pipelines, each performing a specific transformation</li>
<li><strong>Five stage types</strong> are supported: Compression, Encryption, Transform, Checksum, PassThrough</li>
<li><strong>PipelineStage</strong> is a domain entity with identity, configuration, and lifecycle management</li>
<li><strong>Stage compatibility</strong> rules ensure optimal ordering (compress before encrypt)</li>
<li><strong>StageExecutor</strong> trait provides async execution with resource estimation</li>
<li><strong>Resource management</strong> enables efficient execution planning and monitoring</li>
<li><strong>Best practices</strong> include proper naming, validation, and error handling</li>
</ol>
<p><strong>Configuration File Reference:</strong> <code>pipeline/src/domain/entities/pipeline_stage.rs</code>
<strong>Executor Interface:</strong> <code>pipeline-domain/src/repositories/stage_executor.rs:156</code>
<strong>Executor Implementation:</strong> <code>pipeline/src/infrastructure/repositories/stage_executor.rs:175</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/observer-pattern.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../implementation/compression.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/observer-pattern.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../implementation/compression.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
