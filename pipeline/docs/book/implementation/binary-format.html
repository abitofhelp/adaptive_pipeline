<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Binary Format - Pipeline Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pipeline Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="binary-file-format"><a class="header" href="#binary-file-format">Binary File Format</a></h1>
<p><strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner, Claude Code
<strong>Status:</strong> Active</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The Adaptive Pipeline uses a custom binary file format (<code>.adapipe</code>) to store processed files with complete recovery metadata and integrity verification. This format enables perfect restoration of original files while maintaining processing history and security.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Complete Recovery</strong>: All metadata needed to restore original files</li>
<li><strong>Integrity Verification</strong>: SHA-256 checksums for both input and output</li>
<li><strong>Processing History</strong>: Complete record of all processing steps</li>
<li><strong>Format Versioning</strong>: Backward compatibility through version management</li>
<li><strong>Security</strong>: Supports encryption with nonce management</li>
</ul>
<h2 id="file-format-specification"><a class="header" href="#file-format-specification">File Format Specification</a></h2>
<h3 id="binary-layout"><a class="header" href="#binary-layout">Binary Layout</a></h3>
<p>The <code>.adapipe</code> format uses a reverse-header design for efficient processing:</p>
<pre><code class="language-text">┌─────────────────────────────────────────────┐
│          PROCESSED CHUNK DATA               │
│         (variable length)                   │
│  - Compressed and/or encrypted chunks       │
│  - Each chunk: [NONCE][LENGTH][DATA]        │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│          JSON HEADER                        │
│         (variable length)                   │
│  - Processing metadata                      │
│  - Recovery information                     │
│  - Checksums                                │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│      HEADER_LENGTH (4 bytes, u32 LE)        │
│  - Length of JSON header in bytes           │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│    FORMAT_VERSION (2 bytes, u16 LE)         │
│  - Current version: 1                       │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│      MAGIC_BYTES (8 bytes)                  │
│  - "ADAPIPE\0" (0x4144415049504500)         │
└─────────────────────────────────────────────┘
</code></pre>
<p><strong>Why Reverse Header?</strong></p>
<ul>
<li><strong>Efficient Reading</strong>: Read magic bytes and version first</li>
<li><strong>Validation</strong>: Quickly validate format without reading entire file</li>
<li><strong>Streaming</strong>: Process chunk data while reading header</li>
<li><strong>Metadata Location</strong>: Header location calculated from end of file</li>
</ul>
<h3 id="magic-bytes"><a class="header" href="#magic-bytes">Magic Bytes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const MAGIC_BYTES: [u8; 8] = [
    0x41, 0x44, 0x41, 0x50, // "ADAP"
    0x49, 0x50, 0x45, 0x00  // "IPE\0"
];
<span class="boring">}</span></code></pre></pre>
<p><strong>Purpose:</strong></p>
<ul>
<li>Identify files in <code>.adapipe</code> format</li>
<li>Prevent accidental processing of wrong file types</li>
<li>Enable format detection tools</li>
</ul>
<h3 id="format-version"><a class="header" href="#format-version">Format Version</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const CURRENT_FORMAT_VERSION: u16 = 1;
<span class="boring">}</span></code></pre></pre>
<p><strong>Version History:</strong></p>
<ul>
<li><strong>Version 1</strong>: Initial format with compression, encryption, checksum support</li>
</ul>
<p><strong>Future Versions:</strong></p>
<ul>
<li>Version 2: Enhanced metadata, additional algorithms</li>
<li>Version 3: Streaming optimizations, compression improvements</li>
</ul>
<h2 id="file-header-structure"><a class="header" href="#file-header-structure">File Header Structure</a></h2>
<h3 id="header-fields"><a class="header" href="#header-fields">Header Fields</a></h3>
<p>The JSON header contains comprehensive metadata:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FileHeader {
    /// Application version (e.g., "0.1.0")
    pub app_version: String,

    /// File format version (1)
    pub format_version: u16,

    /// Original input filename
    pub original_filename: String,

    /// Original file size in bytes
    pub original_size: u64,

    /// SHA-256 checksum of original file
    pub original_checksum: String,

    /// SHA-256 checksum of processed file
    pub output_checksum: String,

    /// Processing steps applied (in order)
    pub processing_steps: Vec&lt;ProcessingStep&gt;,

    /// Chunk size used (bytes)
    pub chunk_size: u32,

    /// Number of chunks
    pub chunk_count: u32,

    /// Processing timestamp (RFC3339)
    pub processed_at: DateTime&lt;Utc&gt;,

    /// Pipeline ID
    pub pipeline_id: String,

    /// Additional metadata
    pub metadata: HashMap&lt;String, String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="processing-steps"><a class="header" href="#processing-steps">Processing Steps</a></h3>
<p>Each processing step records transformation details:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProcessingStep {
    /// Step type (compression, encryption, etc.)
    pub step_type: ProcessingStepType,

    /// Algorithm used (e.g., "brotli", "aes-256-gcm")
    pub algorithm: String,

    /// Algorithm-specific parameters
    pub parameters: HashMap&lt;String, String&gt;,

    /// Application order (0-based)
    pub order: u32,
}

pub enum ProcessingStepType {
    Compression,
    Encryption,
    Checksum,
    PassThrough,
    Custom(String),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Example Processing Steps:</strong></p>
<pre><code class="language-json">{
  "processing_steps": [
    {
      "step_type": "Compression",
      "algorithm": "brotli",
      "parameters": {
        "level": "6"
      },
      "order": 0
    },
    {
      "step_type": "Encryption",
      "algorithm": "aes-256-gcm",
      "parameters": {
        "key_derivation": "argon2"
      },
      "order": 1
    },
    {
      "step_type": "Checksum",
      "algorithm": "sha256",
      "parameters": {},
      "order": 2
    }
  ]
}
</code></pre>
<h2 id="chunk-format"><a class="header" href="#chunk-format">Chunk Format</a></h2>
<h3 id="chunk-structure"><a class="header" href="#chunk-structure">Chunk Structure</a></h3>
<p>Each chunk in the processed data section follows this format:</p>
<pre><code class="language-text">┌────────────────────────────────────┐
│   NONCE (12 bytes)                 │
│  - Unique for each chunk           │
│  - Used for encryption IV          │
└────────────────────────────────────┘
┌────────────────────────────────────┐
│   DATA_LENGTH (4 bytes, u32 LE)    │
│  - Length of encrypted data        │
└────────────────────────────────────┘
┌────────────────────────────────────┐
│   ENCRYPTED_DATA (variable)        │
│  - Compressed and encrypted        │
│  - Includes authentication tag     │
└────────────────────────────────────┘
</code></pre>
<p><strong>Rust Structure:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ChunkFormat {
    /// Encryption nonce (12 bytes for AES-GCM)
    pub nonce: [u8; 12],

    /// Length of encrypted data
    pub data_length: u32,

    /// Encrypted (and possibly compressed) chunk data
    pub encrypted_data: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="chunk-processing"><a class="header" href="#chunk-processing">Chunk Processing</a></h3>
<p><strong>Forward Processing (Compress → Encrypt):</strong></p>
<pre><code class="language-text">1. Read original chunk
2. Compress chunk data
3. Generate unique nonce
4. Encrypt compressed data
5. Write: [NONCE][LENGTH][ENCRYPTED_DATA]
</code></pre>
<p><strong>Reverse Processing (Decrypt → Decompress):</strong></p>
<pre><code class="language-text">1. Read: [NONCE][LENGTH][ENCRYPTED_DATA]
2. Decrypt using nonce
3. Decompress decrypted data
4. Verify checksum
5. Write original chunk
</code></pre>
<h2 id="creating-binary-files"><a class="header" href="#creating-binary-files">Creating Binary Files</a></h2>
<h3 id="basic-file-creation"><a class="header" href="#basic-file-creation">Basic File Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pipeline_domain::value_objects::{FileHeader, ProcessingStep};
use std::fs::File;
use std::io::Write;

fn create_adapipe_file(
    input_data: &amp;[u8],
    output_path: &amp;str,
    processing_steps: Vec&lt;ProcessingStep&gt;,
) -&gt; Result&lt;(), PipelineError&gt; {
    // Create header
    let original_checksum = calculate_sha256(input_data);
    let mut header = FileHeader::new(
        "input.txt".to_string(),
        input_data.len() as u64,
        original_checksum,
    );

    // Add processing steps
    header.processing_steps = processing_steps;
    header.chunk_count = calculate_chunk_count(input_data.len(), header.chunk_size);

    // Process chunks
    let processed_data = process_chunks(input_data, &amp;header.processing_steps)?;

    // Calculate output checksum
    header.output_checksum = calculate_sha256(&amp;processed_data);

    // Serialize header to JSON
    let json_header = serde_json::to_vec(&amp;header)?;
    let header_length = json_header.len() as u32;

    // Write file in reverse order
    let mut file = File::create(output_path)?;

    // 1. Write processed data
    file.write_all(&amp;processed_data)?;

    // 2. Write JSON header
    file.write_all(&amp;json_header)?;

    // 3. Write header length
    file.write_all(&amp;header_length.to_le_bytes())?;

    // 4. Write format version
    file.write_all(&amp;CURRENT_FORMAT_VERSION.to_le_bytes())?;

    // 5. Write magic bytes
    file.write_all(&amp;MAGIC_BYTES)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-processing-steps"><a class="header" href="#adding-processing-steps">Adding Processing Steps</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FileHeader {
    /// Add compression step
    pub fn add_compression_step(mut self, algorithm: &amp;str, level: u32) -&gt; Self {
        let mut parameters = HashMap::new();
        parameters.insert("level".to_string(), level.to_string());

        self.processing_steps.push(ProcessingStep {
            step_type: ProcessingStepType::Compression,
            algorithm: algorithm.to_string(),
            parameters,
            order: self.processing_steps.len() as u32,
        });

        self
    }

    /// Add encryption step
    pub fn add_encryption_step(
        mut self,
        algorithm: &amp;str,
        key_derivation: &amp;str
    ) -&gt; Self {
        let mut parameters = HashMap::new();
        parameters.insert("key_derivation".to_string(), key_derivation.to_string());

        self.processing_steps.push(ProcessingStep {
            step_type: ProcessingStepType::Encryption,
            algorithm: algorithm.to_string(),
            parameters,
            order: self.processing_steps.len() as u32,
        });

        self
    }

    /// Add checksum step
    pub fn add_checksum_step(mut self, algorithm: &amp;str) -&gt; Self {
        self.processing_steps.push(ProcessingStep {
            step_type: ProcessingStepType::Checksum,
            algorithm: algorithm.to_string(),
            parameters: HashMap::new(),
            order: self.processing_steps.len() as u32,
        });

        self
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="reading-binary-files"><a class="header" href="#reading-binary-files">Reading Binary Files</a></h2>
<h3 id="basic-file-reading"><a class="header" href="#basic-file-reading">Basic File Reading</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{Read, Seek, SeekFrom};

fn read_adapipe_file(path: &amp;str) -&gt; Result&lt;FileHeader, PipelineError&gt; {
    let mut file = File::open(path)?;

    // Read from end of file (reverse header)
    file.seek(SeekFrom::End(-8))?;

    // 1. Read and validate magic bytes
    let mut magic = [0u8; 8];
    file.read_exact(&amp;mut magic)?;

    if magic != MAGIC_BYTES {
        return Err(PipelineError::InvalidFormat(
            "Not an .adapipe file".to_string()
        ));
    }

    // 2. Read format version
    file.seek(SeekFrom::End(-10))?;
    let mut version_bytes = [0u8; 2];
    file.read_exact(&amp;mut version_bytes)?;
    let version = u16::from_le_bytes(version_bytes);

    if version &gt; CURRENT_FORMAT_VERSION {
        return Err(PipelineError::UnsupportedVersion(version));
    }

    // 3. Read header length
    file.seek(SeekFrom::End(-14))?;
    let mut length_bytes = [0u8; 4];
    file.read_exact(&amp;mut length_bytes)?;
    let header_length = u32::from_le_bytes(length_bytes) as usize;

    // 4. Read JSON header
    file.seek(SeekFrom::End(-(14 + header_length as i64)))?;
    let mut json_data = vec![0u8; header_length];
    file.read_exact(&amp;mut json_data)?;

    // 5. Deserialize header
    let header: FileHeader = serde_json::from_slice(&amp;json_data)?;

    Ok(header)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reading-chunk-data"><a class="header" href="#reading-chunk-data">Reading Chunk Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_chunks(
    file: &amp;mut File,
    header: &amp;FileHeader
) -&gt; Result&lt;Vec&lt;ChunkFormat&gt;, PipelineError&gt; {
    let mut chunks = Vec::with_capacity(header.chunk_count as usize);

    // Seek to start of chunk data
    file.seek(SeekFrom::Start(0))?;

    for _ in 0..header.chunk_count {
        // Read nonce
        let mut nonce = [0u8; 12];
        file.read_exact(&amp;mut nonce)?;

        // Read data length
        let mut length_bytes = [0u8; 4];
        file.read_exact(&amp;mut length_bytes)?;
        let data_length = u32::from_le_bytes(length_bytes);

        // Read encrypted data
        let mut encrypted_data = vec![0u8; data_length as usize];
        file.read_exact(&amp;mut encrypted_data)?;

        chunks.push(ChunkFormat {
            nonce,
            data_length,
            encrypted_data,
        });
    }

    Ok(chunks)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="file-recovery"><a class="header" href="#file-recovery">File Recovery</a></h2>
<h3 id="complete-recovery-process"><a class="header" href="#complete-recovery-process">Complete Recovery Process</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn restore_original_file(
    input_path: &amp;str,
    output_path: &amp;str,
    password: Option&lt;&amp;str&gt;,
) -&gt; Result&lt;(), PipelineError&gt; {
    // 1. Read header
    let header = read_adapipe_file(input_path)?;

    // 2. Read chunks
    let mut file = File::open(input_path)?;
    let chunks = read_chunks(&amp;mut file, &amp;header)?;

    // 3. Process chunks in reverse order
    let mut restored_data = Vec::new();

    for chunk in chunks {
        let mut chunk_data = chunk.encrypted_data;

        // Reverse processing steps
        for step in header.processing_steps.iter().rev() {
            chunk_data = match step.step_type {
                ProcessingStepType::Encryption =&gt; {
                    decrypt_chunk(chunk_data, &amp;chunk.nonce, &amp;step, password)?
                }
                ProcessingStepType::Compression =&gt; {
                    decompress_chunk(chunk_data, &amp;step)?
                }
                ProcessingStepType::Checksum =&gt; {
                    verify_chunk_checksum(&amp;chunk_data, &amp;step)?;
                    chunk_data
                }
                _ =&gt; chunk_data,
            };
        }

        restored_data.extend_from_slice(&amp;chunk_data);
    }

    // 4. Verify restored data
    let restored_checksum = calculate_sha256(&amp;restored_data);
    if restored_checksum != header.original_checksum {
        return Err(PipelineError::IntegrityError(
            "Restored data checksum mismatch".to_string()
        ));
    }

    // 5. Write restored file
    let mut output = File::create(output_path)?;
    output.write_all(&amp;restored_data)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="processing-step-reversal"><a class="header" href="#processing-step-reversal">Processing Step Reversal</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reverse_processing_step(
    data: Vec&lt;u8&gt;,
    step: &amp;ProcessingStep,
    password: Option&lt;&amp;str&gt;,
) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
    match step.step_type {
        ProcessingStepType::Compression =&gt; {
            // Decompress
            match step.algorithm.as_str() {
                "brotli" =&gt; decompress_brotli(data),
                "gzip" =&gt; decompress_gzip(data),
                "zstd" =&gt; decompress_zstd(data),
                "lz4" =&gt; decompress_lz4(data),
                _ =&gt; Err(PipelineError::UnsupportedAlgorithm(
                    step.algorithm.clone()
                )),
            }
        }
        ProcessingStepType::Encryption =&gt; {
            // Decrypt
            let password = password.ok_or(PipelineError::MissingPassword)?;
            match step.algorithm.as_str() {
                "aes-256-gcm" =&gt; decrypt_aes_256_gcm(data, password, step),
                "chacha20-poly1305" =&gt; decrypt_chacha20(data, password, step),
                _ =&gt; Err(PipelineError::UnsupportedAlgorithm(
                    step.algorithm.clone()
                )),
            }
        }
        ProcessingStepType::Checksum =&gt; {
            // Verify checksum (no transformation)
            verify_checksum(&amp;data, step)?;
            Ok(data)
        }
        _ =&gt; Ok(data),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integrity-verification"><a class="header" href="#integrity-verification">Integrity Verification</a></h2>
<h3 id="file-validation"><a class="header" href="#file-validation">File Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_adapipe_file(path: &amp;str) -&gt; Result&lt;ValidationReport, PipelineError&gt; {
    let mut report = ValidationReport::new();

    // 1. Read and validate header
    let header = match read_adapipe_file(path) {
        Ok(h) =&gt; {
            report.add_check("Header format", true, "Valid");
            h
        }
        Err(e) =&gt; {
            report.add_check("Header format", false, &amp;e.to_string());
            return Ok(report);
        }
    };

    // 2. Validate format version
    if header.format_version &lt;= CURRENT_FORMAT_VERSION {
        report.add_check("Format version", true, &amp;format!("v{}", header.format_version));
    } else {
        report.add_check(
            "Format version",
            false,
            &amp;format!("Unsupported: v{}", header.format_version)
        );
    }

    // 3. Validate processing steps
    for (i, step) in header.processing_steps.iter().enumerate() {
        let is_supported = match step.step_type {
            ProcessingStepType::Compression =&gt; {
                matches!(step.algorithm.as_str(), "brotli" | "gzip" | "zstd" | "lz4")
            }
            ProcessingStepType::Encryption =&gt; {
                matches!(step.algorithm.as_str(), "aes-256-gcm" | "chacha20-poly1305")
            }
            _ =&gt; true,
        };

        report.add_check(
            &amp;format!("Step {} ({:?})", i, step.step_type),
            is_supported,
            &amp;step.algorithm
        );
    }

    // 4. Verify output checksum
    let mut file = File::open(path)?;
    let data_length = file.metadata()?.len() - 14 - header.json_size() as u64;
    let mut processed_data = vec![0u8; data_length as usize];
    file.read_exact(&amp;mut processed_data)?;

    let calculated_checksum = calculate_sha256(&amp;processed_data);
    let checksums_match = calculated_checksum == header.output_checksum;

    report.add_check(
        "Output checksum",
        checksums_match,
        if checksums_match { "Valid" } else { "Mismatch" }
    );

    Ok(report)
}

pub struct ValidationReport {
    checks: Vec&lt;(String, bool, String)&gt;,
}

impl ValidationReport {
    pub fn new() -&gt; Self {
        Self { checks: Vec::new() }
    }

    pub fn add_check(&amp;mut self, name: &amp;str, passed: bool, message: &amp;str) {
        self.checks.push((name.to_string(), passed, message.to_string()));
    }

    pub fn is_valid(&amp;self) -&gt; bool {
        self.checks.iter().all(|(_, passed, _)| *passed)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="checksum-verification"><a class="header" href="#checksum-verification">Checksum Verification</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn verify_file_integrity(path: &amp;str) -&gt; Result&lt;bool, PipelineError&gt; {
    let header = read_adapipe_file(path)?;

    // Calculate actual checksum
    let mut file = File::open(path)?;
    let data_length = file.metadata()?.len() - 14 - header.json_size() as u64;
    let mut data = vec![0u8; data_length as usize];
    file.read_exact(&amp;mut data)?;

    let calculated = calculate_sha256(&amp;data);

    // Compare with stored checksum
    Ok(calculated == header.output_checksum)
}

fn calculate_sha256(data: &amp;[u8]) -&gt; String {
    let mut hasher = Sha256::new();
    hasher.update(data);
    format!("{:x}", hasher.finalize())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="version-management"><a class="header" href="#version-management">Version Management</a></h2>
<h3 id="format-versioning"><a class="header" href="#format-versioning">Format Versioning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn check_format_compatibility(version: u16) -&gt; Result&lt;(), PipelineError&gt; {
    match version {
        1 =&gt; Ok(()), // Current version
        v if v &lt; CURRENT_FORMAT_VERSION =&gt; {
            // Older version - attempt migration
            migrate_format(v, CURRENT_FORMAT_VERSION)
        }
        v =&gt; Err(PipelineError::UnsupportedVersion(v)),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="format-migration"><a class="header" href="#format-migration">Format Migration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn migrate_format(from: u16, to: u16) -&gt; Result&lt;(), PipelineError&gt; {
    match (from, to) {
        (1, 2) =&gt; {
            // Migration from v1 to v2
            // Add new fields with defaults
            Ok(())
        }
        _ =&gt; Err(PipelineError::MigrationUnsupported(from, to)),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="backward-compatibility"><a class="header" href="#backward-compatibility">Backward Compatibility</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_any_version(path: &amp;str) -&gt; Result&lt;FileHeader, PipelineError&gt; {
    let version = read_format_version(path)?;

    match version {
        1 =&gt; read_v1_format(path),
        2 =&gt; read_v2_format(path),
        v =&gt; Err(PipelineError::UnsupportedVersion(v)),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="file-creation"><a class="header" href="#file-creation">File Creation</a></h3>
<p><strong>Always set checksums:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Set both checksums
let original_checksum = calculate_sha256(&amp;input_data);
let header = FileHeader::new(filename, size, original_checksum);
// ... process data ...
header.output_checksum = calculate_sha256(&amp;processed_data);
<span class="boring">}</span></code></pre></pre>
<p><strong>Record all processing steps:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Record every transformation
header = header
    .add_compression_step("brotli", 6)
    .add_encryption_step("aes-256-gcm", "argon2")
    .add_checksum_step("sha256");
<span class="boring">}</span></code></pre></pre>
<h3 id="file-reading"><a class="header" href="#file-reading">File Reading</a></h3>
<p><strong>Always validate format:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Validate before processing
let header = read_adapipe_file(path)?;

if header.format_version &gt; CURRENT_FORMAT_VERSION {
    return Err(PipelineError::UnsupportedVersion(
        header.format_version
    ));
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Verify checksums:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Verify integrity
let restored_checksum = calculate_sha256(&amp;restored_data);
if restored_checksum != header.original_checksum {
    return Err(PipelineError::IntegrityError(
        "Checksum mismatch".to_string()
    ));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p><strong>Handle all error cases:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match read_adapipe_file(path) {
    Ok(header) =&gt; process_file(header),
    Err(PipelineError::InvalidFormat(msg)) =&gt; {
        eprintln!("Not a valid .adapipe file: {}", msg);
    }
    Err(PipelineError::UnsupportedVersion(v)) =&gt; {
        eprintln!("Unsupported format version: {}", v);
    }
    Err(e) =&gt; {
        eprintln!("Error reading file: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="nonce-management"><a class="header" href="#nonce-management">Nonce Management</a></h3>
<p><strong>Never reuse nonces:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Generate unique nonce per chunk
fn generate_nonce() -&gt; [u8; 12] {
    let mut nonce = [0u8; 12];
    use rand::RngCore;
    rand::thread_rng().fill_bytes(&amp;mut nonce);
    nonce
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-derivation"><a class="header" href="#key-derivation">Key Derivation</a></h3>
<p><strong>Use strong key derivation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Argon2 for password-based encryption
fn derive_key(password: &amp;str, salt: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    use argon2::{Argon2, PasswordHasher};

    let argon2 = Argon2::default();
    let hash = argon2.hash_password(password.as_bytes(), salt)
        .unwrap();

    hash.hash.unwrap().as_bytes().to_vec()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integrity-protection"><a class="header" href="#integrity-protection">Integrity Protection</a></h3>
<p><strong>Verify at every step:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Verify after each transformation
fn process_with_verification(
    data: Vec&lt;u8&gt;,
    step: &amp;ProcessingStep
) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
    let processed = apply_transformation(data, step)?;
    verify_transformation(&amp;processed, step)?;
    Ok(processed)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand the binary file format:</p>
<ul>
<li><a href="chunking.html">Chunking Strategy</a> - Efficient chunk processing</li>
<li><a href="file-io.html">File I/O</a> - File reading and writing patterns</li>
<li><a href="integrity.html">Integrity Verification</a> - Checksum algorithms</li>
<li><a href="encryption.html">Encryption</a> - Encryption implementation details</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../implementation/chunking.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../implementation/observability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../implementation/chunking.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../implementation/observability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
