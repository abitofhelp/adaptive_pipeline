<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concurrency Model - Pipeline Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pipeline Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="concurrency-model"><a class="header" href="#concurrency-model">Concurrency Model</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>This chapter provides a comprehensive overview of the concurrency model in the adaptive pipeline system. Learn how async/await, Tokio runtime, and concurrent patterns enable high-performance, scalable file processing.</p>
<hr />
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#concurrency-architecture">Concurrency Architecture</a></li>
<li><a href="#asyncawait-model">Async/Await Model</a></li>
<li><a href="#tokio-runtime">Tokio Runtime</a></li>
<li><a href="#parallel-chunk-processing">Parallel Chunk Processing</a></li>
<li><a href="#concurrency-primitives">Concurrency Primitives</a></li>
<li><a href="#thread-pools-and-workers">Thread Pools and Workers</a></li>
<li><a href="#resource-management">Resource Management</a></li>
<li><a href="#concurrency-patterns">Concurrency Patterns</a></li>
<li><a href="#performance-considerations">Performance Considerations</a></li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The <strong>concurrency model</strong> enables the adaptive pipeline to process files efficiently through parallel processing, async I/O, and concurrent chunk handling. The system uses Rust's async/await with the Tokio runtime for high-performance, scalable concurrency.</p>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<ul>
<li><strong>Async/Await</strong>: Non-blocking asynchronous operations</li>
<li><strong>Tokio Runtime</strong>: Multi-threaded async runtime</li>
<li><strong>Parallel Processing</strong>: Concurrent chunk processing</li>
<li><strong>Worker Pools</strong>: Configurable thread pools</li>
<li><strong>Resource Management</strong>: Efficient resource allocation and cleanup</li>
<li><strong>Thread Safety</strong>: Safe concurrent access through Rust's type system</li>
</ul>
<h3 id="concurrency-stack"><a class="header" href="#concurrency-stack">Concurrency Stack</a></h3>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────┐
│                  Application Layer                          │
│  - Pipeline orchestration                                   │
│  - File processing coordination                             │
└─────────────────────────────────────────────────────────────┘
                         ↓ async
┌─────────────────────────────────────────────────────────────┐
│                   Tokio Runtime                             │
│  - Multi-threaded work-stealing scheduler                   │
│  - Async task execution                                     │
│  - I/O reactor                                              │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│              Concurrency Primitives                         │
│  ┌─────────┬──────────┬──────────┬─────────────┐           │
│  │ Mutex   │ RwLock   │ Semaphore│  Channel    │           │
│  │ (Sync)  │ (Shared) │ (Limit)  │ (Message)   │           │
│  └─────────┴──────────┴──────────┴─────────────┘           │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│                  Worker Threads                             │
│  - Chunk processing workers                                 │
│  - I/O workers                                              │
│  - Background tasks                                         │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h3>
<ol>
<li><strong>Async-First</strong>: All I/O operations are asynchronous</li>
<li><strong>Structured Concurrency</strong>: Clear task ownership and lifetimes</li>
<li><strong>Safe Sharing</strong>: Thread-safe sharing through Arc and sync primitives</li>
<li><strong>Resource Bounded</strong>: Limited resource usage with semaphores</li>
<li><strong>Zero-Cost Abstractions</strong>: Minimal overhead from async runtime</li>
</ol>
<hr />
<h2 id="concurrency-architecture"><a class="header" href="#concurrency-architecture">Concurrency Architecture</a></h2>
<p>The system uses a layered concurrency architecture with clear separation between sync and async code.</p>
<h3 id="architectural-layers"><a class="header" href="#architectural-layers">Architectural Layers</a></h3>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────┐
│ Async Layer (I/O Bound)                                     │
│  ┌──────────────────────────────────────────────────┐      │
│  │  File I/O Service (async)                        │      │
│  │  - tokio::fs file operations                     │      │
│  │  - Async read/write                              │      │
│  └──────────────────────────────────────────────────┘      │
│  ┌──────────────────────────────────────────────────┐      │
│  │  Pipeline Service (async orchestration)          │      │
│  │  - Async workflow coordination                   │      │
│  │  - Task spawning and management                  │      │
│  └──────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ Sync Layer (CPU Bound)                                      │
│  ┌──────────────────────────────────────────────────┐      │
│  │  Compression Service (sync)                      │      │
│  │  - CPU-bound compression algorithms              │      │
│  │  - No async overhead                             │      │
│  └──────────────────────────────────────────────────┘      │
│  ┌──────────────────────────────────────────────────┐      │
│  │  Encryption Service (sync)                       │      │
│  │  - CPU-bound encryption algorithms               │      │
│  │  - No async overhead                             │      │
│  └──────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="async-vs-sync-decision"><a class="header" href="#async-vs-sync-decision">Async vs Sync Decision</a></h3>
<p><strong>Async for:</strong></p>
<ul>
<li>File I/O (tokio::fs)</li>
<li>Network I/O</li>
<li>Database operations</li>
<li>Long-running waits</li>
</ul>
<p><strong>Sync for:</strong></p>
<ul>
<li>CPU-bound compression</li>
<li>CPU-bound encryption</li>
<li>Hash calculations</li>
<li>Pure computation</li>
</ul>
<hr />
<h2 id="asyncawait-model"><a class="header" href="#asyncawait-model">Async/Await Model</a></h2>
<p>The system uses Rust's async/await for non-blocking concurrency.</p>
<h3 id="async-functions"><a class="header" href="#async-functions">Async Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Async function definition
async fn process_file(
    path: &amp;Path,
    chunk_size: ChunkSize,
) -&gt; Result&lt;Vec&lt;FileChunk&gt;, PipelineError&gt; {
    // Await async operations
    let chunks = read_file_chunks(path, chunk_size).await?;

    // Process chunks
    let results = process_chunks_parallel(chunks).await?;

    Ok(results)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="awaiting-futures"><a class="header" href="#awaiting-futures">Awaiting Futures</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sequential awaits
let chunks = service.read_file_chunks(path, chunk_size).await?;
let processed = process_chunks(chunks).await?;
service.write_file_chunks(output_path, processed).await?;

// Parallel awaits with join
use tokio::try_join;

let (chunks1, chunks2) = try_join!(
    service.read_file_chunks(path1, chunk_size),
    service.read_file_chunks(path2, chunk_size),
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="async-traits"><a class="header" href="#async-traits">Async Traits</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;

#[async_trait]
pub trait FileIOService: Send + Sync {
    async fn read_file_chunks(
        &amp;self,
        path: &amp;Path,
        chunk_size: ChunkSize,
    ) -&gt; Result&lt;Vec&lt;FileChunk&gt;, PipelineError&gt;;

    async fn write_file_chunks(
        &amp;self,
        path: &amp;Path,
        chunks: Vec&lt;FileChunk&gt;,
    ) -&gt; Result&lt;(), PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="tokio-runtime"><a class="header" href="#tokio-runtime">Tokio Runtime</a></h2>
<p>The system uses Tokio's multi-threaded runtime for async execution.</p>
<h3 id="runtime-configuration"><a class="header" href="#runtime-configuration">Runtime Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::runtime::Runtime;

// Multi-threaded runtime (default)
let runtime = Runtime::new()?;

// Custom configuration
let runtime = tokio::runtime::Builder::new_multi_thread()
    .worker_threads(8)              // 8 worker threads
    .thread_name("pipeline-worker")
    .thread_stack_size(3 * 1024 * 1024)  // 3 MB stack
    .enable_all()                   // Enable I/O and time drivers
    .build()?;

// Execute async work
runtime.block_on(async {
    process_file(path, chunk_size).await?;
});
<span class="boring">}</span></code></pre></pre>
<h3 id="runtime-selection"><a class="header" href="#runtime-selection">Runtime Selection</a></h3>
<pre><pre class="playground"><code class="language-rust">// Multi-threaded runtime (CPU-bound + I/O)
#[tokio::main]
async fn main() {
    // Automatically uses multi-threaded runtime
    process_pipeline().await;
}

// Current-thread runtime (testing, single-threaded)
#[tokio::main(flavor = "current_thread")]
async fn main() {
    // Single-threaded runtime
    process_pipeline().await;
}</code></pre></pre>
<h3 id="work-stealing-scheduler"><a class="header" href="#work-stealing-scheduler">Work-Stealing Scheduler</a></h3>
<p>Tokio uses a work-stealing scheduler for load balancing:</p>
<pre><code class="language-text">Thread 1: [Task A] [Task B] ────────&gt; (idle, steals Task D)
Thread 2: [Task C] [Task D] [Task E]  (busy)
Thread 3: [Task F] ────────────────&gt;  (idle, steals Task E)
</code></pre>
<hr />
<h2 id="parallel-chunk-processing"><a class="header" href="#parallel-chunk-processing">Parallel Chunk Processing</a></h2>
<p>Chunks are processed concurrently for maximum throughput.</p>
<h3 id="parallel-processing-with-try_join_all"><a class="header" href="#parallel-processing-with-try_join_all">Parallel Processing with try_join_all</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::future::try_join_all;

async fn process_chunks_parallel(
    chunks: Vec&lt;FileChunk&gt;,
) -&gt; Result&lt;Vec&lt;FileChunk&gt;, PipelineError&gt; {
    // Spawn tasks for each chunk
    let futures = chunks.into_iter().map(|chunk| {
        tokio::spawn(async move {
            process_chunk(chunk).await
        })
    });

    // Wait for all to complete
    let results = try_join_all(futures).await?;

    // Collect results
    Ok(results.into_iter().collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bounded-parallelism"><a class="header" href="#bounded-parallelism">Bounded Parallelism</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::Semaphore;
use std::sync::Arc;

async fn process_with_limit(
    chunks: Vec&lt;FileChunk&gt;,
    max_parallel: usize,
) -&gt; Result&lt;Vec&lt;FileChunk&gt;, PipelineError&gt; {
    let semaphore = Arc::new(Semaphore::new(max_parallel));
    let futures = chunks.into_iter().map(|chunk| {
        let permit = semaphore.clone();
        async move {
            let _guard = permit.acquire().await.unwrap();
            process_chunk(chunk).await
        }
    });

    try_join_all(futures).await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pipeline-parallelism"><a class="header" href="#pipeline-parallelism">Pipeline Parallelism</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Stage 1: Read chunks
let chunks = read_chunks_stream(path, chunk_size);

// Stage 2: Process chunks (parallel)
let processed = chunks
    .map(|chunk| async move {
        tokio::spawn(async move {
            compress_chunk(chunk).await
        }).await
    })
    .buffer_unordered(8);  // Up to 8 chunks in flight

// Stage 3: Write chunks
write_chunks_stream(processed).await?;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="concurrency-primitives"><a class="header" href="#concurrency-primitives">Concurrency Primitives</a></h2>
<p>The system uses Tokio's async-aware concurrency primitives.</p>
<h3 id="async-mutex"><a class="header" href="#async-mutex">Async Mutex</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::Mutex;
use std::sync::Arc;

let shared_state = Arc::new(Mutex::new(HashMap::new()));

// Acquire lock asynchronously
let mut state = shared_state.lock().await;
state.insert(key, value);
// Lock automatically released when dropped
<span class="boring">}</span></code></pre></pre>
<h3 id="async-rwlock"><a class="header" href="#async-rwlock">Async RwLock</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::RwLock;
use std::sync::Arc;

let config = Arc::new(RwLock::new(PipelineConfig::default()));

// Multiple readers
let config_read = config.read().await;
let chunk_size = config_read.chunk_size;

// Single writer
let mut config_write = config.write().await;
config_write.chunk_size = ChunkSize::from_mb(16)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="channels-mpsc"><a class="header" href="#channels-mpsc">Channels (mpsc)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::mpsc;

// Create channel
let (tx, mut rx) = mpsc::channel::&lt;FileChunk&gt;(100);

// Send chunks
tokio::spawn(async move {
    for chunk in chunks {
        tx.send(chunk).await.unwrap();
    }
});

// Receive chunks
while let Some(chunk) = rx.recv().await {
    process_chunk(chunk).await?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="semaphores"><a class="header" href="#semaphores">Semaphores</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::Semaphore;

// Limit concurrent operations
let semaphore = Arc::new(Semaphore::new(4));  // Max 4 concurrent

for chunk in chunks {
    let permit = semaphore.clone().acquire_owned().await.unwrap();
    tokio::spawn(async move {
        let result = process_chunk(chunk).await;
        drop(permit);  // Release permit
        result
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="thread-pools-and-workers"><a class="header" href="#thread-pools-and-workers">Thread Pools and Workers</a></h2>
<p>Worker pools manage concurrent task execution.</p>
<h3 id="worker-pool-configuration"><a class="header" href="#worker-pool-configuration">Worker Pool Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WorkerPool {
    max_workers: usize,
    semaphore: Arc&lt;Semaphore&gt;,
}

impl WorkerPool {
    pub fn new(max_workers: usize) -&gt; Self {
        Self {
            max_workers,
            semaphore: Arc::new(Semaphore::new(max_workers)),
        }
    }

    pub async fn execute&lt;F, T&gt;(&amp;self, task: F) -&gt; Result&lt;T, PipelineError&gt;
    where
        F: Future&lt;Output = Result&lt;T, PipelineError&gt;&gt; + Send + 'static,
        T: Send + 'static,
    {
        let _permit = self.semaphore.acquire().await.unwrap();
        tokio::spawn(task).await.unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="adaptive-worker-count"><a class="header" href="#adaptive-worker-count">Adaptive Worker Count</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn optimal_worker_count() -&gt; usize {
    let cpu_count = num_cpus::get();

    // For I/O-bound: 2x CPU count
    // For CPU-bound: 1x CPU count
    // For mixed: 1.5x CPU count
    (cpu_count as f64 * 1.5) as usize
}

let worker_pool = WorkerPool::new(optimal_worker_count());
<span class="boring">}</span></code></pre></pre>
<p>For detailed worker pool implementation, see <a href="thread-pooling.html">Thread Pooling</a>.</p>
<hr />
<h2 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h2>
<p>Efficient resource management is critical for concurrent systems.</p>
<h3 id="resource-limits"><a class="header" href="#resource-limits">Resource Limits</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ResourceLimits {
    max_memory: usize,
    max_file_handles: usize,
    max_concurrent_tasks: usize,
}

impl ResourceLimits {
    pub fn calculate_max_parallel_chunks(&amp;self, chunk_size: ChunkSize) -&gt; usize {
        let memory_limit = self.max_memory / chunk_size.bytes();
        let task_limit = self.max_concurrent_tasks;

        memory_limit.min(task_limit)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-tracking"><a class="header" href="#resource-tracking">Resource Tracking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering};

pub struct ResourceTracker {
    active_tasks: AtomicUsize,
    memory_used: AtomicUsize,
}

impl ResourceTracker {
    pub fn acquire_task(&amp;self) -&gt; TaskGuard {
        self.active_tasks.fetch_add(1, Ordering::SeqCst);
        TaskGuard { tracker: self }
    }
}

pub struct TaskGuard&lt;'a&gt; {
    tracker: &amp;'a ResourceTracker,
}

impl Drop for TaskGuard&lt;'_&gt; {
    fn drop(&amp;mut self) {
        self.tracker.active_tasks.fetch_sub(1, Ordering::SeqCst);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For detailed resource management, see <a href="resources.html">Resource Management</a>.</p>
<hr />
<h2 id="concurrency-patterns"><a class="header" href="#concurrency-patterns">Concurrency Patterns</a></h2>
<p>Common concurrency patterns used in the pipeline.</p>
<h3 id="pattern-1-fan-outfan-in"><a class="header" href="#pattern-1-fan-outfan-in">Pattern 1: Fan-Out/Fan-In</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fan-out: Distribute work to multiple workers
let futures = chunks.into_iter().map(|chunk| {
    tokio::spawn(async move {
        process_chunk(chunk).await
    })
});

// Fan-in: Collect results
let results = try_join_all(futures).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-pipeline-pattern"><a class="header" href="#pattern-2-pipeline-pattern">Pattern 2: Pipeline Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio_stream::StreamExt;

// Stage 1 → Stage 2 → Stage 3
let result = read_stream(path)
    .map(|chunk| compress_chunk(chunk))
    .buffer_unordered(8)
    .map(|chunk| encrypt_chunk(chunk))
    .buffer_unordered(8)
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .await;
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-worker-pool-pattern"><a class="header" href="#pattern-3-worker-pool-pattern">Pattern 3: Worker Pool Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pool = WorkerPool::new(8);

for chunk in chunks {
    pool.execute(async move {
        process_chunk(chunk).await
    }).await?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-4-rate-limiting"><a class="header" href="#pattern-4-rate-limiting">Pattern 4: Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{interval, Duration};

let mut interval = interval(Duration::from_millis(100));

for chunk in chunks {
    interval.tick().await;  // Rate limit: 10 chunks/sec
    process_chunk(chunk).await?;
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="tokio-task-overhead"><a class="header" href="#tokio-task-overhead">Tokio Task Overhead</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Cost</th><th>Notes</th></tr></thead><tbody>
<tr><td><strong>Spawn task</strong></td><td>~1-2 μs</td><td>Very lightweight</td></tr>
<tr><td><strong>Context switch</strong></td><td>~100 ns</td><td>Work-stealing scheduler</td></tr>
<tr><td><strong>Mutex lock</strong></td><td>~50 ns</td><td>Uncontended case</td></tr>
<tr><td><strong>Channel send</strong></td><td>~100-200 ns</td><td>Depends on channel type</td></tr>
</tbody></table>
</div>
<h3 id="choosing-concurrency-level"><a class="header" href="#choosing-concurrency-level">Choosing Concurrency Level</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn optimal_concurrency(
    file_size: u64,
    chunk_size: ChunkSize,
    available_memory: usize,
) -&gt; usize {
    let num_chunks = (file_size / chunk_size.bytes() as u64) as usize;
    let memory_limit = available_memory / chunk_size.bytes();
    let cpu_limit = num_cpus::get() * 2;

    num_chunks.min(memory_limit).min(cpu_limit)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="avoiding-contention"><a class="header" href="#avoiding-contention">Avoiding Contention</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Bad: High contention
let counter = Arc::new(Mutex::new(0));
for _ in 0..1000 {
    let c = counter.clone();
    tokio::spawn(async move {
        *c.lock().await += 1;  // Lock contention!
    });
}

// ✅ Good: Reduce contention
let counter = Arc::new(AtomicUsize::new(0));
for _ in 0..1000 {
    let c = counter.clone();
    tokio::spawn(async move {
        c.fetch_add(1, Ordering::Relaxed);  // Lock-free!
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-use-async-for-io-sync-for-cpu"><a class="header" href="#1-use-async-for-io-sync-for-cpu">1. Use Async for I/O, Sync for CPU</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Async I/O
async fn read_file(path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
    tokio::fs::read(path).await
}

// ✅ Good: Sync CPU-bound
fn compress_data(data: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
    brotli::compress(data)  // Sync, CPU-bound
}

// ❌ Bad: Async for CPU-bound
async fn compress_data_async(data: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
    // Unnecessary async overhead
    brotli::compress(data)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-spawn-blocking-for-sync-code"><a class="header" href="#2-spawn-blocking-for-sync-code">2. Spawn Blocking for Sync Code</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Spawn blocking task
async fn process_chunk(chunk: FileChunk) -&gt; Result&lt;FileChunk, Error&gt; {
    tokio::task::spawn_blocking(move || {
        // CPU-bound compression in blocking thread
        compress_sync(chunk)
    }).await?
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-limit-concurrent-tasks"><a class="header" href="#3-limit-concurrent-tasks">3. Limit Concurrent Tasks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Bounded parallelism
let semaphore = Arc::new(Semaphore::new(max_concurrent));
for chunk in chunks {
    let permit = semaphore.clone();
    tokio::spawn(async move {
        let _guard = permit.acquire().await.unwrap();
        process_chunk(chunk).await
    });
}

// ❌ Bad: Unbounded parallelism
for chunk in chunks {
    tokio::spawn(async move {
        process_chunk(chunk).await  // May spawn thousands of tasks!
    });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-use-channels-for-communication"><a class="header" href="#4-use-channels-for-communication">4. Use Channels for Communication</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Channel communication
let (tx, mut rx) = mpsc::channel(100);

tokio::spawn(async move {
    while let Some(chunk) = rx.recv().await {
        process_chunk(chunk).await;
    }
});

tx.send(chunk).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="5-handle-errors-properly"><a class="header" href="#5-handle-errors-properly">5. Handle Errors Properly</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Proper error handling
let results: Result&lt;Vec&lt;_&gt;, _&gt; = try_join_all(futures).await;
match results {
    Ok(chunks) =&gt; { /* success */ },
    Err(e) =&gt; {
        error!("Processing failed: {}", e);
        // Cleanup resources
        return Err(e);
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="issue-1-too-many-tokio-tasks"><a class="header" href="#issue-1-too-many-tokio-tasks">Issue 1: Too Many Tokio Tasks</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">thread 'tokio-runtime-worker' stack overflow
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Limit concurrent tasks
let semaphore = Arc::new(Semaphore::new(100));

// 2. Use buffer_unordered
stream.buffer_unordered(10).collect().await

// 3. Increase stack size
tokio::runtime::Builder::new_multi_thread()
    .thread_stack_size(4 * 1024 * 1024)  // 4 MB
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-2-mutex-deadlock"><a class="header" href="#issue-2-mutex-deadlock">Issue 2: Mutex Deadlock</a></h3>
<p><strong>Symptom:</strong> Tasks hang indefinitely.</p>
<p><strong>Solutions:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Always acquire locks in same order
async fn transfer(from: &amp;Mutex&lt;u64&gt;, to: &amp;Mutex&lt;u64&gt;, amount: u64) {
    let (first, second) = if ptr::eq(from, to) {
        panic!("Same account");
    } else if (from as *const _ as usize) &lt; (to as *const _ as usize) {
        (from, to)
    } else {
        (to, from)
    };

    let mut a = first.lock().await;
    let mut b = second.lock().await;
    // Transfer logic
}

// 2. Use try_lock with timeout
tokio::time::timeout(Duration::from_secs(5), mutex.lock()).await??;
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-3-channel-backpressure"><a class="header" href="#issue-3-channel-backpressure">Issue 3: Channel Backpressure</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Producer overwhelms consumer
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Bounded channel
let (tx, rx) = mpsc::channel::&lt;FileChunk&gt;(100);  // Max 100 in flight

// 2. Apply backpressure
match tx.try_send(chunk) {
    Ok(()) =&gt; { /* sent */ },
    Err(TrySendError::Full(_)) =&gt; {
        // Wait and retry
        tokio::time::sleep(Duration::from_millis(10)).await;
    },
    Err(e) =&gt; return Err(e.into()),
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>After understanding the concurrency model, explore specific implementations:</p>
<h3 id="related-advanced-topics"><a class="header" href="#related-advanced-topics">Related Advanced Topics</a></h3>
<ol>
<li><strong><a href="thread-pooling.html">Thread Pooling</a></strong>: Worker pool implementation and optimization</li>
<li><strong><a href="resources.html">Resource Management</a></strong>: Memory and resource tracking</li>
</ol>
<h3 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h3>
<ul>
<li><strong><a href="performance.html">Performance Optimization</a></strong>: Optimizing concurrent code</li>
<li><strong><a href="../implementation/file-io.html">File I/O</a></strong>: Async file operations</li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><strong>Key Takeaways:</strong></p>
<ol>
<li><strong>Async/Await</strong> provides non-blocking concurrency for I/O operations</li>
<li><strong>Tokio Runtime</strong> uses work-stealing for efficient task scheduling</li>
<li><strong>Parallel Processing</strong> enables concurrent chunk processing for throughput</li>
<li><strong>Concurrency Primitives</strong> (Mutex, RwLock, Semaphore) enable safe sharing</li>
<li><strong>Worker Pools</strong> manage bounded concurrent task execution</li>
<li><strong>Resource Management</strong> tracks and limits resource usage</li>
<li><strong>Patterns</strong> (fan-out/fan-in, pipeline, worker pool) structure concurrent code</li>
</ol>
<p><strong>Architecture File References:</strong></p>
<ul>
<li><strong>Pipeline Service:</strong> <code>pipeline/src/application/services/pipeline_service.rs:189</code></li>
<li><strong>File Processor:</strong> <code>pipeline/src/application/services/file_processor_service.rs:1</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../implementation/logging.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../advanced/thread-pooling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../implementation/logging.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../advanced/thread-pooling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
