@startuml class_diagram
skinparam class {
    BackgroundColor lightblue
    BorderColor black
    FontSize 11
}

skinparam interface {
    BackgroundColor lightyellow
    BorderColor black
}

interface Stage {
    +process(data: ChunkData): Result<ChunkData>
    +get_name(): String
    +get_version(): String
    +initialize(config: StageConfig): Result<()>
}

interface MemoryManager {
    +get_buffer(size: usize): Result<Buffer>
    +return_buffer(buffer: Buffer)
    +get_memory_stats(): MemoryStats
}

interface KeyManager {
    +generate_key(algorithm: Algorithm): Result<Key>
    +derive_key(password: String, salt: Vec<u8>): Result<Key>
    +store_key(key: Key, id: String): Result<()>
    +retrieve_key(id: String): Result<Key>
}

class PipelineManager {
    -config: PipelineConfig
    -stages: Vec<Box<dyn Stage>>
    -memory_manager: Arc<dyn MemoryManager>
    -metrics: Arc<MetricsCollector>
    -circuit_breaker: CircuitBreaker
    
    +new(config: PipelineConfig): Result<Self>
    +process_file(input: Path, output: Path): Result<ProcessingResult>
    +add_stage(stage: Box<dyn Stage>): Result<()>
    +shutdown(): Result<()>
}

class StageExecutor {
    -thread_pool: ThreadPool
    -memory_manager: Arc<dyn MemoryManager>
    -metrics: Arc<MetricsCollector>
    
    +new(pool_size: usize): Self
    +execute_stage(stage: &dyn Stage, data: ChunkData): Result<ChunkData>
    +execute_parallel(stages: Vec<&dyn Stage>, data: Vec<ChunkData>): Result<Vec<ChunkData>>
}

class CompressionStage {
    -algorithm: CompressionAlgorithm
    -level: CompressionLevel
    -dictionary: Option<Dictionary>
    
    +new(algorithm: CompressionAlgorithm, level: CompressionLevel): Self
    +compress(data: &[u8]): Result<Vec<u8>>
    +decompress(data: &[u8]): Result<Vec<u8>>
}

class EncryptionStage {
    -algorithm: EncryptionAlgorithm
    -key_manager: Arc<dyn KeyManager>
    
    +new(algorithm: EncryptionAlgorithm, key_manager: Arc<dyn KeyManager>): Self
    +encrypt(data: &[u8], key: &Key): Result<Vec<u8>>
    +decrypt(data: &[u8], key: &Key): Result<Vec<u8>>
}

class IntegrityStage {
    -algorithm: HashAlgorithm
    -hmac_key: Option<Key>
    
    +new(algorithm: HashAlgorithm): Self
    +calculate_hash(data: &[u8]): Result<Hash>
    +verify_hash(data: &[u8], expected_hash: &Hash): Result<bool>
}

class ChunkData {
    +id: ChunkId
    +data: Bytes
    +metadata: ChunkMetadata
    +checksum: Option<Checksum>
    
    +new(id: ChunkId, data: Bytes): Self
    +with_metadata(metadata: ChunkMetadata): Self
    +calculate_checksum(): Checksum
}

class CircuitBreaker {
    -failure_threshold: u32
    -timeout_duration: Duration
    -state: CircuitState
    -failure_count: u32
    
    +new(threshold: u32, timeout: Duration): Self
    +call<T>(operation: impl Fn() -> Result<T>): Result<T>
    +is_open(): bool
    +reset(): ()
}

' Relationships
PipelineManager --> StageExecutor : uses
PipelineManager --> Stage : manages
PipelineManager --> MemoryManager : uses
PipelineManager --> CircuitBreaker : uses

StageExecutor --> Stage : executes
StageExecutor --> ChunkData : processes

CompressionStage ..|> Stage : implements
EncryptionStage ..|> Stage : implements
IntegrityStage ..|> Stage : implements

EncryptionStage --> KeyManager : uses
Stage --> ChunkData : processes

note top of PipelineManager : "Main orchestrator that coordinates\nall pipeline operations"
note right of Stage : "Interface that all processing\nstages must implement"
note bottom of ChunkData : "Immutable data structure\nrepresenting a chunk of file data"

@enduml  s