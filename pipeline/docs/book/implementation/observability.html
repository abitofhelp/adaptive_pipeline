<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Observability - Pipeline Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pipeline Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="observability-overview"><a class="header" href="#observability-overview">Observability Overview</a></h1>
<p><strong>Version</strong>: 1.0
<strong>Date</strong>: 2025-10-04
<strong>License</strong>: BSD-3-Clause
<strong>Copyright</strong>: (c) 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors</strong>: Michael Gardner
<strong>Status</strong>: Active</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Observability is the ability to understand the internal state of a system by examining its external outputs. The Optimized Adaptive Pipeline implements a comprehensive observability strategy that combines <strong>metrics</strong>, <strong>logging</strong>, and <strong>health monitoring</strong> to provide complete system visibility.</p>
<h3 id="key-principles"><a class="header" href="#key-principles">Key Principles</a></h3>
<ul>
<li><strong>Three Pillars</strong>: Metrics, Logs, and Traces (health monitoring)</li>
<li><strong>Comprehensive Coverage</strong>: Monitor all aspects of system operation</li>
<li><strong>Real-Time Insights</strong>: Live performance tracking and alerting</li>
<li><strong>Low Overhead</strong>: Minimal performance impact on pipeline processing</li>
<li><strong>Integration Ready</strong>: Compatible with external monitoring systems (Prometheus, Grafana)</li>
<li><strong>Actionable</strong>: Designed to support debugging, optimization, and operations</li>
</ul>
<hr />
<h2 id="the-three-pillars"><a class="header" href="#the-three-pillars">The Three Pillars</a></h2>
<h3 id="1-metrics---quantitative-measurements"><a class="header" href="#1-metrics---quantitative-measurements">1. Metrics - Quantitative Measurements</a></h3>
<p><strong>What</strong>: Numerical measurements aggregated over time</p>
<p><strong>Purpose</strong>: Track system performance, identify trends, detect anomalies</p>
<p><strong>Implementation</strong>:</p>
<ul>
<li>Domain layer: <code>ProcessingMetrics</code> entity</li>
<li>Infrastructure layer: <code>MetricsService</code> with Prometheus integration</li>
<li>HTTP <code>/metrics</code> endpoint for scraping</li>
</ul>
<p><strong>Key Metrics</strong>:</p>
<ul>
<li><strong>Counters</strong>: Total pipelines processed, bytes processed, errors</li>
<li><strong>Gauges</strong>: Active pipelines, current throughput, memory usage</li>
<li><strong>Histograms</strong>: Processing duration, latency distribution</li>
</ul>
<p><strong>See</strong>: <a href="metrics.html">Metrics Collection</a></p>
<h3 id="2-logging---contextual-events"><a class="header" href="#2-logging---contextual-events">2. Logging - Contextual Events</a></h3>
<p><strong>What</strong>: Timestamped records of discrete events with structured context</p>
<p><strong>Purpose</strong>: Understand what happened, when, and why</p>
<p><strong>Implementation</strong>:</p>
<ul>
<li>Bootstrap phase: <code>BootstrapLogger</code> trait</li>
<li>Application phase: <code>tracing</code> crate with structured logging</li>
<li>Multiple log levels: ERROR, WARN, INFO, DEBUG, TRACE</li>
</ul>
<p><strong>Key Features</strong>:</p>
<ul>
<li>Structured fields for filtering and analysis</li>
<li>Correlation IDs for request tracing</li>
<li>Integration with ObservabilityService for alerts</li>
</ul>
<p><strong>See</strong>: <a href="logging.html">Logging Implementation</a></p>
<h3 id="3-health-monitoring---system-status"><a class="header" href="#3-health-monitoring---system-status">3. Health Monitoring - System Status</a></h3>
<p><strong>What</strong>: Aggregated health scores and status indicators</p>
<p><strong>Purpose</strong>: Quickly assess system health and detect degradation</p>
<p><strong>Implementation</strong>:</p>
<ul>
<li><code>ObservabilityService</code> with real-time health scoring</li>
<li><code>SystemHealth</code> status reporting</li>
<li>Alert generation for threshold violations</li>
</ul>
<p><strong>Key Components</strong>:</p>
<ul>
<li>Performance health (throughput, latency)</li>
<li>Error health (error rates, failure patterns)</li>
<li>Resource health (CPU, memory, I/O)</li>
<li>Overall health score (weighted composite)</li>
</ul>
<hr />
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<h3 id="layered-observability"><a class="header" href="#layered-observability">Layered Observability</a></h3>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────┐
│                    Application Layer                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │           ObservabilityService                      │   │
│  │  (Orchestrates monitoring, alerting, health)        │   │
│  └──────────┬────────────────┬──────────────┬──────────┘   │
│             │                │              │               │
│             ▼                ▼              ▼               │
│  ┌──────────────┐  ┌─────────────┐  ┌─────────────┐       │
│  │ Performance  │  │   Alert     │  │   Health    │       │
│  │   Tracker    │  │  Manager    │  │  Monitor    │       │
│  └──────────────┘  └─────────────┘  └─────────────┘       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                           │
                           │ Uses
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                  Infrastructure Layer                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────┐              ┌──────────────────┐    │
│  │ MetricsService   │              │ Logging (tracing)│    │
│  │ (Prometheus)     │              │ (Structured logs)│    │
│  └──────────────────┘              └──────────────────┘    │
│           │                                 │               │
│           │                                 │               │
│           ▼                                 ▼               │
│  ┌──────────────────┐              ┌──────────────────┐    │
│  │ /metrics HTTP    │              │ Log Subscribers  │    │
│  │ endpoint         │              │ (console, file)  │    │
│  └──────────────────┘              └──────────────────┘    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                           │
                           │ Exposes
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                    External Systems                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐ │
│  │  Prometheus  │    │    Grafana   │    │ Log Analysis │ │
│  │   (Scraper)  │    │ (Dashboards) │    │    Tools     │ │
│  └──────────────┘    └──────────────┘    └──────────────┘ │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="component-integration"><a class="header" href="#component-integration">Component Integration</a></h3>
<p>The observability components are tightly integrated:</p>
<ol>
<li><strong>ObservabilityService</strong> orchestrates monitoring</li>
<li><strong>MetricsService</strong> records quantitative data</li>
<li><strong>Logging</strong> records contextual events</li>
<li><strong>PerformanceTracker</strong> maintains real-time state</li>
<li><strong>AlertManager</strong> checks thresholds and generates alerts</li>
<li><strong>HealthMonitor</strong> computes system health scores</li>
</ol>
<hr />
<h2 id="observabilityservice"><a class="header" href="#observabilityservice">ObservabilityService</a></h2>
<h3 id="core-responsibilities"><a class="header" href="#core-responsibilities">Core Responsibilities</a></h3>
<p>The <code>ObservabilityService</code> is the central orchestrator for monitoring:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ObservabilityService {
    metrics_service: Arc&lt;MetricsService&gt;,
    performance_tracker: Arc&lt;RwLock&lt;PerformanceTracker&gt;&gt;,
    alert_thresholds: AlertThresholds,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Methods</strong>:</p>
<ul>
<li><code>start_operation()</code> - Begin tracking an operation</li>
<li><code>complete_operation()</code> - End tracking with metrics</li>
<li><code>get_system_health()</code> - Get current health status</li>
<li><code>record_processing_metrics()</code> - Record pipeline metrics</li>
<li><code>check_alerts()</code> - Evaluate alert conditions</li>
</ul>
<h3 id="performancetracker"><a class="header" href="#performancetracker">PerformanceTracker</a></h3>
<p>Maintains real-time performance state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PerformanceTracker {
    pub active_operations: u32,
    pub total_operations: u64,
    pub average_throughput_mbps: f64,
    pub peak_throughput_mbps: f64,
    pub error_rate_percent: f64,
    pub system_health_score: f64,
    pub last_update: Instant,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Tracked Metrics</strong>:</p>
<ul>
<li>Active operation count</li>
<li>Total operation count</li>
<li>Average and peak throughput</li>
<li>Error rate percentage</li>
<li>Overall health score</li>
<li>Last update timestamp</li>
</ul>
<h3 id="operationtracker"><a class="header" href="#operationtracker">OperationTracker</a></h3>
<p>Automatic operation lifecycle tracking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OperationTracker {
    operation_name: String,
    start_time: Instant,
    observability_service: ObservabilityService,
    completed: AtomicBool,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Lifecycle</strong>:</p>
<ol>
<li>Created via <code>start_operation()</code></li>
<li>Increments active operation count</li>
<li>Logs operation start</li>
<li>On completion: Records duration, throughput, success/failure</li>
<li>On drop (if not completed): Marks as failed</li>
</ol>
<p><strong>Drop Safety</strong>: If the tracker is dropped without explicit completion (e.g., due to panic), it automatically marks the operation as failed.</p>
<hr />
<h2 id="health-monitoring"><a class="header" href="#health-monitoring">Health Monitoring</a></h2>
<h3 id="systemhealth-structure"><a class="header" href="#systemhealth-structure">SystemHealth Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SystemHealth {
    pub status: HealthStatus,
    pub score: f64,
    pub active_operations: u32,
    pub throughput_mbps: f64,
    pub error_rate_percent: f64,
    pub uptime_seconds: u64,
    pub alerts: Vec&lt;Alert&gt;,
}

pub enum HealthStatus {
    Healthy,   // Score &gt;= 90.0
    Warning,   // Score &gt;= 70.0 &amp;&amp; &lt; 90.0
    Critical,  // Score &lt; 70.0
    Unknown,   // Unable to determine health
}
<span class="boring">}</span></code></pre></pre>
<h3 id="health-score-calculation"><a class="header" href="#health-score-calculation">Health Score Calculation</a></h3>
<p>The health score starts at 100 and deductions are applied:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut score = 100.0;

// Deduct for high error rate
if error_rate_percent &gt; max_error_rate_percent {
    score -= 30.0;  // Error rate is critical
}

// Deduct for low throughput
if average_throughput_mbps &lt; min_throughput_mbps {
    score -= 20.0;  // Performance degradation
}

// Additional deductions for other factors...
<span class="boring">}</span></code></pre></pre>
<p><strong>Health Score Ranges</strong>:</p>
<ul>
<li><strong>100-90</strong>: Healthy - System operating normally</li>
<li><strong>89-70</strong>: Warning - Degraded performance, investigation needed</li>
<li><strong>69-0</strong>: Critical - System in distress, immediate action required</li>
</ul>
<h3 id="alert-structure"><a class="header" href="#alert-structure">Alert Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Alert {
    pub severity: AlertSeverity,
    pub message: String,
    pub timestamp: String,
    pub metric_name: String,
    pub current_value: f64,
    pub threshold: f64,
}

pub enum AlertSeverity {
    Info,
    Warning,
    Critical,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="alert-thresholds"><a class="header" href="#alert-thresholds">Alert Thresholds</a></h2>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AlertThresholds {
    pub max_error_rate_percent: f64,
    pub min_throughput_mbps: f64,
    pub max_processing_duration_seconds: f64,
    pub max_memory_usage_mb: f64,
}

impl Default for AlertThresholds {
    fn default() -&gt; Self {
        Self {
            max_error_rate_percent: 5.0,
            min_throughput_mbps: 1.0,
            max_processing_duration_seconds: 300.0,
            max_memory_usage_mb: 1024.0,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="alert-generation"><a class="header" href="#alert-generation">Alert Generation</a></h3>
<p>Alerts are generated when thresholds are violated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn check_alerts(&amp;self, tracker: &amp;PerformanceTracker) {
    // High error rate alert
    if tracker.error_rate_percent &gt; self.alert_thresholds.max_error_rate_percent {
        warn!(
            "🚨 Alert: High error rate {:.1}% (threshold: {:.1}%)",
            tracker.error_rate_percent,
            self.alert_thresholds.max_error_rate_percent
        );
    }

    // Low throughput alert
    if tracker.average_throughput_mbps &lt; self.alert_thresholds.min_throughput_mbps {
        warn!(
            "🚨 Alert: Low throughput {:.2} MB/s (threshold: {:.2} MB/s)",
            tracker.average_throughput_mbps,
            self.alert_thresholds.min_throughput_mbps
        );
    }

    // High concurrent operations alert
    if tracker.active_operations &gt; 10 {
        warn!("🚨 Alert: High concurrent operations: {}", tracker.active_operations);
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="usage-patterns"><a class="header" href="#usage-patterns">Usage Patterns</a></h2>
<h3 id="basic-operation-tracking"><a class="header" href="#basic-operation-tracking">Basic Operation Tracking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start operation tracking
let tracker = observability_service
    .start_operation("file_processing")
    .await;

// Do work
let result = process_file(&amp;input_path).await?;

// Complete tracking with success/failure
tracker.complete(true, result.bytes_processed).await;
<span class="boring">}</span></code></pre></pre>
<h3 id="automatic-tracking-with-drop-safety"><a class="header" href="#automatic-tracking-with-drop-safety">Automatic Tracking with Drop Safety</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn process_pipeline(id: &amp;PipelineId) -&gt; Result&lt;()&gt; {
    // Tracker automatically handles failure if function panics or returns Err
    let tracker = observability_service
        .start_operation("pipeline_execution")
        .await;

    // If this fails, tracker is dropped and marks operation as failed
    let result = execute_stages(id).await?;

    // Explicit success
    tracker.complete(true, result.bytes_processed).await;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="recording-pipeline-metrics"><a class="header" href="#recording-pipeline-metrics">Recording Pipeline Metrics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// After pipeline completion
let metrics = pipeline.processing_metrics();

// Record to both Prometheus and performance tracker
observability_service
    .record_processing_metrics(&amp;metrics)
    .await;

// This automatically:
// - Updates Prometheus counters/gauges/histograms
// - Updates PerformanceTracker state
// - Checks alert thresholds
// - Logs completion with metrics
<span class="boring">}</span></code></pre></pre>
<h3 id="health-check-endpoint"><a class="header" href="#health-check-endpoint">Health Check Endpoint</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn health_check() -&gt; Result&lt;SystemHealth&gt; {
    let health = observability_service.get_system_health().await;

    match health.status {
        HealthStatus::Healthy =&gt; {
            info!("System health: HEALTHY (score: {:.1})", health.score);
        }
        HealthStatus::Warning =&gt; {
            warn!(
                "System health: WARNING (score: {:.1}, {} alerts)",
                health.score,
                health.alerts.len()
            );
        }
        HealthStatus::Critical =&gt; {
            error!(
                "System health: CRITICAL (score: {:.1}, {} alerts)",
                health.score,
                health.alerts.len()
            );
        }
        HealthStatus::Unknown =&gt; {
            warn!("System health: UNKNOWN");
        }
    }

    Ok(health)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-summary"><a class="header" href="#performance-summary">Performance Summary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get human-readable performance summary
let summary = observability_service
    .get_performance_summary()
    .await;

println!("{}", summary);
<span class="boring">}</span></code></pre></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-text">📊 Performance Summary:
Active Operations: 3
Total Operations: 1247
Average Throughput: 45.67 MB/s
Peak Throughput: 89.23 MB/s
Error Rate: 2.1%
System Health: 88.5/100 (Warning)
Alerts: 1
</code></pre>
<hr />
<h2 id="integration-with-external-systems"><a class="header" href="#integration-with-external-systems">Integration with External Systems</a></h2>
<h3 id="prometheus-integration"><a class="header" href="#prometheus-integration">Prometheus Integration</a></h3>
<p>The system exposes metrics via HTTP endpoint:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// HTTP /metrics endpoint
use axum::{routing::get, Router};

let app = Router::new()
    .route("/metrics", get(metrics_handler));

async fn metrics_handler() -&gt; String {
    metrics_service.get_metrics()
        .unwrap_or_else(|_| "# Error generating metrics\n".to_string())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Prometheus Configuration</strong>:</p>
<pre><code class="language-yaml">scrape_configs:
  - job_name: 'pipeline'
    static_configs:
      - targets: ['localhost:9090']
    scrape_interval: 15s
    scrape_timeout: 10s
</code></pre>
<h3 id="grafana-dashboards"><a class="header" href="#grafana-dashboards">Grafana Dashboards</a></h3>
<p>Create dashboards to visualize:</p>
<ul>
<li><strong>Pipeline Throughput</strong>: Line graph of MB/s over time</li>
<li><strong>Active Operations</strong>: Gauge of current active count</li>
<li><strong>Error Rate</strong>: Line graph of error percentage</li>
<li><strong>Processing Duration</strong>: Histogram of completion times</li>
<li><strong>System Health</strong>: Gauge with color thresholds</li>
</ul>
<p><strong>Example PromQL Queries</strong>:</p>
<pre><code class="language-promql"># Average throughput over 5 minutes
rate(pipeline_bytes_processed_total[5m]) / 1024 / 1024

# Error rate percentage
100 * (
  rate(pipeline_errors_total[5m]) /
  rate(pipeline_processed_total[5m])
)

# P99 processing duration
histogram_quantile(0.99, pipeline_processing_duration_seconds_bucket)
</code></pre>
<h3 id="log-aggregation"><a class="header" href="#log-aggregation">Log Aggregation</a></h3>
<p>Send logs to external systems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing_subscriber::{fmt, layer::SubscriberExt, EnvFilter, Registry};
use tracing_appender::{non_blocking, rolling};

// JSON logs for shipping to ELK/Splunk
let file_appender = rolling::daily("./logs", "pipeline.json");
let (non_blocking_appender, _guard) = non_blocking(file_appender);

let file_layer = fmt::layer()
    .with_writer(non_blocking_appender)
    .json()
    .with_target(true)
    .with_thread_ids(true);

let subscriber = Registry::default()
    .with(EnvFilter::new("info"))
    .with(file_layer);

tracing::subscriber::set_global_default(subscriber)?;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="low-overhead-design"><a class="header" href="#low-overhead-design">Low Overhead Design</a></h3>
<p><strong>Atomic Operations</strong>: Metrics use atomic types to avoid locks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MetricsService {
    pipelines_processed: Arc&lt;AtomicU64&gt;,
    bytes_processed: Arc&lt;AtomicU64&gt;,
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Async RwLock</strong>: PerformanceTracker uses async RwLock for concurrent reads:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>performance_tracker: Arc&lt;RwLock&lt;PerformanceTracker&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong>Lazy Evaluation</strong>: Expensive calculations only performed when health is queried</p>
<p><strong>Compile-Time Filtering</strong>: Debug/trace logs have zero overhead in release builds</p>
<h3 id="benchmark-results"><a class="header" href="#benchmark-results">Benchmark Results</a></h3>
<p>Observability overhead on Intel i7-10700K @ 3.8 GHz:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time</th><th>Overhead</th></tr></thead><tbody>
<tr><td><code>start_operation()</code></td><td>~500 ns</td><td>Negligible</td></tr>
<tr><td><code>complete_operation()</code></td><td>~1.2 μs</td><td>Minimal</td></tr>
<tr><td><code>record_processing_metrics()</code></td><td>~2.5 μs</td><td>Low</td></tr>
<tr><td><code>get_system_health()</code></td><td>~8 μs</td><td>Moderate (infrequent)</td></tr>
<tr><td><code>info!()</code> log</td><td>~80 ns</td><td>Negligible</td></tr>
<tr><td><code>debug!()</code> log (disabled)</td><td>~0 ns</td><td>Zero</td></tr>
</tbody></table>
</div>
<p><strong>Total overhead</strong>: &lt; 0.1% of pipeline processing time</p>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="-do"><a class="header" href="#-do">✅ DO</a></h3>
<p><strong>Track all significant operations</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tracker = observability.start_operation("file_compression").await;
let result = compress_file(&amp;path).await?;
tracker.complete(true, result.compressed_size).await;
<span class="boring">}</span></code></pre></pre>
<p><strong>Use structured logging</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>info!(
    pipeline_id = %id,
    bytes = total_bytes,
    duration_ms = elapsed.as_millis(),
    "Pipeline completed"
);
<span class="boring">}</span></code></pre></pre>
<p><strong>Record domain metrics</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>observability.record_processing_metrics(&amp;pipeline.metrics()).await;
<span class="boring">}</span></code></pre></pre>
<p><strong>Check health regularly</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In health check endpoint
let health = observability.get_system_health().await;
<span class="boring">}</span></code></pre></pre>
<p><strong>Configure thresholds appropriately</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let observability = ObservabilityService::new_with_config(metrics_service).await;
<span class="boring">}</span></code></pre></pre>
<h3 id="-dont"><a class="header" href="#-dont">❌ DON'T</a></h3>
<p><strong>Don't track trivial operations</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Too fine-grained
let tracker = observability.start_operation("allocate_vec").await;
let vec = Vec::with_capacity(100);
tracker.complete(true, 0).await; // Overhead &gt; value
<span class="boring">}</span></code></pre></pre>
<p><strong>Don't log in hot loops without rate limiting</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Excessive logging
for chunk in chunks {
    debug!("Processing chunk {}", chunk.id); // Called millions of times!
}

// GOOD: Log summary
debug!(chunk_count = chunks.len(), "Processing chunks");
info!(chunks_processed = chunks.len(), "Chunk processing complete");
<span class="boring">}</span></code></pre></pre>
<p><strong>Don't forget to complete trackers</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Leaks active operation count
let tracker = observability.start_operation("process").await;
process().await?;
// Forgot to call tracker.complete()!

// GOOD: Explicit completion
let tracker = observability.start_operation("process").await;
let result = process().await?;
tracker.complete(true, result.bytes).await;
<span class="boring">}</span></code></pre></pre>
<p><strong>Don't block on observability operations</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Blocking in async context
tokio::task::block_in_place(|| {
    observability.get_system_health().await // Won't compile anyway!
});

// GOOD: Await directly
let health = observability.get_system_health().await;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h2>
<h3 id="unit-testing-observabilityservice"><a class="header" href="#unit-testing-observabilityservice">Unit Testing ObservabilityService</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_operation_tracking() {
    let metrics_service = Arc::new(MetricsService::new().unwrap());
    let observability = ObservabilityService::new(metrics_service);

    // Start operation
    let tracker = observability.start_operation("test").await;

    // Check active count increased
    let health = observability.get_system_health().await;
    assert_eq!(health.active_operations, 1);

    // Complete operation
    tracker.complete(true, 1000).await;

    // Check active count decreased
    let health = observability.get_system_health().await;
    assert_eq!(health.active_operations, 0);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-alert-generation"><a class="header" href="#testing-alert-generation">Testing Alert Generation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_high_error_rate_alert() {
    let metrics_service = Arc::new(MetricsService::new().unwrap());
    let mut observability = ObservabilityService::new(metrics_service);

    // Set low threshold
    observability.alert_thresholds.max_error_rate_percent = 1.0;

    // Simulate high error rate
    for _ in 0..10 {
        let tracker = observability.start_operation("test").await;
        tracker.complete(false, 0).await; // All failures
    }

    // Check health has alerts
    let health = observability.get_system_health().await;
    assert!(!health.alerts.is_empty());
    assert_eq!(health.status, HealthStatus::Critical);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_end_to_end_observability() {
    // Setup
    let metrics_service = Arc::new(MetricsService::new().unwrap());
    let observability = Arc::new(ObservabilityService::new(metrics_service.clone()));

    // Run pipeline with tracking
    let tracker = observability.start_operation("pipeline").await;
    let result = run_test_pipeline().await.unwrap();
    tracker.complete(true, result.bytes_processed).await;

    // Verify metrics recorded
    let metrics_output = metrics_service.get_metrics().unwrap();
    assert!(metrics_output.contains("pipeline_processed_total"));

    // Verify health is good
    let health = observability.get_system_health().await;
    assert_eq!(health.status, HealthStatus::Healthy);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="common-issues-and-solutions"><a class="header" href="#common-issues-and-solutions">Common Issues and Solutions</a></h2>
<h3 id="issue-active-operations-count-stuck"><a class="header" href="#issue-active-operations-count-stuck">Issue: Active operations count stuck</a></h3>
<p><strong>Symptom</strong>: <code>active_operations</code> never decreases</p>
<p><strong>Cause</strong>: <code>OperationTracker</code> not completed or dropped</p>
<p><strong>Solution</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ensure tracker is completed in all code paths
let tracker = observability.start_operation("op").await;
let result = match dangerous_operation().await {
    Ok(r) =&gt; {
        tracker.complete(true, r.bytes).await;
        Ok(r)
    }
    Err(e) =&gt; {
        tracker.complete(false, 0).await;
        Err(e)
    }
};
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-health-score-always-100"><a class="header" href="#issue-health-score-always-100">Issue: Health score always 100</a></h3>
<p><strong>Symptom</strong>: Health never degrades despite errors</p>
<p><strong>Cause</strong>: Metrics not being recorded</p>
<p><strong>Solution</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Always record processing metrics
observability.record_processing_metrics(&amp;metrics).await;
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-alerts-not-firing"><a class="header" href="#issue-alerts-not-firing">Issue: Alerts not firing</a></h3>
<p><strong>Symptom</strong>: Thresholds violated but no alerts logged</p>
<p><strong>Cause</strong>: Log level filtering out WARN messages</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Enable WARN level
export RUST_LOG=warn

# Or per-module
export RUST_LOG=pipeline::infrastructure::logging=warn
</code></pre>
<hr />
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><strong><a href="metrics.html">Metrics Collection</a></strong>: Deep dive into Prometheus metrics</li>
<li><strong><a href="logging.html">Logging Implementation</a></strong>: Structured logging with tracing</li>
<li><strong><a href="configuration.html">Configuration</a></strong>: Configure alert thresholds and settings</li>
<li><strong><a href="../testing/integration-tests.html">Testing</a></strong>: Integration testing strategies</li>
</ul>
<hr />
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>Source: <code>pipeline/src/infrastructure/logging/observability_service.rs</code> (lines 1-716)</li>
<li><a href="https://prometheus.io/docs/">Prometheus Documentation</a></li>
<li><a href="https://grafana.com/docs/grafana/latest/dashboards/">Grafana Dashboards</a></li>
<li><a href="https://www.oreilly.com/library/view/distributed-systems-observability/9781492033431/ch04.html">The Three Pillars of Observability</a></li>
<li><a href="https://sre.google/sre-book/monitoring-distributed-systems/">Site Reliability Engineering</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../implementation/binary-format.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../implementation/metrics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../implementation/binary-format.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../implementation/metrics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
