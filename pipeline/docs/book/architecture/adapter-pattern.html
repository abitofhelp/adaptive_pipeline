<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adapter Pattern - Pipeline Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pipeline Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hexagonal-architecture-ports-and-adapters"><a class="header" href="#hexagonal-architecture-ports-and-adapters">Hexagonal Architecture (Ports and Adapters)</a></h1>
<p><strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner, Claude Code
<strong>Status:</strong> Active</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Hexagonal Architecture, also known as <strong>Ports and Adapters</strong>, is a pattern that isolates the core business logic (domain) from external concerns. The pipeline system uses this pattern to keep the domain pure and infrastructure replaceable.</p>
<p><img src="../diagrams/hexagonal-architecture.svg" alt="Hexagonal Architecture" /></p>
<h2 id="the-hexagon-metaphor"><a class="header" href="#the-hexagon-metaphor">The Hexagon Metaphor</a></h2>
<p>Think of your application as a hexagon:</p>
<pre><code class="language-text">                     ┌─────────────────┐
                     │   Primary       │
                     │   Adapters      │
                     │  (Drivers)      │
                     └────────┬────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
        │              ┌──────▼──────┐              │
        │              │             │              │
        │              │   Domain    │              │
        │              │    (Core)   │              │
        │              │             │              │
        │              └──────┬──────┘              │
        │                     │                     │
        └─────────────────────┼─────────────────────┘
                              │
                     ┌────────▼────────┐
                     │   Secondary     │
                     │   Adapters      │
                     │  (Driven)       │
                     └─────────────────┘
</code></pre>
<ul>
<li><strong>The Hexagon (Core)</strong>: Your domain logic - completely independent</li>
<li><strong>Ports</strong>: Interfaces that define how to interact with the core</li>
<li><strong>Adapters</strong>: Implementations that connect the core to the outside world</li>
</ul>
<h2 id="ports-the-interfaces"><a class="header" href="#ports-the-interfaces">Ports: The Interfaces</a></h2>
<p><strong>Ports</strong> are interfaces defined by the domain layer. They specify what the domain needs without caring about implementation details.</p>
<h3 id="primary-ports-driving"><a class="header" href="#primary-ports-driving">Primary Ports (Driving)</a></h3>
<p>Primary ports define <strong>use cases</strong> - what the application can do. External systems drive the application through these ports.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain layer defines the interface (port)
#[async_trait]
pub trait FileProcessorService: Send + Sync {
    async fn process_file(
        &amp;self,
        pipeline_id: &amp;PipelineId,
        input_path: &amp;FilePath,
        output_path: &amp;FilePath,
    ) -&gt; Result&lt;ProcessingMetrics, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Examples in our system:</strong></p>
<ul>
<li><code>FileProcessorService</code> - File processing operations</li>
<li><code>PipelineService</code> - Pipeline management operations</li>
</ul>
<h3 id="secondary-ports-driven"><a class="header" href="#secondary-ports-driven">Secondary Ports (Driven)</a></h3>
<p>Secondary ports define <strong>dependencies</strong> - what the domain needs from the outside world. The application drives these external systems.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain layer defines what it needs (port)
#[async_trait]
pub trait PipelineRepository: Send + Sync {
    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt;;
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt;;
    async fn update(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt;;
    async fn delete(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;(), PipelineError&gt;;
}

#[async_trait]
pub trait CompressionService: Send + Sync {
    async fn compress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt;;

    async fn decompress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Examples in our system:</strong></p>
<ul>
<li><code>PipelineRepository</code> - Data persistence</li>
<li><code>CompressionService</code> - Data compression</li>
<li><code>EncryptionService</code> - Data encryption</li>
<li><code>ChecksumService</code> - Integrity verification</li>
</ul>
<h2 id="adapters-the-implementations"><a class="header" href="#adapters-the-implementations">Adapters: The Implementations</a></h2>
<p><strong>Adapters</strong> are concrete implementations of ports. They translate between the domain and external systems.</p>
<h3 id="primary-adapters-driving"><a class="header" href="#primary-adapters-driving">Primary Adapters (Driving)</a></h3>
<p>Primary adapters <strong>drive</strong> the application. They take input from the outside world and call the domain.</p>
<h4 id="cli-adapter-mainrs"><a class="header" href="#cli-adapter-mainrs">CLI Adapter (main.rs)</a></h4>
<pre><pre class="playground"><code class="language-rust">// Primary adapter - drives the application
#[tokio::main]
async fn main() -&gt; std::process::ExitCode {
    // 1. Parse user input
    let cli = bootstrap::bootstrap_cli()?;

    // 2. Set up infrastructure (dependency injection)
    let services = setup_services().await?;

    // 3. Drive the domain through primary port
    match cli.command {
        Commands::Process { input, output, pipeline } =&gt; {
            // Call domain through FileProcessorService port
            services.file_processor
                .process_file(&amp;pipeline, &amp;input, &amp;output)
                .await?
        }
        Commands::Create { name, stages } =&gt; {
            // Call domain through PipelineService port
            services.pipeline_service
                .create_pipeline(&amp;name, stages)
                .await?
        }
        // ... more commands
    }
}</code></pre></pre>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Translates user input to domain operations</li>
<li>Handles presentation concerns (formatting, errors)</li>
<li>Drives the application core</li>
</ul>
<h4 id="http-api-adapter-future"><a class="header" href="#http-api-adapter-future">HTTP API Adapter (future)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Another primary adapter for HTTP API
async fn handle_process_request(
    req: HttpRequest,
    services: Arc&lt;Services&gt;,
) -&gt; HttpResponse {
    // Parse HTTP request
    let body: ProcessFileRequest = req.json().await?;

    // Drive domain through the same port
    let result = services.file_processor
        .process_file(&amp;body.pipeline_id, &amp;body.input, &amp;body.output)
        .await;

    // Convert result to HTTP response
    match result {
        Ok(metrics) =&gt; HttpResponse::Ok().json(metrics),
        Err(e) =&gt; HttpResponse::BadRequest().json(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Notice:</strong> Both CLI and HTTP adapters use the <strong>same domain ports</strong>. The domain doesn't know or care which adapter is calling it.</p>
<h3 id="secondary-adapters-driven"><a class="header" href="#secondary-adapters-driven">Secondary Adapters (Driven)</a></h3>
<p>Secondary adapters are <strong>driven by</strong> the application. They implement the interfaces the domain needs.</p>
<h4 id="sqlite-repository-adapter"><a class="header" href="#sqlite-repository-adapter">SQLite Repository Adapter</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Infrastructure layer - implements domain port
pub struct SQLitePipelineRepository {
    pool: SqlitePool,
}

#[async_trait]
impl PipelineRepository for SQLitePipelineRepository {
    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt; {
        // Convert domain entity to database row
        let row = PipelineRow::from_domain(pipeline);

        // Persist to SQLite
        sqlx::query(
            "INSERT INTO pipelines (id, name, archived, created_at, updated_at)
             VALUES (?, ?, ?, ?, ?)"
        )
        .bind(&amp;row.id)
        .bind(&amp;row.name)
        .bind(row.archived)
        .bind(&amp;row.created_at)
        .bind(&amp;row.updated_at)
        .execute(&amp;self.pool)
        .await
        .map_err(|e| PipelineError::RepositoryError(e.to_string()))?;

        Ok(())
    }

    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt; {
        // Query SQLite
        let row = sqlx::query_as::&lt;_, PipelineRow&gt;(
            "SELECT * FROM pipelines WHERE id = ?"
        )
        .bind(id.to_string())
        .fetch_optional(&amp;self.pool)
        .await
        .map_err(|e| PipelineError::RepositoryError(e.to_string()))?;

        // Convert database row to domain entity
        row.map(|r| Pipeline::from_database(r)).transpose()
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Implements domain-defined interface</li>
<li>Handles database-specific operations</li>
<li>Translates between domain models and database rows</li>
<li>Can be swapped without changing domain</li>
</ul>
<h4 id="compression-service-adapter"><a class="header" href="#compression-service-adapter">Compression Service Adapter</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Infrastructure layer - implements domain port
pub struct CompressionServiceAdapter {
    // Internal state for compression libraries
}

#[async_trait]
impl CompressionService for CompressionServiceAdapter {
    async fn compress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
        // Route to appropriate compression library
        match algorithm.name() {
            "brotli" =&gt; {
                let mut compressed = Vec::new();
                brotli::BrotliCompress(
                    &amp;mut Cursor::new(data),
                    &amp;mut compressed,
                    &amp;Default::default(),
                )?;
                Ok(compressed)
            }
            "zstd" =&gt; {
                let compressed = zstd::encode_all(data, 3)?;
                Ok(compressed)
            }
            "lz4" =&gt; {
                let compressed = lz4::block::compress(data, None, false)?;
                Ok(compressed)
            }
            _ =&gt; Err(PipelineError::UnsupportedAlgorithm(
                algorithm.name().to_string()
            )),
        }
    }

    async fn decompress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
        // Similar implementation for decompression
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Wraps external libraries (brotli, zstd, lz4)</li>
<li>Implements domain interface</li>
<li>Handles library-specific details</li>
<li>Can be swapped for different implementations</li>
</ul>
<h2 id="benefits-of-hexagonal-architecture"><a class="header" href="#benefits-of-hexagonal-architecture">Benefits of Hexagonal Architecture</a></h2>
<h3 id="1-testability"><a class="header" href="#1-testability">1. Testability</a></h3>
<p>You can test the domain in isolation using mock adapters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mock adapter for testing
struct MockPipelineRepository {
    pipelines: Mutex&lt;HashMap&lt;PipelineId, Pipeline&gt;&gt;,
}

#[async_trait]
impl PipelineRepository for MockPipelineRepository {
    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt; {
        self.pipelines.lock().unwrap()
            .insert(pipeline.id().clone(), pipeline.clone());
        Ok(())
    }

    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt; {
        Ok(self.pipelines.lock().unwrap().get(id).cloned())
    }
}

#[tokio::test]
async fn test_file_processor_service() {
    // Use mock adapter instead of real database
    let repo = Arc::new(MockPipelineRepository::new());
    let service = FileProcessorService::new(repo);

    // Test domain logic without database
    let result = service.process_file(/* ... */).await;
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-flexibility"><a class="header" href="#2-flexibility">2. Flexibility</a></h3>
<p>Swap implementations without changing the domain:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start with SQLite
let repo: Arc&lt;dyn PipelineRepository&gt; =
    Arc::new(SQLitePipelineRepository::new(pool));

// Later, switch to PostgreSQL
let repo: Arc&lt;dyn PipelineRepository&gt; =
    Arc::new(PostgresPipelineRepository::new(pool));

// Domain doesn't change - same interface!
let service = FileProcessorService::new(repo);
<span class="boring">}</span></code></pre></pre>
<h3 id="3-multiple-interfaces"><a class="header" href="#3-multiple-interfaces">3. Multiple Interfaces</a></h3>
<p>Support multiple input sources using the same domain:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CLI adapter
async fn cli_handler(cli: Cli, services: Arc&lt;Services&gt;) {
    services.file_processor.process_file(/* ... */).await?;
}

// HTTP adapter
async fn http_handler(req: HttpRequest, services: Arc&lt;Services&gt;) {
    services.file_processor.process_file(/* ... */).await?;
}

// gRPC adapter
async fn grpc_handler(req: GrpcRequest, services: Arc&lt;Services&gt;) {
    services.file_processor.process_file(/* ... */).await?;
}
<span class="boring">}</span></code></pre></pre>
<p>All three adapters use the <strong>same domain logic</strong> through the <strong>same port</strong>.</p>
<h3 id="4-technology-independence"><a class="header" href="#4-technology-independence">4. Technology Independence</a></h3>
<p>The domain doesn't depend on specific technologies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain doesn't know about:
// - SQLite, PostgreSQL, or MongoDB
// - HTTP, gRPC, or CLI
// - Brotli, Zstd, or LZ4
// - Any specific framework or library

// It only knows about:
// - Business concepts (Pipeline, Stage, Chunk)
// - Business rules (validation, ordering)
// - Interfaces it needs (Repository, CompressionService)
<span class="boring">}</span></code></pre></pre>
<h2 id="dependency-inversion"><a class="header" href="#dependency-inversion">Dependency Inversion</a></h2>
<p>Hexagonal Architecture relies on <strong>Dependency Inversion Principle</strong>:</p>
<pre><code class="language-text">Traditional:                    Hexagonal:

┌──────────┐                   ┌──────────┐
│   CLI    │                   │   CLI    │
└────┬─────┘                   └────┬─────┘
     │ depends on                   │ depends on
     ▼                              ▼
┌──────────┐                   ┌──────────┐
│ Domain   │                   │  Port    │ ← Interface
└────┬─────┘                   │ (trait)  │
     │ depends on               └────△─────┘
     ▼                               │ implements
┌──────────┐                   ┌────┴─────┐
│ Database │                   │  Domain  │
└──────────┘                   └──────────┘
                                     △
                                     │ implements
                               ┌─────┴─────┐
                               │ Database  │
                               │ Adapter   │
                               └───────────┘
</code></pre>
<p><strong>Traditional:</strong> Domain depends on Database (tight coupling)
<strong>Hexagonal:</strong> Database depends on Domain interface (loose coupling)</p>
<h2 id="our-adapter-structure"><a class="header" href="#our-adapter-structure">Our Adapter Structure</a></h2>
<pre><code class="language-text">pipeline/src/
├── infrastructure/
│   └── adapters/
│       ├── compression_service_adapter.rs    # Implements CompressionService
│       ├── encryption_service_adapter.rs     # Implements EncryptionService
│       ├── async_compression_adapter.rs      # Async wrapper
│       ├── async_encryption_adapter.rs       # Async wrapper
│       └── repositories/
│           ├── sqlite_repository_adapter.rs  # Implements PipelineRepository
│           └── sqlite_base_repository.rs     # Base repository utilities
</code></pre>
<h2 id="adapter-responsibilities"><a class="header" href="#adapter-responsibilities">Adapter Responsibilities</a></h2>
<h3 id="what-adapters-should-do"><a class="header" href="#what-adapters-should-do">What Adapters Should Do</a></h3>
<p>✅ <strong>Translate</strong> between domain and external systems
✅ <strong>Handle</strong> technology-specific details
✅ <strong>Implement</strong> domain-defined interfaces
✅ <strong>Convert</strong> data formats (domain ↔ database, domain ↔ API)
✅ <strong>Manage</strong> external resources (connections, files, etc.)</p>
<h3 id="what-adapters-should-not-do"><a class="header" href="#what-adapters-should-not-do">What Adapters Should NOT Do</a></h3>
<p>❌ <strong>Contain business logic</strong> - belongs in domain
❌ <strong>Make business decisions</strong> - belongs in domain
❌ <strong>Validate business rules</strong> - belongs in domain
❌ <strong>Know about other adapters</strong> - should be independent
❌ <strong>Expose infrastructure details</strong> to domain</p>
<h2 id="example-complete-flow"><a class="header" href="#example-complete-flow">Example: Complete Flow</a></h2>
<p>Let's trace a complete request through the hexagonal architecture:</p>
<pre><code class="language-text">1. Primary Adapter (CLI)
   ↓ User types: pipeline process --input file.txt --output file.bin

2. Parse and validate input
   ↓ Create FilePath("/path/to/file.txt")

3. Call Primary Port (FileProcessorService)
   ↓ process_file(pipeline_id, input_path, output_path)

4. Domain Logic
   ├─ Fetch Pipeline (via PipelineRepository port)
   │  └─ Secondary Adapter queries SQLite
   ├─ Process each stage
   │  ├─ Compress (via CompressionService port)
   │  │  └─ Secondary Adapter uses brotli library
   │  ├─ Encrypt (via EncryptionService port)
   │  │  └─ Secondary Adapter uses aes-gcm library
   │  └─ Calculate checksum (via ChecksumService port)
   │     └─ Secondary Adapter uses sha2 library
   └─ Return ProcessingMetrics

5. Primary Adapter formats output
   ↓ Display metrics to user
</code></pre>
<h2 id="common-adapter-patterns"><a class="header" href="#common-adapter-patterns">Common Adapter Patterns</a></h2>
<h3 id="repository-adapter-pattern"><a class="header" href="#repository-adapter-pattern">Repository Adapter Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Domain defines interface (port)
pub trait PipelineRepository: Send + Sync {
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;&gt;;
}

// 2. Infrastructure implements adapter
pub struct SQLitePipelineRepository { /* ... */ }

impl PipelineRepository for SQLitePipelineRepository {
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;&gt; {
        // Database-specific implementation
    }
}

// 3. Application uses through interface
pub struct FileProcessorService {
    repository: Arc&lt;dyn PipelineRepository&gt;,  // Uses interface, not concrete type
}
<span class="boring">}</span></code></pre></pre>
<h3 id="service-adapter-pattern"><a class="header" href="#service-adapter-pattern">Service Adapter Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Domain defines interface
pub trait CompressionService: Send + Sync {
    async fn compress(&amp;self, data: &amp;[u8], algo: &amp;Algorithm) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
}

// 2. Infrastructure implements adapter
pub struct CompressionServiceAdapter { /* ... */ }

impl CompressionService for CompressionServiceAdapter {
    async fn compress(&amp;self, data: &amp;[u8], algo: &amp;Algorithm) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        // Library-specific implementation
    }
}

// 3. Application uses through interface
pub struct StageExecutor {
    compression: Arc&lt;dyn CompressionService&gt;,  // Uses interface
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-with-adapters"><a class="header" href="#testing-with-adapters">Testing with Adapters</a></h2>
<h3 id="unit-tests-domain-layer"><a class="header" href="#unit-tests-domain-layer">Unit Tests (Domain Layer)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test domain logic without any adapters
#[test]
fn test_pipeline_validation() {
    // Pure domain logic - no infrastructure needed
    let result = Pipeline::new("test", vec![]);
    assert!(result.is_err());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests-with-mock-adapters"><a class="header" href="#integration-tests-with-mock-adapters">Integration Tests (With Mock Adapters)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_file_processing() {
    // Use mock adapters
    let mock_repo = Arc::new(MockPipelineRepository::new());
    let mock_compression = Arc::new(MockCompressionService::new());

    let service = FileProcessorService::new(mock_repo, mock_compression);

    // Test without real database or compression
    let result = service.process_file(/* ... */).await;
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="end-to-end-tests-with-real-adapters"><a class="header" href="#end-to-end-tests-with-real-adapters">End-to-End Tests (With Real Adapters)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_real_file_processing() {
    // Use real adapters
    let db_pool = create_test_database().await;
    let real_repo = Arc::new(SQLitePipelineRepository::new(db_pool));
    let real_compression = Arc::new(CompressionServiceAdapter::new());

    let service = FileProcessorService::new(real_repo, real_compression);

    // Test with real infrastructure
    let result = service.process_file(/* ... */).await;
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand hexagonal architecture:</p>
<ul>
<li><a href="dependencies.html">Dependency Inversion</a> - Managing dependencies properly</li>
<li><a href="layers.html">Layered Architecture</a> - How layers relate to ports/adapters</li>
<li><a href="repository-pattern.html">Repository Pattern</a> - Detailed repository implementation</li>
<li><a href="domain-model.html">Domain Model</a> - Understanding the core domain</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/service-pattern.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/observer-pattern.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/service-pattern.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/observer-pattern.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
