<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Persistence - Pipeline Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pipeline Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-persistence"><a class="header" href="#data-persistence">Data Persistence</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>This chapter provides a comprehensive overview of the data persistence architecture in the adaptive pipeline system. Learn how the repository pattern, SQLite database, and schema management work together to provide reliable, efficient data storage.</p>
<hr />
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#persistence-architecture">Persistence Architecture</a></li>
<li><a href="#repository-pattern">Repository Pattern</a></li>
<li><a href="#database-choice-sqlite">Database Choice: SQLite</a></li>
<li><a href="#storage-architecture">Storage Architecture</a></li>
<li><a href="#transaction-management">Transaction Management</a></li>
<li><a href="#connection-management">Connection Management</a></li>
<li><a href="#data-mapping">Data Mapping</a></li>
<li><a href="#performance-optimization">Performance Optimization</a></li>
<li><a href="#usage-examples">Usage Examples</a></li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
<li><a href="#testing-strategies">Testing Strategies</a></li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><strong>Data persistence</strong> in the adaptive pipeline system follows Domain-Driven Design principles, separating domain logic from infrastructure concerns through the repository pattern. The system uses SQLite for reliable, zero-configuration data storage with full ACID transaction support.</p>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<ul>
<li><strong>Repository Pattern</strong>: Abstraction layer between domain and infrastructure</li>
<li><strong>SQLite Database</strong>: Embedded database with zero configuration</li>
<li><strong>Schema Management</strong>: Automated migrations with sqlx</li>
<li><strong>ACID Transactions</strong>: Full transactional support for data consistency</li>
<li><strong>Connection Pooling</strong>: Efficient connection management</li>
<li><strong>Type Safety</strong>: Compile-time query validation</li>
</ul>
<h3 id="persistence-stack"><a class="header" href="#persistence-stack">Persistence Stack</a></h3>
<pre><code class="language-text">┌──────────────────────────────────────────────────────────┐
│                    Domain Layer                          │
│  ┌────────────────────────────────────────────────┐     │
│  │   PipelineRepository (Trait)                   │     │
│  │   - save(), find_by_id(), list_all()          │     │
│  └────────────────────────────────────────────────┘     │
└──────────────────────────────────────────────────────────┘
                         ↓ implements
┌──────────────────────────────────────────────────────────┐
│                Infrastructure Layer                       │
│  ┌────────────────────────────────────────────────┐     │
│  │   SqlitePipelineRepository                     │     │
│  │   - Concrete SQLite implementation             │     │
│  └────────────────────────────────────────────────┘     │
│                         ↓ uses                           │
│  ┌────────────────────────────────────────────────┐     │
│  │   Schema Management                            │     │
│  │   - Migrations, initialization                 │     │
│  └────────────────────────────────────────────────┘     │
└──────────────────────────────────────────────────────────┘
                         ↓ persists to
┌──────────────────────────────────────────────────────────┐
│                  SQLite Database                         │
│  ┌────────────┬──────────────┬──────────────────┐      │
│  │ pipelines  │pipeline_stage│pipeline_config   │      │
│  └────────────┴──────────────┴──────────────────┘      │
└──────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h3>
<ol>
<li><strong>Separation of Concerns</strong>: Domain logic independent of storage technology</li>
<li><strong>Testability</strong>: Easy mocking with in-memory implementations</li>
<li><strong>Flexibility</strong>: Support for different storage backends</li>
<li><strong>Consistency</strong>: ACID transactions ensure data integrity</li>
<li><strong>Performance</strong>: Connection pooling and query optimization</li>
</ol>
<hr />
<h2 id="persistence-architecture"><a class="header" href="#persistence-architecture">Persistence Architecture</a></h2>
<p>The persistence layer follows a three-tier architecture aligned with Domain-Driven Design.</p>
<h3 id="architectural-layers"><a class="header" href="#architectural-layers">Architectural Layers</a></h3>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────┐
│ Application Layer                                           │
│  - PipelineService uses repository trait                    │
│  - Business logic remains persistence-agnostic              │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ Domain Layer                                                │
│  - PipelineRepository trait (abstract interface)            │
│  - Pipeline, PipelineStage entities                         │
│  - No infrastructure dependencies                           │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ Infrastructure Layer                                        │
│  - SqlitePipelineRepository (concrete implementation)       │
│  - Schema management and migrations                         │
│  - Connection pooling and transaction management            │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ Storage Layer                                               │
│  - SQLite database file                                     │
│  - Indexes and constraints                                  │
│  - Migration history tracking                               │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="component-relationships"><a class="header" href="#component-relationships">Component Relationships</a></h3>
<p><strong>Domain-to-Infrastructure Flow:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Application code depends on domain trait
use adaptive_pipeline_domain::repositories::PipelineRepository;

async fn create_pipeline(
    repo: &amp;dyn PipelineRepository,
    name: String,
) -&gt; Result&lt;Pipeline, PipelineError&gt; {
    let pipeline = Pipeline::new(name)?;
    repo.save(&amp;pipeline).await?;
    Ok(pipeline)
}

// Infrastructure provides concrete implementation
use adaptive_pipeline::infrastructure::repositories::SqlitePipelineRepository;

let repository = SqlitePipelineRepository::new(pool);
let pipeline = create_pipeline(&amp;repository, "my-pipeline".to_string()).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="benefits-of-this-architecture"><a class="header" href="#benefits-of-this-architecture">Benefits of This Architecture</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Benefit</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Domain Independence</strong></td><td>Business logic doesn't depend on SQLite specifics</td></tr>
<tr><td><strong>Testability</strong></td><td>Easy to mock repositories for unit testing</td></tr>
<tr><td><strong>Flexibility</strong></td><td>Can swap SQLite for PostgreSQL without changing domain</td></tr>
<tr><td><strong>Maintainability</strong></td><td>Clear separation makes code easier to understand</td></tr>
<tr><td><strong>Type Safety</strong></td><td>Compile-time verification of database operations</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="repository-pattern"><a class="header" href="#repository-pattern">Repository Pattern</a></h2>
<p>The repository pattern provides an abstraction layer between domain entities and data storage.</p>
<h3 id="repository-pattern-benefits"><a class="header" href="#repository-pattern-benefits">Repository Pattern Benefits</a></h3>
<p><strong>1. Separation of Concerns</strong></p>
<p>Domain logic remains free from persistence details:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain layer - storage-agnostic
#[async_trait]
pub trait PipelineRepository: Send + Sync {
    async fn save(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt;;
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt;;
    async fn list_all(&amp;self) -&gt; Result&lt;Vec&lt;Pipeline&gt;, PipelineError&gt;;
    async fn delete(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;bool, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>2. Implementation Flexibility</strong></p>
<p>Multiple storage backends can implement the same interface:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SQLite implementation
pub struct SqlitePipelineRepository { /* ... */ }

// PostgreSQL implementation
pub struct PostgresPipelineRepository { /* ... */ }

// In-memory testing implementation
pub struct InMemoryPipelineRepository { /* ... */ }

// All implement the same PipelineRepository trait
<span class="boring">}</span></code></pre></pre>
<p><strong>3. Enhanced Testability</strong></p>
<p>Mock implementations simplify testing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
struct MockPipelineRepository {
    pipelines: Arc&lt;Mutex&lt;HashMap&lt;PipelineId, Pipeline&gt;&gt;&gt;,
}

#[async_trait]
impl PipelineRepository for MockPipelineRepository {
    async fn save(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt; {
        let mut pipelines = self.pipelines.lock().await;
        pipelines.insert(pipeline.id().clone(), pipeline.clone());
        Ok(())
    }
    // ... implement other methods
}
<span class="boring">}</span></code></pre></pre>
<h3 id="repository-interface-design"><a class="header" href="#repository-interface-design">Repository Interface Design</a></h3>
<p><strong>Method Categories:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Methods</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>CRUD</strong></td><td><code>save()</code>, <code>find_by_id()</code>, <code>update()</code>, <code>delete()</code></td><td>Basic operations</td></tr>
<tr><td><strong>Queries</strong></td><td><code>find_by_name()</code>, <code>find_all()</code>, <code>list_paginated()</code></td><td>Data retrieval</td></tr>
<tr><td><strong>Validation</strong></td><td><code>exists()</code>, <code>count()</code></td><td>Existence checks</td></tr>
<tr><td><strong>Lifecycle</strong></td><td><code>archive()</code>, <code>restore()</code>, <code>list_archived()</code></td><td>Soft deletion</td></tr>
<tr><td><strong>Search</strong></td><td><code>find_by_config()</code></td><td>Advanced queries</td></tr>
</tbody></table>
</div>
<p><strong>Complete Interface:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait PipelineRepository: Send + Sync {
    // CRUD Operations
    async fn save(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt;;
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt;;
    async fn update(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt;;
    async fn delete(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;bool, PipelineError&gt;;

    // Query Operations
    async fn find_by_name(&amp;self, name: &amp;str) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt;;
    async fn find_all(&amp;self) -&gt; Result&lt;Vec&lt;Pipeline&gt;, PipelineError&gt;;
    async fn list_all(&amp;self) -&gt; Result&lt;Vec&lt;Pipeline&gt;, PipelineError&gt;;
    async fn list_paginated(&amp;self, offset: usize, limit: usize)
        -&gt; Result&lt;Vec&lt;Pipeline&gt;, PipelineError&gt;;

    // Validation Operations
    async fn exists(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;bool, PipelineError&gt;;
    async fn count(&amp;self) -&gt; Result&lt;usize, PipelineError&gt;;

    // Lifecycle Operations
    async fn archive(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;bool, PipelineError&gt;;
    async fn restore(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;bool, PipelineError&gt;;
    async fn list_archived(&amp;self) -&gt; Result&lt;Vec&lt;Pipeline&gt;, PipelineError&gt;;

    // Search Operations
    async fn find_by_config(&amp;self, key: &amp;str, value: &amp;str)
        -&gt; Result&lt;Vec&lt;Pipeline&gt;, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="database-choice-sqlite"><a class="header" href="#database-choice-sqlite">Database Choice: SQLite</a></h2>
<p>The system uses <strong>SQLite</strong> as the default database for its simplicity, reliability, and zero-configuration deployment.</p>
<h3 id="why-sqlite"><a class="header" href="#why-sqlite">Why SQLite?</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Advantage</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Zero Configuration</strong></td><td>No database server to install or configure</td></tr>
<tr><td><strong>Single File</strong></td><td>Entire database stored in one file</td></tr>
<tr><td><strong>ACID Compliant</strong></td><td>Full transactional support</td></tr>
<tr><td><strong>Cross-Platform</strong></td><td>Works on Linux, macOS, Windows</td></tr>
<tr><td><strong>Embedded</strong></td><td>Runs in-process, no network overhead</td></tr>
<tr><td><strong>Reliable</strong></td><td>Battle-tested, used in production worldwide</td></tr>
<tr><td><strong>Fast</strong></td><td>Optimized for local file access</td></tr>
</tbody></table>
</div>
<h3 id="sqlite-characteristics"><a class="header" href="#sqlite-characteristics">SQLite Characteristics</a></h3>
<p><strong>Performance Profile:</strong></p>
<pre><code class="language-text">Operation          | Speed      | Notes
-------------------|------------|--------------------------------
Single INSERT      | ~0.1ms     | Very fast for local file
Batch INSERT       | ~10ms/1000 | Use transactions for batching
Single SELECT      | ~0.05ms    | Fast with proper indexes
Complex JOIN       | ~1-5ms     | Depends on dataset size
Full table scan    | ~10ms/10K  | Avoid without indexes
</code></pre>
<p><strong>Limitations:</strong></p>
<ul>
<li><strong>Concurrent Writes</strong>: Only one writer at a time (readers can be concurrent)</li>
<li><strong>Network Access</strong>: Not designed for network file systems</li>
<li><strong>Database Size</strong>: Practical limit ~281 TB (theoretical limit)</li>
<li><strong>Scalability</strong>: Best for single-server deployments</li>
</ul>
<p><strong>When SQLite is Ideal:</strong></p>
<p>✅ Single-server applications
✅ Embedded systems
✅ Desktop applications
✅ Development and testing
✅ Low-to-medium write concurrency</p>
<p><strong>When to Consider Alternatives:</strong></p>
<p>❌ High concurrent write workload
❌ Multi-server deployments
❌ Network file systems
❌ Very large datasets (&gt; 100GB)</p>
<h3 id="sqlite-configuration"><a class="header" href="#sqlite-configuration">SQLite Configuration</a></h3>
<p><strong>Connection String:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Local file database
let url = "sqlite://./pipeline.db";

// In-memory database (testing)
let url = "sqlite::memory:";

// Custom connection options
use sqlx::sqlite::SqliteConnectOptions;
let options = SqliteConnectOptions::new()
    .filename("./pipeline.db")
    .create_if_missing(true)
    .foreign_keys(true)
    .journal_mode(sqlx::sqlite::SqliteJournalMode::Wal);
<span class="boring">}</span></code></pre></pre>
<p><strong>Connection Pool Configuration:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::sqlite::SqlitePoolOptions;

let pool = SqlitePoolOptions::new()
    .max_connections(5)          // Connection pool size
    .min_connections(1)          // Minimum connections
    .acquire_timeout(Duration::from_secs(30))
    .idle_timeout(Duration::from_secs(600))
    .connect(&amp;database_url)
    .await?;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="storage-architecture"><a class="header" href="#storage-architecture">Storage Architecture</a></h2>
<p>The storage layer uses a normalized relational schema with five core tables.</p>
<h3 id="database-schema-overview"><a class="header" href="#database-schema-overview">Database Schema Overview</a></h3>
<pre><code class="language-text">┌─────────────┐
│  pipelines  │ (id, name, archived, created_at, updated_at)
└──────┬──────┘
       │ 1:N
       ├──────────────────────────┐
       │                          │
       ↓                          ↓
┌──────────────────┐    ┌──────────────────┐
│ pipeline_stages  │    │pipeline_config   │
│ (id, pipeline_id,│    │(pipeline_id, key,│
│  name, type,     │    │ value)           │
│  algorithm, ...)  │    └──────────────────┘
└──────┬───────────┘
       │ 1:N
       ↓
┌──────────────────┐
│stage_parameters  │
│(stage_id, key,   │
│ value)           │
└──────────────────┘
</code></pre>
<h3 id="table-purposes"><a class="header" href="#table-purposes">Table Purposes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Table</th><th>Purpose</th><th>Key Fields</th></tr></thead><tbody>
<tr><td><strong>pipelines</strong></td><td>Core pipeline entity</td><td>id (PK), name (UNIQUE), archived</td></tr>
<tr><td><strong>pipeline_stages</strong></td><td>Stage definitions</td><td>id (PK), pipeline_id (FK), stage_order</td></tr>
<tr><td><strong>pipeline_configuration</strong></td><td>Pipeline-level config</td><td>(pipeline_id, key) composite PK</td></tr>
<tr><td><strong>stage_parameters</strong></td><td>Stage-level parameters</td><td>(stage_id, key) composite PK</td></tr>
<tr><td><strong>processing_metrics</strong></td><td>Execution metrics</td><td>pipeline_id (PK/FK), progress, performance</td></tr>
</tbody></table>
</div>
<h3 id="schema-design-principles"><a class="header" href="#schema-design-principles">Schema Design Principles</a></h3>
<p><strong>1. Normalization</strong></p>
<p>Data is normalized to reduce redundancy:</p>
<pre><code class="language-sql">-- ✅ Normalized: Stages reference pipeline
CREATE TABLE pipeline_stages (
    id TEXT PRIMARY KEY,
    pipeline_id TEXT NOT NULL,  -- Foreign key
    FOREIGN KEY (pipeline_id) REFERENCES pipelines(id) ON DELETE CASCADE
);

-- ❌ Denormalized: Duplicating pipeline data
-- Each stage would store pipeline name, created_at, etc.
</code></pre>
<p><strong>2. Referential Integrity</strong></p>
<p>Foreign keys enforce data consistency:</p>
<pre><code class="language-sql">-- CASCADE DELETE: Deleting pipeline removes all stages
FOREIGN KEY (pipeline_id) REFERENCES pipelines(id) ON DELETE CASCADE

-- Orphaned stages cannot exist
</code></pre>
<p><strong>3. Indexing Strategy</strong></p>
<p>Indexes optimize common queries:</p>
<pre><code class="language-sql">-- Index on foreign keys for JOIN performance
CREATE INDEX idx_pipeline_stages_pipeline_id ON pipeline_stages(pipeline_id);

-- Index on frequently queried fields
CREATE INDEX idx_pipelines_name ON pipelines(name);
CREATE INDEX idx_pipelines_archived ON pipelines(archived);
</code></pre>
<p><strong>4. Timestamps</strong></p>
<p>All entities track creation and modification:</p>
<pre><code class="language-sql">created_at TEXT NOT NULL,  -- RFC 3339 format
updated_at TEXT NOT NULL   -- RFC 3339 format
</code></pre>
<h3 id="schema-initialization"><a class="header" href="#schema-initialization">Schema Initialization</a></h3>
<p><strong>Automated Migration System:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adaptive_pipeline::infrastructure::repositories::schema;

// High-level initialization (recommended)
let pool = schema::initialize_database("sqlite://./pipeline.db").await?;
// Database created, migrations applied, ready to use!

// Manual initialization
schema::create_database_if_missing("sqlite://./pipeline.db").await?;
let pool = SqlitePool::connect("sqlite://./pipeline.db").await?;
schema::ensure_schema(&amp;pool).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Migration Tracking:</strong></p>
<pre><code class="language-sql">-- sqlx automatically creates this table
CREATE TABLE _sqlx_migrations (
    version BIGINT PRIMARY KEY,
    description TEXT NOT NULL,
    installed_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    success BOOLEAN NOT NULL,
    checksum BLOB NOT NULL,
    execution_time BIGINT NOT NULL
);
</code></pre>
<p>For complete schema details, see <a href="schema.html">Schema Management</a>.</p>
<hr />
<h2 id="transaction-management"><a class="header" href="#transaction-management">Transaction Management</a></h2>
<p>SQLite provides full ACID transaction support for data consistency.</p>
<h3 id="acid-properties"><a class="header" href="#acid-properties">ACID Properties</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>SQLite Implementation</th></tr></thead><tbody>
<tr><td><strong>Atomicity</strong></td><td>All-or-nothing commits via rollback journal</td></tr>
<tr><td><strong>Consistency</strong></td><td>Foreign keys, constraints enforce invariants</td></tr>
<tr><td><strong>Isolation</strong></td><td>Serializable isolation (single writer)</td></tr>
<tr><td><strong>Durability</strong></td><td>WAL mode ensures data persists after commit</td></tr>
</tbody></table>
</div>
<h3 id="transaction-usage"><a class="header" href="#transaction-usage">Transaction Usage</a></h3>
<p><strong>Explicit Transactions:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Begin transaction
let mut tx = pool.begin().await?;

// Perform multiple operations
sqlx::query("INSERT INTO pipelines (id, name, created_at, updated_at) VALUES (?, ?, ?, ?)")
    .bind(&amp;id)
    .bind(&amp;name)
    .bind(&amp;now)
    .bind(&amp;now)
    .execute(&amp;mut *tx)
    .await?;

sqlx::query("INSERT INTO pipeline_stages (id, pipeline_id, name, stage_type, stage_order, algorithm, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")
    .bind(&amp;stage_id)
    .bind(&amp;id)
    .bind("compression")
    .bind("compression")
    .bind(0)
    .bind("brotli")
    .bind(&amp;now)
    .bind(&amp;now)
    .execute(&amp;mut *tx)
    .await?;

// Commit transaction (or rollback on error)
tx.commit().await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Automatic Rollback:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn save_pipeline_with_stages(
    pool: &amp;SqlitePool,
    pipeline: &amp;Pipeline,
) -&gt; Result&lt;(), PipelineError&gt; {
    let mut tx = pool.begin().await?;

    // Insert pipeline
    insert_pipeline(&amp;mut tx, pipeline).await?;

    // Insert all stages
    for stage in pipeline.stages() {
        insert_stage(&amp;mut tx, stage).await?;
    }

    // Commit (or automatic rollback if any operation fails)
    tx.commit().await?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="transaction-best-practices"><a class="header" href="#transaction-best-practices">Transaction Best Practices</a></h3>
<p><strong>1. Keep Transactions Short</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Short transaction
let mut tx = pool.begin().await?;
sqlx::query("INSERT INTO ...").execute(&amp;mut *tx).await?;
tx.commit().await?;

// ❌ Bad: Long-running transaction
let mut tx = pool.begin().await?;
expensive_computation().await;  // Don't do this inside transaction!
sqlx::query("INSERT INTO ...").execute(&amp;mut *tx).await?;
tx.commit().await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>2. Handle Errors Gracefully</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match save_pipeline(&amp;pool, &amp;pipeline).await {
    Ok(()) =&gt; info!("Pipeline saved successfully"),
    Err(e) =&gt; {
        error!("Failed to save pipeline: {}", e);
        // Transaction automatically rolled back
        return Err(e);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>3. Use Connection Pool</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Use pool for automatic connection management
async fn save(pool: &amp;SqlitePool, data: &amp;Data) -&gt; Result&lt;(), Error&gt; {
    sqlx::query("INSERT ...").execute(pool).await?;
    Ok(())
}

// ❌ Bad: Creating new connections
async fn save(url: &amp;str, data: &amp;Data) -&gt; Result&lt;(), Error&gt; {
    let pool = SqlitePool::connect(url).await?;  // Expensive!
    sqlx::query("INSERT ...").execute(&amp;pool).await?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="connection-management"><a class="header" href="#connection-management">Connection Management</a></h2>
<p>Efficient connection management is crucial for performance and resource utilization.</p>
<h3 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h3>
<p><strong>SqlitePool Benefits:</strong></p>
<ul>
<li><strong>Connection Reuse</strong>: Avoid overhead of creating new connections</li>
<li><strong>Concurrency Control</strong>: Limit concurrent database access</li>
<li><strong>Automatic Cleanup</strong>: Close idle connections automatically</li>
<li><strong>Health Monitoring</strong>: Detect and recover from connection failures</li>
</ul>
<p><strong>Pool Configuration:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::sqlite::SqlitePoolOptions;
use std::time::Duration;

let pool = SqlitePoolOptions::new()
    // Maximum number of connections in pool
    .max_connections(5)

    // Minimum number of idle connections
    .min_connections(1)

    // Timeout for acquiring connection from pool
    .acquire_timeout(Duration::from_secs(30))

    // Close connections idle for this duration
    .idle_timeout(Duration::from_secs(600))

    // Maximum lifetime of a connection
    .max_lifetime(Duration::from_secs(3600))

    // Test connection before returning from pool
    .test_before_acquire(true)

    .connect(&amp;database_url)
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-lifecycle"><a class="header" href="#connection-lifecycle">Connection Lifecycle</a></h3>
<pre><code class="language-text">1. Application requests connection
   ↓
2. Pool checks for available connection
   ├─ Available → Reuse existing connection
   └─ Not available → Create new connection (if under max)
   ↓
3. Application uses connection
   ↓
4. Application returns connection to pool
   ↓
5. Pool keeps connection alive (if under idle_timeout)
   ↓
6. Connection eventually closed (after max_lifetime)
</code></pre>
<h3 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h3>
<p><strong>Optimal Pool Size:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For CPU-bound workloads
let pool_size = num_cpus::get();

// For I/O-bound workloads
let pool_size = num_cpus::get() * 2;

// For SQLite (single writer)
let pool_size = 5;  // Conservative for write-heavy workloads
<span class="boring">}</span></code></pre></pre>
<p><strong>Connection Timeout Strategies:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Timeout</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong>Web API</strong></td><td>5-10 seconds</td><td>Fail fast for user requests</td></tr>
<tr><td><strong>Background Job</strong></td><td>30-60 seconds</td><td>More tolerance for delays</td></tr>
<tr><td><strong>Batch Processing</strong></td><td>2-5 minutes</td><td>Long-running operations acceptable</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="data-mapping"><a class="header" href="#data-mapping">Data Mapping</a></h2>
<p>Data mapping converts between domain entities and database records.</p>
<h3 id="entity-to-row-mapping"><a class="header" href="#entity-to-row-mapping">Entity-to-Row Mapping</a></h3>
<p><strong>Domain Entity:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Pipeline {
    id: PipelineId,
    name: String,
    stages: Vec&lt;PipelineStage&gt;,
    archived: bool,
    created_at: DateTime&lt;Utc&gt;,
    updated_at: DateTime&lt;Utc&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Database Row:</strong></p>
<pre><code class="language-sql">CREATE TABLE pipelines (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    archived BOOLEAN NOT NULL DEFAULT false,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);
</code></pre>
<p><strong>Mapping Logic:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain → Database (serialize)
let id_str = pipeline.id().to_string();
let name_str = pipeline.name();
let archived_bool = pipeline.is_archived();
let created_at_str = pipeline.created_at().to_rfc3339();
let updated_at_str = pipeline.updated_at().to_rfc3339();

sqlx::query("INSERT INTO pipelines (id, name, archived, created_at, updated_at) VALUES (?, ?, ?, ?, ?)")
    .bind(id_str)
    .bind(name_str)
    .bind(archived_bool)
    .bind(created_at_str)
    .bind(updated_at_str)
    .execute(pool)
    .await?;

// Database → Domain (deserialize)
let row = sqlx::query("SELECT * FROM pipelines WHERE id = ?")
    .bind(id_str)
    .fetch_one(pool)
    .await?;

let id = PipelineId::from(row.get::&lt;String, _&gt;("id"));
let name = row.get::&lt;String, _&gt;("name");
let archived = row.get::&lt;bool, _&gt;("archived");
let created_at = DateTime::parse_from_rfc3339(row.get::&lt;String, _&gt;("created_at"))?;
let updated_at = DateTime::parse_from_rfc3339(row.get::&lt;String, _&gt;("updated_at"))?;
<span class="boring">}</span></code></pre></pre>
<h3 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust Type</th><th>SQLite Type</th><th>Conversion</th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>TEXT</code></td><td>Direct mapping</td></tr>
<tr><td><code>i64</code></td><td><code>INTEGER</code></td><td>Direct mapping</td></tr>
<tr><td><code>f64</code></td><td><code>REAL</code></td><td>Direct mapping</td></tr>
<tr><td><code>bool</code></td><td><code>INTEGER</code> (0/1)</td><td><code>sqlx</code> handles conversion</td></tr>
<tr><td><code>DateTime&lt;Utc&gt;</code></td><td><code>TEXT</code></td><td>RFC 3339 string format</td></tr>
<tr><td><code>PipelineId</code></td><td><code>TEXT</code></td><td>UUID string representation</td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>BLOB</code></td><td>Direct binary mapping</td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td><code>NULL</code> / value</td><td><code>NULL</code> for <code>None</code></td></tr>
</tbody></table>
</div>
<h3 id="handling-relationships"><a class="header" href="#handling-relationships">Handling Relationships</a></h3>
<p><strong>One-to-Many (Pipeline → Stages):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn load_pipeline_with_stages(
    pool: &amp;SqlitePool,
    id: &amp;PipelineId,
) -&gt; Result&lt;Pipeline, PipelineError&gt; {
    // Load pipeline
    let pipeline_row = sqlx::query("SELECT * FROM pipelines WHERE id = ?")
        .bind(id.to_string())
        .fetch_one(pool)
        .await?;

    // Load related stages
    let stage_rows = sqlx::query("SELECT * FROM pipeline_stages WHERE pipeline_id = ? ORDER BY stage_order")
        .bind(id.to_string())
        .fetch_all(pool)
        .await?;

    // Map to domain entities
    let pipeline = map_pipeline_row(pipeline_row)?;
    let stages = stage_rows.into_iter()
        .map(map_stage_row)
        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;

    // Combine into aggregate
    pipeline.with_stages(stages)
}
<span class="boring">}</span></code></pre></pre>
<p>For detailed repository implementation, see <a href="repositories.html">Repository Implementation</a>.</p>
<hr />
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<p>Several strategies optimize persistence performance.</p>
<h3 id="query-optimization"><a class="header" href="#query-optimization">Query Optimization</a></h3>
<p><strong>1. Use Indexes Effectively</strong></p>
<pre><code class="language-sql">-- Index on frequently queried columns
CREATE INDEX idx_pipelines_name ON pipelines(name);
CREATE INDEX idx_pipelines_archived ON pipelines(archived);

-- Index on foreign keys for JOINs
CREATE INDEX idx_pipeline_stages_pipeline_id ON pipeline_stages(pipeline_id);
</code></pre>
<p><strong>2. Avoid N+1 Queries</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Bad: N+1 query problem
for pipeline_id in pipeline_ids {
    let pipeline = repo.find_by_id(&amp;pipeline_id).await?;
    // Process pipeline...
}

// ✅ Good: Single batch query
let pipelines = repo.find_all().await?;
for pipeline in pipelines {
    // Process pipeline...
}
<span class="boring">}</span></code></pre></pre>
<p><strong>3. Use Prepared Statements</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// sqlx automatically uses prepared statements
let pipeline = sqlx::query_as::&lt;_, Pipeline&gt;("SELECT * FROM pipelines WHERE id = ?")
    .bind(id)
    .fetch_one(pool)
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-pool-tuning"><a class="header" href="#connection-pool-tuning">Connection Pool Tuning</a></h3>
<p><strong>Optimal Settings:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For low-concurrency (CLI tools)
.max_connections(2)
.min_connections(1)

// For medium-concurrency (web services)
.max_connections(5)
.min_connections(2)

// For high-concurrency (not recommended for SQLite writes)
.max_connections(10)  // Reading only
.min_connections(5)
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<p><strong>Batch Inserts:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn save_multiple_pipelines(
    pool: &amp;SqlitePool,
    pipelines: &amp;[Pipeline],
) -&gt; Result&lt;(), PipelineError&gt; {
    let mut tx = pool.begin().await?;

    for pipeline in pipelines {
        sqlx::query("INSERT INTO pipelines (id, name, created_at, updated_at) VALUES (?, ?, ?, ?)")
            .bind(pipeline.id().to_string())
            .bind(pipeline.name())
            .bind(pipeline.created_at().to_rfc3339())
            .bind(pipeline.updated_at().to_rfc3339())
            .execute(&amp;mut *tx)
            .await?;
    }

    tx.commit().await?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-benchmarks"><a class="header" href="#performance-benchmarks">Performance Benchmarks</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Latency</th><th>Throughput</th><th>Notes</th></tr></thead><tbody>
<tr><td>Single INSERT</td><td>~0.1ms</td><td>~10K/sec</td><td>Without transaction</td></tr>
<tr><td>Batch INSERT (1000)</td><td>~10ms</td><td>~100K/sec</td><td>Within transaction</td></tr>
<tr><td>Single SELECT by ID</td><td>~0.05ms</td><td>~20K/sec</td><td>With index</td></tr>
<tr><td>SELECT with JOIN</td><td>~0.5ms</td><td>~2K/sec</td><td>Two-table join</td></tr>
<tr><td>Full table scan (10K rows)</td><td>~10ms</td><td>~1K/sec</td><td>Without index</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="example-1-basic-crud-operations"><a class="header" href="#example-1-basic-crud-operations">Example 1: Basic CRUD Operations</a></h3>
<pre><pre class="playground"><code class="language-rust">use adaptive_pipeline::infrastructure::repositories::{schema, SqlitePipelineRepository};
use adaptive_pipeline_domain::Pipeline;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize database
    let pool = schema::initialize_database("sqlite://./pipeline.db").await?;
    let repo = SqlitePipelineRepository::new(pool);

    // Create pipeline
    let pipeline = Pipeline::new("my-pipeline".to_string())?;
    repo.save(&amp;pipeline).await?;
    println!("Saved pipeline: {}", pipeline.id());

    // Read pipeline
    let loaded = repo.find_by_id(pipeline.id()).await?
        .ok_or("Pipeline not found")?;
    println!("Loaded pipeline: {}", loaded.name());

    // Update pipeline
    let mut updated = loaded;
    updated.update_name("renamed-pipeline".to_string())?;
    repo.update(&amp;updated).await?;

    // Delete pipeline
    repo.delete(updated.id()).await?;
    println!("Deleted pipeline");

    Ok(())
}</code></pre></pre>
<h3 id="example-2-transaction-management"><a class="header" href="#example-2-transaction-management">Example 2: Transaction Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::SqlitePool;

async fn save_pipeline_atomically(
    pool: &amp;SqlitePool,
    pipeline: &amp;Pipeline,
) -&gt; Result&lt;(), PipelineError&gt; {
    // Begin transaction
    let mut tx = pool.begin().await?;

    // Insert pipeline
    sqlx::query("INSERT INTO pipelines (id, name, created_at, updated_at) VALUES (?, ?, ?, ?)")
        .bind(pipeline.id().to_string())
        .bind(pipeline.name())
        .bind(pipeline.created_at().to_rfc3339())
        .bind(pipeline.updated_at().to_rfc3339())
        .execute(&amp;mut *tx)
        .await?;

    // Insert all stages
    for (i, stage) in pipeline.stages().iter().enumerate() {
        sqlx::query("INSERT INTO pipeline_stages (id, pipeline_id, name, stage_type, stage_order, algorithm, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")
            .bind(stage.id().to_string())
            .bind(pipeline.id().to_string())
            .bind(stage.name())
            .bind(stage.stage_type().to_string())
            .bind(i as i64)
            .bind(stage.algorithm())
            .bind(stage.created_at().to_rfc3339())
            .bind(stage.updated_at().to_rfc3339())
            .execute(&amp;mut *tx)
            .await?;
    }

    // Commit transaction (or rollback on error)
    tx.commit().await?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-3-query-with-pagination"><a class="header" href="#example-3-query-with-pagination">Example 3: Query with Pagination</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn list_pipelines_paginated(
    repo: &amp;dyn PipelineRepository,
    page: usize,
    page_size: usize,
) -&gt; Result&lt;Vec&lt;Pipeline&gt;, PipelineError&gt; {
    let offset = page * page_size;
    repo.list_paginated(offset, page_size).await
}

// Usage
let page_1 = list_pipelines_paginated(&amp;repo, 0, 10).await?;  // First 10
let page_2 = list_pipelines_paginated(&amp;repo, 1, 10).await?;  // Next 10
<span class="boring">}</span></code></pre></pre>
<h3 id="example-4-archive-management"><a class="header" href="#example-4-archive-management">Example 4: Archive Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn archive_old_pipelines(
    repo: &amp;dyn PipelineRepository,
    cutoff_date: DateTime&lt;Utc&gt;,
) -&gt; Result&lt;usize, PipelineError&gt; {
    let pipelines = repo.find_all().await?;
    let mut archived_count = 0;

    for pipeline in pipelines {
        if pipeline.created_at() &lt; &amp;cutoff_date {
            repo.archive(pipeline.id()).await?;
            archived_count += 1;
        }
    }

    Ok(archived_count)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-5-connection-pool-management"><a class="header" href="#example-5-connection-pool-management">Example 5: Connection Pool Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::sqlite::SqlitePoolOptions;
use std::time::Duration;

async fn create_optimized_pool(database_url: &amp;str) -&gt; Result&lt;SqlitePool, sqlx::Error&gt; {
    let pool = SqlitePoolOptions::new()
        .max_connections(5)
        .min_connections(1)
        .acquire_timeout(Duration::from_secs(30))
        .idle_timeout(Duration::from_secs(600))
        .max_lifetime(Duration::from_secs(3600))
        .connect(database_url)
        .await?;

    Ok(pool)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-use-transactions-for-multi-step-operations"><a class="header" href="#1-use-transactions-for-multi-step-operations">1. Use Transactions for Multi-Step Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Atomic multi-step operation
async fn create_pipeline_with_stages(pool: &amp;SqlitePool, pipeline: &amp;Pipeline) -&gt; Result&lt;(), Error&gt; {
    let mut tx = pool.begin().await?;
    insert_pipeline(&amp;mut tx, pipeline).await?;
    insert_stages(&amp;mut tx, pipeline.stages()).await?;
    tx.commit().await?;
    Ok(())
}

// ❌ Bad: Non-atomic operations
async fn create_pipeline_with_stages(pool: &amp;SqlitePool, pipeline: &amp;Pipeline) -&gt; Result&lt;(), Error&gt; {
    insert_pipeline(pool, pipeline).await?;
    insert_stages(pool, pipeline.stages()).await?;  // May fail, leaving orphaned pipeline
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-always-use-connection-pooling"><a class="header" href="#2-always-use-connection-pooling">2. Always Use Connection Pooling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Reuse pool
let pool = SqlitePool::connect(&amp;url).await?;
let repo = SqlitePipelineRepository::new(pool.clone());
let service = PipelineService::new(Arc::new(repo));

// ❌ Bad: Create new connections
for _ in 0..100 {
    let pool = SqlitePool::connect(&amp;url).await?;  // Expensive!
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-handle-database-errors-gracefully"><a class="header" href="#3-handle-database-errors-gracefully">3. Handle Database Errors Gracefully</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match repo.save(&amp;pipeline).await {
    Ok(()) =&gt; info!("Pipeline saved successfully"),
    Err(PipelineError::DatabaseError(msg)) if msg.contains("UNIQUE constraint") =&gt; {
        warn!("Pipeline already exists: {}", pipeline.name());
    }
    Err(e) =&gt; {
        error!("Failed to save pipeline: {}", e);
        return Err(e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-use-indexes-for-frequently-queried-fields"><a class="header" href="#4-use-indexes-for-frequently-queried-fields">4. Use Indexes for Frequently Queried Fields</a></h3>
<pre><code class="language-sql">-- ✅ Good: Index on query columns
CREATE INDEX idx_pipelines_name ON pipelines(name);
SELECT * FROM pipelines WHERE name = ?;  -- Fast!

-- ❌ Bad: No index on query column
-- No index on 'name'
SELECT * FROM pipelines WHERE name = ?;  -- Slow (full table scan)
</code></pre>
<h3 id="5-keep-transactions-short"><a class="header" href="#5-keep-transactions-short">5. Keep Transactions Short</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Short transaction
let mut tx = pool.begin().await?;
sqlx::query("INSERT ...").execute(&amp;mut *tx).await?;
tx.commit().await?;

// ❌ Bad: Long transaction holding locks
let mut tx = pool.begin().await?;
expensive_computation().await;  // Don't do this!
sqlx::query("INSERT ...").execute(&amp;mut *tx).await?;
tx.commit().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="6-validate-data-before-persisting"><a class="header" href="#6-validate-data-before-persisting">6. Validate Data Before Persisting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Validate before save
async fn save_pipeline(repo: &amp;dyn PipelineRepository, pipeline: &amp;Pipeline) -&gt; Result&lt;(), Error&gt; {
    pipeline.validate()?;  // Validate first
    repo.save(pipeline).await?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="7-use-migrations-for-schema-changes"><a class="header" href="#7-use-migrations-for-schema-changes">7. Use Migrations for Schema Changes</a></h3>
<pre><code class="language-bash"># ✅ Good: Create migration
sqlx migrate add add_archived_column

# Edit migration file
# migrations/20250101000001_add_archived_column.sql
ALTER TABLE pipelines ADD COLUMN archived BOOLEAN NOT NULL DEFAULT false;

# Apply migration
sqlx migrate run
</code></pre>
<hr />
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="issue-1-database-locked-error"><a class="header" href="#issue-1-database-locked-error">Issue 1: Database Locked Error</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Error: database is locked
</code></pre>
<p><strong>Causes:</strong></p>
<ul>
<li>Long-running transaction blocking other operations</li>
<li>Multiple writers attempting simultaneous writes</li>
<li>Connection not released back to pool</li>
</ul>
<p><strong>Solutions:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Reduce transaction duration
let mut tx = pool.begin().await?;
// Do minimal work inside transaction
sqlx::query("INSERT ...").execute(&amp;mut *tx).await?;
tx.commit().await?;

// 2. Enable WAL mode for better concurrency
use sqlx::sqlite::SqliteConnectOptions;
let options = SqliteConnectOptions::new()
    .filename("./pipeline.db")
    .journal_mode(sqlx::sqlite::SqliteJournalMode::Wal);

// 3. Increase busy timeout
.busy_timeout(Duration::from_secs(5))
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-2-connection-pool-exhausted"><a class="header" href="#issue-2-connection-pool-exhausted">Issue 2: Connection Pool Exhausted</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Error: timed out while waiting for an open connection
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Increase pool size
.max_connections(10)

// 2. Increase acquire timeout
.acquire_timeout(Duration::from_secs(60))

// 3. Ensure connections are returned
async fn query_data(pool: &amp;SqlitePool) -&gt; Result&lt;(), Error&gt; {
    let result = sqlx::query("SELECT ...").fetch_all(pool).await?;
    // Connection automatically returned to pool
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-3-foreign-key-constraint-failed"><a class="header" href="#issue-3-foreign-key-constraint-failed">Issue 3: Foreign Key Constraint Failed</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Error: FOREIGN KEY constraint failed
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Ensure foreign keys are enabled
.foreign_keys(true)

// 2. Verify referenced record exists
let exists = sqlx::query_scalar("SELECT EXISTS(SELECT 1 FROM pipelines WHERE id = ?)")
    .bind(&amp;pipeline_id)
    .fetch_one(pool)
    .await?;

if !exists {
    return Err("Pipeline not found".into());
}

// 3. Use CASCADE DELETE for automatic cleanup
CREATE TABLE pipeline_stages (
    ...
    FOREIGN KEY (pipeline_id) REFERENCES pipelines(id) ON DELETE CASCADE
);
<span class="boring">}</span></code></pre></pre>
<h3 id="issue-4-migration-checksum-mismatch"><a class="header" href="#issue-4-migration-checksum-mismatch">Issue 4: Migration Checksum Mismatch</a></h3>
<p><strong>Symptom:</strong></p>
<pre><code class="language-text">Error: migration checksum mismatch
</code></pre>
<p><strong>Solutions:</strong></p>
<pre><code class="language-bash"># Option 1: Revert migration
sqlx migrate revert

# Option 2: Reset database (development only!)
rm pipeline.db
sqlx migrate run

# Option 3: Create new migration to fix
sqlx migrate add fix_schema_issue
</code></pre>
<h3 id="issue-5-query-performance-degradation"><a class="header" href="#issue-5-query-performance-degradation">Issue 5: Query Performance Degradation</a></h3>
<p><strong>Diagnosis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable query logging
RUST_LOG=sqlx=debug cargo run

// Analyze slow queries
let start = Instant::now();
let result = query.fetch_all(pool).await?;
let duration = start.elapsed();
if duration &gt; Duration::from_millis(100) {
    warn!("Slow query: {:?}", duration);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Solutions:</strong></p>
<pre><code class="language-sql">-- 1. Add missing indexes
CREATE INDEX idx_pipelines_created_at ON pipelines(created_at);

-- 2. Use EXPLAIN QUERY PLAN
EXPLAIN QUERY PLAN SELECT * FROM pipelines WHERE name = ?;

-- 3. Optimize query
-- Before: Full table scan
SELECT * FROM pipelines WHERE lower(name) = ?;

-- After: Use index
SELECT * FROM pipelines WHERE name = ?;
</code></pre>
<hr />
<h2 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h2>
<h3 id="unit-testing-with-mock-repository"><a class="header" href="#unit-testing-with-mock-repository">Unit Testing with Mock Repository</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    struct MockPipelineRepository {
        pipelines: Arc&lt;Mutex&lt;HashMap&lt;PipelineId, Pipeline&gt;&gt;&gt;,
    }

    #[async_trait]
    impl PipelineRepository for MockPipelineRepository {
        async fn save(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt; {
            let mut pipelines = self.pipelines.lock().await;
            pipelines.insert(pipeline.id().clone(), pipeline.clone());
            Ok(())
        }

        async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt; {
            let pipelines = self.pipelines.lock().await;
            Ok(pipelines.get(id).cloned())
        }

        // ... implement other methods
    }

    #[tokio::test]
    async fn test_save_and_load() {
        let repo = MockPipelineRepository {
            pipelines: Arc::new(Mutex::new(HashMap::new())),
        };

        let pipeline = Pipeline::new("test".to_string()).unwrap();
        repo.save(&amp;pipeline).await.unwrap();

        let loaded = repo.find_by_id(pipeline.id()).await.unwrap().unwrap();
        assert_eq!(loaded.name(), "test");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing-with-sqlite"><a class="header" href="#integration-testing-with-sqlite">Integration Testing with SQLite</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_sqlite_repository_integration() {
    // Use in-memory database for tests
    let pool = schema::initialize_database("sqlite::memory:").await.unwrap();
    let repo = SqlitePipelineRepository::new(pool);

    // Create pipeline
    let pipeline = Pipeline::new("integration-test".to_string()).unwrap();
    repo.save(&amp;pipeline).await.unwrap();

    // Verify persistence
    let loaded = repo.find_by_id(pipeline.id()).await.unwrap().unwrap();
    assert_eq!(loaded.name(), "integration-test");

    // Verify stages are loaded
    assert_eq!(loaded.stages().len(), pipeline.stages().len());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="transaction-testing"><a class="header" href="#transaction-testing">Transaction Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_transaction_rollback() {
    let pool = schema::initialize_database("sqlite::memory:").await.unwrap();

    let result = async {
        let mut tx = pool.begin().await?;

        sqlx::query("INSERT INTO pipelines (id, name, created_at, updated_at) VALUES (?, ?, ?, ?)")
            .bind("test-id")
            .bind("test")
            .bind("2025-01-01T00:00:00Z")
            .bind("2025-01-01T00:00:00Z")
            .execute(&amp;mut *tx)
            .await?;

        // Simulate error
        return Err::&lt;(), sqlx::Error&gt;(sqlx::Error::RowNotFound);

        // This would commit, but error prevents it
        // tx.commit().await?;
    }.await;

    assert!(result.is_err());

    // Verify rollback - no pipeline should exist
    let count: i64 = sqlx::query_scalar("SELECT COUNT(*) FROM pipelines")
        .fetch_one(&amp;pool)
        .await
        .unwrap();
    assert_eq!(count, 0);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>After understanding data persistence fundamentals, explore specific implementations:</p>
<h3 id="detailed-persistence-topics"><a class="header" href="#detailed-persistence-topics">Detailed Persistence Topics</a></h3>
<ol>
<li><strong><a href="repositories.html">Repository Implementation</a></strong>: Deep dive into repository pattern implementation</li>
<li><strong><a href="schema.html">Schema Management</a></strong>: Database schema design and migration strategies</li>
</ol>
<h3 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h3>
<ul>
<li><strong><a href="observability.html">Observability</a></strong>: Monitoring database operations and performance</li>
<li><strong><a href="stages.html">Stage Processing</a></strong>: How stages interact with persistence layer</li>
</ul>
<h3 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h3>
<ul>
<li><strong><a href="../advanced/performance.html">Performance Optimization</a></strong>: Database query optimization and profiling</li>
<li><strong><a href="../advanced/extending.html">Extending the Pipeline</a></strong>: Adding custom persistence backends</li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><strong>Key Takeaways:</strong></p>
<ol>
<li><strong>Repository Pattern</strong> provides abstraction between domain and infrastructure layers</li>
<li><strong>SQLite</strong> offers zero-configuration, ACID-compliant persistence</li>
<li><strong>Schema Management</strong> uses sqlx migrations for automated database evolution</li>
<li><strong>Connection Pooling</strong> optimizes resource utilization and performance</li>
<li><strong>Transactions</strong> ensure data consistency with ACID guarantees</li>
<li><strong>Data Mapping</strong> converts between domain entities and database records</li>
<li><strong>Performance</strong> optimized through indexing, batching, and query optimization</li>
</ol>
<p><strong>Architecture File References:</strong></p>
<ul>
<li><strong>Repository Interface:</strong> <code>pipeline-domain/src/repositories/pipeline_repository.rs:138</code></li>
<li><strong>SQLite Implementation:</strong> <code>pipeline/src/infrastructure/repositories/sqlite_pipeline_repository.rs:193</code></li>
<li><strong>Schema Management:</strong> <code>pipeline/src/infrastructure/repositories/schema.rs:18</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../implementation/integrity.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../implementation/repositories.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../implementation/integrity.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../implementation/repositories.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
