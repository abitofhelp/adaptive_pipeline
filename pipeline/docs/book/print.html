<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pipeline Developer Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pipeline Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pipeline-developer-guide"><a class="header" href="#pipeline-developer-guide">Pipeline Developer Guide</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<h2 id="welcome"><a class="header" href="#welcome">Welcome</a></h2>
<p>This is the comprehensive technical guide for the Optimized Adaptive Pipeline. Whether you're learning advanced Rust patterns, contributing to the project, or using the pipeline in production, this guide provides the depth you need.</p>
<h2 id="how-to-use-this-guide"><a class="header" href="#how-to-use-this-guide">How to Use This Guide</a></h2>
<p>This guide follows a <strong>progressive disclosure</strong> approach - each section builds on previous ones:</p>
<h3 id="start-here-fundamentals"><a class="header" href="#start-here-fundamentals">Start Here: Fundamentals</a></h3>
<p>If you're new to the pipeline, start with <strong>Fundamentals</strong>. This section introduces core concepts in an accessible way:</p>
<ul>
<li>What pipelines do and why they're useful</li>
<li>Key terminology and concepts</li>
<li>How stages work together</li>
<li>Basic configuration</li>
<li>Running your first pipeline</li>
</ul>
<p><strong>Time commitment:</strong> 30-45 minutes</p>
<h3 id="building-understanding-architecture"><a class="header" href="#building-understanding-architecture">Building Understanding: Architecture</a></h3>
<p>Once you understand the basics, explore the <strong>Architecture</strong> section. This explains <em>how</em> the pipeline is designed:</p>
<ul>
<li>Layered architecture (Domain, Application, Infrastructure)</li>
<li>Domain-Driven Design concepts</li>
<li>Design patterns in use (Repository, Service, Adapter, Observer)</li>
<li>Dependency management</li>
</ul>
<p>This section bridges the gap between basic usage and implementation details.</p>
<p><strong>Time commitment:</strong> 1-2 hours</p>
<h3 id="going-deeper-implementation"><a class="header" href="#going-deeper-implementation">Going Deeper: Implementation</a></h3>
<p>The <strong>Implementation</strong> section covers how specific features work:</p>
<ul>
<li>Stage processing details</li>
<li>Compression and encryption</li>
<li>Data persistence and schema management</li>
<li>File I/O and chunking</li>
<li>Metrics and observability</li>
</ul>
<p>Perfect for contributors or those adapting the pipeline for specific needs.</p>
<p><strong>Time commitment:</strong> 2-3 hours</p>
<h3 id="expert-level-advanced-topics"><a class="header" href="#expert-level-advanced-topics">Expert Level: Advanced Topics</a></h3>
<p>For optimization and extension, the <strong>Advanced Topics</strong> section covers:</p>
<ul>
<li>Concurrency model and thread pooling</li>
<li>Performance optimization techniques</li>
<li>Creating custom stages and algorithms</li>
</ul>
<p><strong>Time commitment:</strong> 2-4 hours depending on depth</p>
<h3 id="reference-formal-documentation"><a class="header" href="#reference-formal-documentation">Reference: Formal Documentation</a></h3>
<p>The <strong>Formal Documentation</strong> section contains:</p>
<ul>
<li>Software Requirements Specification (SRS)</li>
<li>Software Design Document (SDD)</li>
<li>Test Strategy (STP)</li>
</ul>
<p>These are comprehensive reference documents.</p>
<h2 id="documentation-scope"><a class="header" href="#documentation-scope">Documentation Scope</a></h2>
<p>Following our <strong>"reasonable" principle</strong>, this guide focuses on:</p>
<p>✅ <strong>What you need to know</strong> to use, contribute to, or extend the pipeline
✅ <strong>Why decisions were made</strong> with just enough context
✅ <strong>How to accomplish tasks</strong> with practical examples
✅ <strong>Advanced Rust patterns</strong> demonstrated in real code</p>
<p>We intentionally <strong>do not</strong> include:</p>
<p>❌ Rust language tutorials (see <a href="https://doc.rust-lang.org/book/">The Rust Book</a>)
❌ General programming concepts
❌ Third-party library documentation (links provided instead)
❌ Exhaustive algorithm details (high-level explanations with references)</p>
<h2 id="learning-path-recommendations"><a class="header" href="#learning-path-recommendations">Learning Path Recommendations</a></h2>
<h3 id="i-want-to-use-the-pipeline"><a class="header" href="#i-want-to-use-the-pipeline">I want to use the pipeline</a></h3>
<p>→ Read <a href="fundamentals/what-is-a-pipeline.html">Fundamentals</a>
→ Skip to <a href="implementation/stages.html">Implementation</a> for specific features</p>
<h3 id="i-want-to-contribute"><a class="header" href="#i-want-to-contribute">I want to contribute</a></h3>
<p>→ Read Fundamentals + Architecture (full sections)
→ Review relevant Implementation chapters
→ Check <a href="../../docs/book/contributing/guidelines.html">Contributing Guide</a></p>
<h3 id="i-want-to-learn-advanced-rust-patterns"><a class="header" href="#i-want-to-learn-advanced-rust-patterns">I want to learn advanced Rust patterns</a></h3>
<p>→ Focus on Architecture section (patterns)
→ Review Implementation for real-world examples
→ Study Advanced Topics for concurrency/performance</p>
<h3 id="im-building-something-similar"><a class="header" href="#im-building-something-similar">I'm building something similar</a></h3>
<p>→ Read Architecture + Implementation
→ Study formal documentation (SRS/SDD)
→ Review source code with this guide as reference</p>
<h2 id="conventions-used"><a class="header" href="#conventions-used">Conventions Used</a></h2>
<p>Throughout this guide:</p>
<ul>
<li><strong>Code examples</strong> are complete and runnable unless marked otherwise</li>
<li><strong>File paths</strong> use format <code>module/file.rs:line</code> for source references</li>
<li><strong>Diagrams</strong> are in PlantUML (SVG rendered in book)</li>
<li><strong>Callouts</strong> highlight important information:</li>
</ul>
<blockquote>
<p><strong>Note:</strong> Additional helpful information</p>
</blockquote>
<blockquote>
<p><strong>Warning:</strong> Important caveats or gotchas</p>
</blockquote>
<blockquote>
<p><strong>Example:</strong> Practical code demonstration</p>
</blockquote>
<h2 id="ready-to-start"><a class="header" href="#ready-to-start">Ready to Start?</a></h2>
<p>Choose your path:</p>
<ul>
<li><strong>New users:</strong> <a href="fundamentals/what-is-a-pipeline.html">What is a Pipeline?</a></li>
<li><strong>Contributors:</strong> <a href="architecture/overview.html">Architecture Overview</a></li>
<li><strong>Specific feature:</strong> Use search (press 's') or browse <a href="introduction.html#">table of contents</a></li>
</ul>
<p>Let's dive in!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-pipeline"><a class="header" href="#what-is-a-pipeline">What is a Pipeline?</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Introduction to pipelines and their purpose.</p>
<h2 id="what-is-a-pipeline-1"><a class="header" href="#what-is-a-pipeline-1">What is a Pipeline?</a></h2>
<p>A <strong>pipeline</strong> is a series of connected processing stages that transform data from input to output. Each stage performs a specific operation, and data flows through the stages sequentially or in parallel.</p>
<p>Think of it like a factory assembly line:</p>
<ul>
<li>Raw materials (input file) enter at one end</li>
<li>Each station (stage) performs a specific task</li>
<li>The finished product (processed file) exits at the other end</li>
</ul>
<h2 id="real-world-analogy"><a class="header" href="#real-world-analogy">Real-World Analogy</a></h2>
<h3 id="assembly-line"><a class="header" href="#assembly-line">Assembly Line</a></h3>
<p>Imagine an automobile assembly line:</p>
<pre><code>Raw Materials → Welding → Painting → Assembly → Quality Check → Finished Car
</code></pre>
<p>In our pipeline system:</p>
<pre><code>Input File → Compression → Encryption → Validation → Output File
</code></pre>
<p>Each stage:</p>
<ul>
<li>Receives data from the previous stage</li>
<li>Performs its specific transformation</li>
<li>Passes the result to the next stage</li>
</ul>
<h2 id="why-use-a-pipeline"><a class="header" href="#why-use-a-pipeline">Why Use a Pipeline?</a></h2>
<h3 id="modularity"><a class="header" href="#modularity">Modularity</a></h3>
<p>Each stage does one thing well. You can:</p>
<ul>
<li>Add new stages easily</li>
<li>Remove stages you don't need</li>
<li>Reorder stages as needed</li>
</ul>
<p><strong>Example</strong>: Need encryption? Add an encryption stage. Don't need compression? Remove the compression stage.</p>
<h3 id="reusability"><a class="header" href="#reusability">Reusability</a></h3>
<p>Stages can be used in multiple pipelines:</p>
<ul>
<li>Use the same compression stage in different workflows</li>
<li>Share validation logic across projects</li>
<li>Build libraries of reusable components</li>
</ul>
<h3 id="testability"><a class="header" href="#testability">Testability</a></h3>
<p>Each stage can be tested independently:</p>
<ul>
<li>Unit test individual stages</li>
<li>Mock stage inputs/outputs</li>
<li>Verify stage behavior in isolation</li>
</ul>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<p>Pipelines can process data efficiently:</p>
<ul>
<li>Process file chunks in parallel</li>
<li>Distribute work across CPU cores</li>
<li>Handle files of any size</li>
</ul>
<h2 id="our-pipeline-system"><a class="header" href="#our-pipeline-system">Our Pipeline System</a></h2>
<p>The Optimized Adaptive Pipeline provides:</p>
<p><strong>File Processing</strong>: Transform files through configurable stages</p>
<ul>
<li>Input: Any file type</li>
<li>Stages: Compression, encryption, validation</li>
<li>Output: Processed <code>.adapipe</code> file</li>
</ul>
<p><strong>Flexibility</strong>: Configure stages for your needs</p>
<ul>
<li>Enable/disable stages</li>
<li>Choose algorithms (Brotli, LZ4, Zstandard for compression)</li>
<li>Set security levels (Public → Top Secret)</li>
</ul>
<p><strong>Performance</strong>: Handle large files efficiently</p>
<ul>
<li>Stream processing (low memory usage)</li>
<li>Parallel chunk processing</li>
<li>Optimized algorithms</li>
</ul>
<p><strong>Security</strong>: Protect sensitive data</p>
<ul>
<li>AES-256-GCM encryption</li>
<li>Argon2 key derivation</li>
<li>Integrity verification with checksums</li>
</ul>
<h2 id="pipeline-flow"><a class="header" href="#pipeline-flow">Pipeline Flow</a></h2>
<p>Here's how data flows through the pipeline:</p>
<p><img src="fundamentals/../diagrams/pipeline-flow.svg" alt="Pipeline Flow" /></p>
<ol>
<li><strong>Input</strong>: Read file from disk</li>
<li><strong>Chunk</strong>: Split into manageable pieces (default 1MB)</li>
<li><strong>Process</strong>: Apply stages to each chunk
<ul>
<li>Compress (optional)</li>
<li>Encrypt (optional)</li>
<li>Calculate checksum (always)</li>
</ul>
</li>
<li><strong>Store</strong>: Write processed data and metadata</li>
<li><strong>Verify</strong>: Confirm integrity of output</li>
</ol>
<h2 id="what-you-can-do"><a class="header" href="#what-you-can-do">What You Can Do</a></h2>
<p>With this pipeline, you can:</p>
<p>✅ <strong>Compress files</strong> to save storage space
✅ <strong>Encrypt files</strong> to protect sensitive data
✅ <strong>Validate integrity</strong> to detect corruption
✅ <strong>Process large files</strong> without running out of memory
✅ <strong>Customize workflows</strong> with configurable stages
✅ <strong>Track metrics</strong> to monitor performance</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Continue to:</p>
<ul>
<li><a href="fundamentals/core-concepts.html">Core Concepts</a> - Key terminology and ideas</li>
<li><a href="fundamentals/stages.html">Pipeline Stages</a> - Understanding stage types</li>
<li><a href="fundamentals/configuration.html">Configuration Basics</a> - How to configure pipelines</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Essential concepts for understanding the pipeline.</p>
<h2 id="key-terminology"><a class="header" href="#key-terminology">Key Terminology</a></h2>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<p>A complete file processing workflow with:</p>
<ul>
<li><strong>Unique ID</strong>: Every pipeline has a ULID identifier</li>
<li><strong>Input path</strong>: Source file to process</li>
<li><strong>Output path</strong>: Destination for processed data</li>
<li><strong>Stages</strong>: Ordered list of processing steps</li>
<li><strong>Status</strong>: Created → Running → Completed (or Failed)</li>
</ul>
<h3 id="stage"><a class="header" href="#stage">Stage</a></h3>
<p>An individual processing operation within a pipeline:</p>
<ul>
<li><strong>Type</strong>: Compression, Encryption, or Integrity Check</li>
<li><strong>Algorithm</strong>: Specific implementation (e.g., Brotli, AES-256-GCM)</li>
<li><strong>Sequence</strong>: Order in the pipeline (1, 2, 3, ...)</li>
<li><strong>Configuration</strong>: Stage-specific settings</li>
</ul>
<h3 id="file-chunk"><a class="header" href="#file-chunk">File Chunk</a></h3>
<p>A portion of a file processed independently:</p>
<ul>
<li><strong>Size</strong>: Configurable (default 1MB)</li>
<li><strong>Sequence</strong>: Chunk number (0, 1, 2, ...)</li>
<li><strong>Checksum</strong>: Integrity verification value</li>
<li><strong>Offset</strong>: Position in original file</li>
</ul>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="entities"><a class="header" href="#entities">Entities</a></h3>
<p><strong>Pipeline Entity</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Pipeline {
    id: PipelineId,
    input_file_path: FilePath,
    output_file_path: FilePath,
    stages: Vec&lt;PipelineStage&gt;,
    status: PipelineStatus,
    created_at: DateTime,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>PipelineStage Entity</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PipelineStage {
    id: StageId,
    pipeline_id: PipelineId,
    stage_type: StageType,
    algorithm: Algorithm,
    sequence_number: u32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="value-objects"><a class="header" href="#value-objects">Value Objects</a></h3>
<p><strong>FilePath</strong> - Validated file system path</p>
<ul>
<li>Must exist (for input) or be writable (for output)</li>
<li>Supports absolute and relative paths</li>
<li>Cross-platform compatibility</li>
</ul>
<p><strong>FileSize</strong> - File size in bytes</p>
<ul>
<li>Human-readable display (KB, MB, GB)</li>
<li>Validation for reasonable limits</li>
<li>Efficient storage representation</li>
</ul>
<p><strong>Algorithm</strong> - Processing algorithm specification</p>
<ul>
<li>Compression: Brotli, LZ4, Zstandard</li>
<li>Encryption: AES-256-GCM, ChaCha20-Poly1305</li>
<li>Checksum: Blake3, SHA-256</li>
</ul>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<h3 id="sequential-processing"><a class="header" href="#sequential-processing">Sequential Processing</a></h3>
<p>Stages execute in order:</p>
<pre><code>Input → Stage 1 → Stage 2 → Stage 3 → Output
</code></pre>
<h3 id="parallel-chunk-processing"><a class="header" href="#parallel-chunk-processing">Parallel Chunk Processing</a></h3>
<p>Chunks process independently:</p>
<pre><code>Chunk 0 ──┐
Chunk 1 ──┼→ All go through stages → Reassemble
Chunk 2 ──┘
</code></pre>
<p>This enables:</p>
<ul>
<li><strong>Concurrency</strong>: Multiple chunks processed simultaneously</li>
<li><strong>Memory efficiency</strong>: Only active chunks in memory</li>
<li><strong>Scalability</strong>: Leverage multiple CPU cores</li>
</ul>
<h3 id="pipeline-execution-sequence"><a class="header" href="#pipeline-execution-sequence">Pipeline Execution Sequence</a></h3>
<p><img src="fundamentals/../diagrams/stage-execution.svg" alt="Stage Execution" /></p>
<ol>
<li><strong>CLI</strong> receives command</li>
<li><strong>Pipeline Service</strong> creates pipeline</li>
<li><strong>File Processor</strong> reads input file</li>
<li>For each chunk:
<ul>
<li>Apply compression (if enabled)</li>
<li>Apply encryption (if enabled)</li>
<li>Calculate checksum (always)</li>
<li>Store chunk metadata</li>
<li>Write processed chunk</li>
</ul>
</li>
<li>Update pipeline status</li>
<li>Return result to user</li>
</ol>
<h2 id="domain-model"><a class="header" href="#domain-model">Domain Model</a></h2>
<p>Our domain model follows Domain-Driven Design principles:</p>
<p><img src="fundamentals/../diagrams/domain-model.svg" alt="Domain Model" /></p>
<h3 id="aggregates"><a class="header" href="#aggregates">Aggregates</a></h3>
<p><strong>Pipeline Aggregate</strong> - The root entity</p>
<ul>
<li>Contains Pipeline entity</li>
<li>Manages associated FileChunks</li>
<li>Enforces business rules</li>
<li>Ensures consistency</li>
</ul>
<h3 id="relationships"><a class="header" href="#relationships">Relationships</a></h3>
<ul>
<li>Pipeline <strong>has many</strong> PipelineStages (1:N)</li>
<li>Pipeline <strong>processes</strong> FileChunks (1:N)</li>
<li>FileChunk <strong>belongs to</strong> Pipeline (N:1)</li>
<li>PipelineStage <strong>uses</strong> Algorithm (N:1)</li>
</ul>
<h2 id="processing-guarantees"><a class="header" href="#processing-guarantees">Processing Guarantees</a></h2>
<h3 id="integrity"><a class="header" href="#integrity">Integrity</a></h3>
<p>Every chunk has a checksum:</p>
<ul>
<li>Calculated after processing</li>
<li>Verified on read/restore</li>
<li>Detects any corruption</li>
</ul>
<h3 id="atomicity"><a class="header" href="#atomicity">Atomicity</a></h3>
<p>Pipeline operations are transactional:</p>
<ul>
<li>All stages complete, or none do</li>
<li>Metadata stored consistently</li>
<li>No partial outputs on failure</li>
</ul>
<h3 id="durability"><a class="header" href="#durability">Durability</a></h3>
<p>Processed data is persisted:</p>
<ul>
<li>SQLite database for metadata</li>
<li>File system for binary data</li>
<li>Recoverable after crashes</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Continue to:</p>
<ul>
<li><a href="fundamentals/stages.html">Pipeline Stages</a> - Types of stages available</li>
<li><a href="fundamentals/configuration.html">Configuration Basics</a> - How to configure pipelines</li>
<li><a href="fundamentals/first-run.html">Running Your First Pipeline</a> - Hands-on tutorial</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline-stages"><a class="header" href="#pipeline-stages">Pipeline Stages</a></h1>
<p><strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner, Claude Code
<strong>Status:</strong> Active</p>
<h2 id="what-is-a-stage"><a class="header" href="#what-is-a-stage">What is a Stage?</a></h2>
<p>A <strong>pipeline stage</strong> is a single processing operation that transforms data in a specific way. Each stage performs one well-defined task, like compressing data, encrypting it, or verifying its integrity.</p>
<p>Think of stages like workstations on an assembly line. Each workstation has specialized tools and performs one specific operation. The product moves from one workstation to the next until it's complete.</p>
<h2 id="stage-types"><a class="header" href="#stage-types">Stage Types</a></h2>
<p>Our pipeline supports three main categories of stages:</p>
<h3 id="1-compression-stages"><a class="header" href="#1-compression-stages">1. Compression Stages</a></h3>
<p>Compression stages reduce the size of your data. This is useful for:</p>
<ul>
<li>Saving disk space</li>
<li>Reducing network bandwidth</li>
<li>Faster file transfers</li>
<li>Lower storage costs</li>
</ul>
<p><strong>Available Compression Algorithms:</strong></p>
<ul>
<li>
<p><strong>Brotli</strong> - Best compression ratio, slower speed</p>
<ul>
<li>Best for: Text files, web content, logs</li>
<li>Performance: Excellent compression, moderate speed</li>
<li>Memory: Higher memory usage</li>
</ul>
</li>
<li>
<p><strong>Gzip</strong> - General-purpose compression</p>
<ul>
<li>Best for: General files, wide compatibility</li>
<li>Performance: Good balance of speed and ratio</li>
<li>Memory: Moderate memory usage</li>
</ul>
</li>
<li>
<p><strong>Zstandard (zstd)</strong> - Modern, fast compression</p>
<ul>
<li>Best for: Large files, real-time compression</li>
<li>Performance: Excellent speed and ratio</li>
<li>Memory: Efficient memory usage</li>
</ul>
</li>
<li>
<p><strong>LZ4</strong> - Extremely fast compression</p>
<ul>
<li>Best for: Real-time applications, live data streams</li>
<li>Performance: Fastest compression, moderate ratio</li>
<li>Memory: Low memory usage</li>
</ul>
</li>
</ul>
<h3 id="2-encryption-stages"><a class="header" href="#2-encryption-stages">2. Encryption Stages</a></h3>
<p>Encryption stages protect your data by making it unreadable without the correct key. This is essential for:</p>
<ul>
<li>Protecting sensitive information</li>
<li>Compliance with security regulations</li>
<li>Secure data transmission</li>
<li>Privacy protection</li>
</ul>
<p><strong>Available Encryption Algorithms:</strong></p>
<ul>
<li>
<p><strong>AES-256-GCM</strong> - Industry standard encryption</p>
<ul>
<li>Key Size: 256 bits (32 bytes)</li>
<li>Security: FIPS approved, very strong</li>
<li>Performance: Excellent with AES-NI hardware support</li>
<li>Authentication: Built-in integrity verification</li>
</ul>
</li>
<li>
<p><strong>ChaCha20-Poly1305</strong> - Modern stream cipher</p>
<ul>
<li>Key Size: 256 bits (32 bytes)</li>
<li>Security: Strong, constant-time implementation</li>
<li>Performance: Consistent across all platforms</li>
<li>Authentication: Built-in integrity verification</li>
</ul>
</li>
<li>
<p><strong>AES-128-GCM</strong> - Faster AES variant</p>
<ul>
<li>Key Size: 128 bits (16 bytes)</li>
<li>Security: Still very secure, slightly faster</li>
<li>Performance: Faster than AES-256</li>
<li>Authentication: Built-in integrity verification</li>
</ul>
</li>
</ul>
<h3 id="3-integrity-verification-stages"><a class="header" href="#3-integrity-verification-stages">3. Integrity Verification Stages</a></h3>
<p>Integrity stages ensure your data hasn't been corrupted or tampered with. They create a unique "fingerprint" of your data called a checksum or hash.</p>
<p><strong>Available Hashing Algorithms:</strong></p>
<ul>
<li>
<p><strong>SHA-256</strong> - Industry standard hashing</p>
<ul>
<li>Output: 256 bits (32 bytes)</li>
<li>Security: Cryptographically secure</li>
<li>Performance: Good balance</li>
<li>Use Case: General integrity verification</li>
</ul>
</li>
<li>
<p><strong>SHA-512</strong> - Stronger SHA variant</p>
<ul>
<li>Output: 512 bits (64 bytes)</li>
<li>Security: Stronger than SHA-256</li>
<li>Performance: Good on 64-bit systems</li>
<li>Use Case: High-security applications</li>
</ul>
</li>
<li>
<p><strong>BLAKE3</strong> - Modern, high-performance hashing</p>
<ul>
<li>Output: 256 bits (32 bytes)</li>
<li>Security: Strong security properties</li>
<li>Performance: Very fast</li>
<li>Use Case: High-performance applications</li>
</ul>
</li>
</ul>
<h2 id="stage-configuration"><a class="header" href="#stage-configuration">Stage Configuration</a></h2>
<p>Each stage has a configuration that specifies how it should process data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pipeline_domain::{PipelineStage, Algorithm};

// Example: Compression stage
let compression_stage = PipelineStage::new(
    "compress".to_string(),
    Algorithm::zstd(),
    1, // stage order
)?;

// Example: Encryption stage
let encryption_stage = PipelineStage::new(
    "encrypt".to_string(),
    Algorithm::aes_256_gcm(),
    2, // stage order
)?;

// Example: Integrity verification stage
let integrity_stage = PipelineStage::new(
    "verify".to_string(),
    Algorithm::sha256(),
    3, // stage order
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="stage-execution-order"><a class="header" href="#stage-execution-order">Stage Execution Order</a></h2>
<p>Stages execute in the order you define them. The output of one stage becomes the input to the next stage.</p>
<p><strong>Recommended Order for Processing:</strong></p>
<ol>
<li>Compress (reduce size first)</li>
<li>Encrypt (protect compressed data)</li>
<li>Verify integrity (create checksum of encrypted data)</li>
</ol>
<p><strong>For Restoration (reverse order):</strong></p>
<ol>
<li>Verify integrity (check encrypted data)</li>
<li>Decrypt (recover compressed data)</li>
<li>Decompress (restore original file)</li>
</ol>
<pre><code class="language-text">Processing Pipeline:
Input File → Compress → Encrypt → Verify → Output File

Restoration Pipeline:
Input File → Verify → Decrypt → Decompress → Output File
</code></pre>
<h2 id="combining-stages"><a class="header" href="#combining-stages">Combining Stages</a></h2>
<p>You can combine stages in different ways depending on your needs:</p>
<h3 id="maximum-security"><a class="header" href="#maximum-security">Maximum Security</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vec![
    PipelineStage::new("compress", Algorithm::brotli(), 1)?,
    PipelineStage::new("encrypt", Algorithm::aes_256_gcm(), 2)?,
    PipelineStage::new("verify", Algorithm::blake3(), 3)?,
]
<span class="boring">}</span></code></pre></pre>
<h3 id="maximum-speed"><a class="header" href="#maximum-speed">Maximum Speed</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vec![
    PipelineStage::new("compress", Algorithm::lz4(), 1)?,
    PipelineStage::new("encrypt", Algorithm::chacha20_poly1305(), 2)?,
]
<span class="boring">}</span></code></pre></pre>
<h3 id="balanced-approach"><a class="header" href="#balanced-approach">Balanced Approach</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vec![
    PipelineStage::new("compress", Algorithm::zstd(), 1)?,
    PipelineStage::new("encrypt", Algorithm::aes_256_gcm(), 2)?,
    PipelineStage::new("verify", Algorithm::sha256(), 3)?,
]
<span class="boring">}</span></code></pre></pre>
<h2 id="parallel-processing"><a class="header" href="#parallel-processing">Parallel Processing</a></h2>
<p>Stages process file chunks in parallel for better performance:</p>
<pre><code class="language-text">File Split into Chunks:
┌──────┬──────┬──────┬──────┐
│Chunk1│Chunk2│Chunk3│Chunk4│
└──┬───┴──┬───┴──┬───┴──┬───┘
   │      │      │      │
   ▼      ▼      ▼      ▼
   ┌──────┬──────┬──────┬──────┐
   │Stage1│Stage1│Stage1│Stage1│ (Parallel)
   └──┬───┴──┬───┴──┬───┴──┬───┘
      ▼      ▼      ▼      ▼
   ┌──────┬──────┬──────┬──────┐
   │Stage2│Stage2│Stage2│Stage2│ (Parallel)
   └──┬───┴──┬───┴──┬───┴──┬───┘
      │      │      │      │
      ▼      ▼      ▼      ▼
   Combined Output File
</code></pre>
<p>This parallel processing allows the pipeline to utilize multiple CPU cores for faster throughput.</p>
<h2 id="stage-validation"><a class="header" href="#stage-validation">Stage Validation</a></h2>
<p>The pipeline validates stages at creation time:</p>
<ul>
<li><strong>Algorithm compatibility</strong>: Ensures compression algorithms are only used in compression stages</li>
<li><strong>Stage order</strong>: Verifies stages have unique, sequential order numbers</li>
<li><strong>Configuration validity</strong>: Checks all stage parameters are valid</li>
<li><strong>Dependency checks</strong>: Ensures restoration pipelines match processing pipelines</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This will fail - wrong algorithm for stage type
PipelineStage::new(
    "compress",
    Algorithm::aes_256_gcm(), // Encryption algorithm!
    1
) // ❌ Error: Algorithm not compatible with stage type
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you understand pipeline stages, you can learn about:</p>
<ul>
<li><a href="fundamentals/configuration.html">Configuration</a> - How to configure pipelines and stages</li>
<li><a href="fundamentals/first-run.html">Your First Pipeline</a> - Run your first pipeline</li>
<li><a href="fundamentals/../architecture/overview.html">Architecture Overview</a> - Deeper dive into the architecture</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-basics"><a class="header" href="#configuration-basics">Configuration Basics</a></h1>
<p><strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner, Claude Code
<strong>Status:</strong> Active</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The pipeline system provides flexible configuration through command-line options, environment variables, and configuration files. This chapter covers the basics of configuring your pipelines.</p>
<h2 id="command-line-interface"><a class="header" href="#command-line-interface">Command-Line Interface</a></h2>
<p>The pipeline CLI provides several commands for managing and running pipelines.</p>
<h3 id="basic-commands"><a class="header" href="#basic-commands">Basic Commands</a></h3>
<h4 id="process-a-file"><a class="header" href="#process-a-file">Process a File</a></h4>
<pre><code class="language-bash">pipeline process \
  --input /path/to/input.txt \
  --output /path/to/output.bin \
  --pipeline my-pipeline
</code></pre>
<h4 id="create-a-pipeline"><a class="header" href="#create-a-pipeline">Create a Pipeline</a></h4>
<pre><code class="language-bash">pipeline create \
  --name my-pipeline \
  --stages compression,encryption,integrity
</code></pre>
<h4 id="list-pipelines"><a class="header" href="#list-pipelines">List Pipelines</a></h4>
<pre><code class="language-bash">pipeline list
</code></pre>
<h4 id="show-pipeline-details"><a class="header" href="#show-pipeline-details">Show Pipeline Details</a></h4>
<pre><code class="language-bash">pipeline show my-pipeline
</code></pre>
<h4 id="delete-a-pipeline"><a class="header" href="#delete-a-pipeline">Delete a Pipeline</a></h4>
<pre><code class="language-bash">pipeline delete my-pipeline --force
</code></pre>
<h3 id="performance-options"><a class="header" href="#performance-options">Performance Options</a></h3>
<h4 id="cpu-threads"><a class="header" href="#cpu-threads">CPU Threads</a></h4>
<p>Control the number of worker threads for CPU-bound operations (compression, encryption):</p>
<pre><code class="language-bash">pipeline process \
  --input file.txt \
  --output file.bin \
  --pipeline my-pipeline \
  --cpu-threads 8
</code></pre>
<p><strong>Default:</strong> Number of CPU cores - 1 (reserves one core for I/O)</p>
<p><strong>Tips:</strong></p>
<ul>
<li>Too high: CPU thrashing, context switching overhead</li>
<li>Too low: Underutilized cores, slower processing</li>
<li>Monitor CPU saturation metrics to tune</li>
</ul>
<h4 id="io-threads"><a class="header" href="#io-threads">I/O Threads</a></h4>
<p>Control the number of concurrent I/O operations:</p>
<pre><code class="language-bash">pipeline process \
  --input file.txt \
  --output file.bin \
  --pipeline my-pipeline \
  --io-threads 24
</code></pre>
<p><strong>Default:</strong> Device-specific (NVMe: 24, SSD: 12, HDD: 4)</p>
<p><strong>Storage Type Detection:</strong></p>
<pre><code class="language-bash">pipeline process \
  --input file.txt \
  --output file.bin \
  --pipeline my-pipeline \
  --storage-type nvme  # or ssd, hdd
</code></pre>
<h4 id="channel-depth"><a class="header" href="#channel-depth">Channel Depth</a></h4>
<p>Control backpressure in the pipeline stages:</p>
<pre><code class="language-bash">pipeline process \
  --input file.txt \
  --output file.bin \
  --pipeline my-pipeline \
  --channel-depth 8
</code></pre>
<p><strong>Default:</strong> 4</p>
<p><strong>Tips:</strong></p>
<ul>
<li>Lower values: Less memory, may cause pipeline stalls</li>
<li>Higher values: More buffering, higher memory usage</li>
<li>Optimal value depends on chunk processing time and I/O latency</li>
</ul>
<h4 id="chunk-size"><a class="header" href="#chunk-size">Chunk Size</a></h4>
<p>Configure the size of file chunks for parallel processing:</p>
<pre><code class="language-bash">pipeline process \
  --input file.txt \
  --output file.bin \
  --pipeline my-pipeline \
  --chunk-size-mb 10
</code></pre>
<p><strong>Default:</strong> Automatically determined based on file size and available resources</p>
<h3 id="global-options"><a class="header" href="#global-options">Global Options</a></h3>
<h4 id="verbose-logging"><a class="header" href="#verbose-logging">Verbose Logging</a></h4>
<p>Enable detailed logging output:</p>
<pre><code class="language-bash">pipeline --verbose process \
  --input file.txt \
  --output file.bin \
  --pipeline my-pipeline
</code></pre>
<h4 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h4>
<p>Use a custom configuration file:</p>
<pre><code class="language-bash">pipeline --config /path/to/config.toml process \
  --input file.txt \
  --output file.bin \
  --pipeline my-pipeline
</code></pre>
<h2 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h2>
<p>Configuration files use TOML format and allow you to save pipeline settings for reuse.</p>
<h3 id="basic-configuration"><a class="header" href="#basic-configuration">Basic Configuration</a></h3>
<pre><code class="language-toml">[pipeline]
name = "my-pipeline"
stages = ["compression", "encryption", "integrity"]

[performance]
cpu_threads = 8
io_threads = 24
channel_depth = 4

[processing]
chunk_size_mb = 10
</code></pre>
<h3 id="algorithm-configuration"><a class="header" href="#algorithm-configuration">Algorithm Configuration</a></h3>
<pre><code class="language-toml">[stages.compression]
algorithm = "zstd"

[stages.encryption]
algorithm = "aes-256-gcm"
key_file = "/path/to/keyfile"

[stages.integrity]
algorithm = "sha256"
</code></pre>
<h3 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h3>
<pre><code class="language-toml"># Pipeline configuration example
[pipeline]
name = "secure-archival"
description = "High compression with encryption for archival"

[stages.compression]
algorithm = "brotli"
level = 11  # Maximum compression

[stages.encryption]
algorithm = "aes-256-gcm"
key_derivation = "argon2"

[stages.integrity]
algorithm = "blake3"

[performance]
cpu_threads = 16
io_threads = 24
channel_depth = 8
storage_type = "nvme"

[processing]
chunk_size_mb = 64
parallel_workers = 16
</code></pre>
<h3 id="using-configuration-files"><a class="header" href="#using-configuration-files">Using Configuration Files</a></h3>
<pre><code class="language-bash"># Use a configuration file
pipeline --config secure-archival.toml process \
  --input large-dataset.tar \
  --output large-dataset.bin

# Override configuration file settings
pipeline --config secure-archival.toml \
  --cpu-threads 8 \
  process --input file.txt --output file.bin
</code></pre>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>Environment variables provide another way to configure the pipeline:</p>
<pre><code class="language-bash"># Set performance defaults
export PIPELINE_CPU_THREADS=8
export PIPELINE_IO_THREADS=24
export PIPELINE_CHANNEL_DEPTH=8

# Set default chunk size
export PIPELINE_CHUNK_SIZE_MB=10

# Enable verbose logging
export PIPELINE_VERBOSE=true

# Run pipeline
pipeline process --input file.txt --output file.bin --pipeline my-pipeline
</code></pre>
<h2 id="configuration-priority"><a class="header" href="#configuration-priority">Configuration Priority</a></h2>
<p>When the same setting is configured in multiple places, the following priority applies (highest to lowest):</p>
<ol>
<li><strong>Command-line arguments</strong> - Explicit flags like <code>--cpu-threads</code></li>
<li><strong>Environment variables</strong> - <code>PIPELINE_*</code> variables</li>
<li><strong>Configuration file</strong> - Settings from <code>--config</code> file</li>
<li><strong>Default values</strong> - Built-in intelligent defaults</li>
</ol>
<p>Example:</p>
<pre><code class="language-bash"># Config file says cpu_threads = 8
# Environment says PIPELINE_CPU_THREADS=12
# Command line says --cpu-threads=16

# Result: Uses 16 (command-line wins)
</code></pre>
<h2 id="performance-tuning-guidelines"><a class="header" href="#performance-tuning-guidelines">Performance Tuning Guidelines</a></h2>
<h3 id="for-maximum-speed"><a class="header" href="#for-maximum-speed">For Maximum Speed</a></h3>
<ul>
<li>Use LZ4 compression</li>
<li>Use ChaCha20-Poly1305 encryption</li>
<li>Increase CPU threads to match cores</li>
<li>Use large chunks (32-64 MB)</li>
<li>Higher channel depth (8-16)</li>
</ul>
<pre><code class="language-bash">pipeline process \
  --input file.txt \
  --output file.bin \
  --pipeline speed-pipeline \
  --cpu-threads 16 \
  --chunk-size-mb 64 \
  --channel-depth 16
</code></pre>
<h3 id="for-maximum-compression"><a class="header" href="#for-maximum-compression">For Maximum Compression</a></h3>
<ul>
<li>Use Brotli compression</li>
<li>Smaller chunks for better compression ratio</li>
<li>More CPU threads for parallel compression</li>
</ul>
<pre><code class="language-bash">pipeline process \
  --input file.txt \
  --output file.bin \
  --pipeline compression-pipeline \
  --cpu-threads 16 \
  --chunk-size-mb 4
</code></pre>
<h3 id="for-resource-constrained-systems"><a class="header" href="#for-resource-constrained-systems">For Resource-Constrained Systems</a></h3>
<ul>
<li>Reduce CPU and I/O threads</li>
<li>Smaller chunks</li>
<li>Lower channel depth</li>
</ul>
<pre><code class="language-bash">pipeline process \
  --input file.txt \
  --output file.bin \
  --pipeline minimal-pipeline \
  --cpu-threads 2 \
  --io-threads 4 \
  --chunk-size-mb 2 \
  --channel-depth 2
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Now that you understand configuration, you're ready to:</p>
<ul>
<li><a href="fundamentals/first-run.html">Run Your First Pipeline</a> - Step-by-step tutorial</li>
<li><a href="fundamentals/stages.html">Learn About Stages</a> - Deep dive into pipeline stages</li>
<li><a href="fundamentals/../architecture/overview.html">Explore Architecture</a> - Understand the system design</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-your-first-pipeline"><a class="header" href="#running-your-first-pipeline">Running Your First Pipeline</a></h1>
<p><strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner, Claude Code
<strong>Status:</strong> Active</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before running your first pipeline, ensure you have:</p>
<ul>
<li>
<p><strong>Pipeline binary</strong> - Built and available in your PATH</p>
<pre><code class="language-bash">cargo build --release
cp target/release/pipeline /usr/local/bin/  # or add to PATH
</code></pre>
</li>
<li>
<p><strong>Test file</strong> - A sample file to process</p>
<pre><code class="language-bash">echo "Hello, Pipeline World!" &gt; test.txt
</code></pre>
</li>
<li>
<p><strong>Permissions</strong> - Read/write access to input and output directories</p>
</li>
</ul>
<h2 id="quick-start-5-minutes"><a class="header" href="#quick-start-5-minutes">Quick Start (5 minutes)</a></h2>
<p>Let's run a simple compression and encryption pipeline in 3 steps:</p>
<h3 id="step-1-create-a-pipeline"><a class="header" href="#step-1-create-a-pipeline">Step 1: Create a Pipeline</a></h3>
<pre><code class="language-bash">pipeline create \
  --name my-first-pipeline \
  --stages compression,encryption
</code></pre>
<p>You should see output like:</p>
<pre><code>✓ Created pipeline: my-first-pipeline
  Stages: compression (zstd), encryption (aes-256-gcm)
</code></pre>
<h3 id="step-2-process-a-file"><a class="header" href="#step-2-process-a-file">Step 2: Process a File</a></h3>
<pre><code class="language-bash">pipeline process \
  --input test.txt \
  --output test.bin \
  --pipeline my-first-pipeline
</code></pre>
<p>You should see progress output:</p>
<pre><code>Processing: test.txt
Pipeline: my-first-pipeline
  Stage 1/2: Compression (zstd)... ✓
  Stage 2/2: Encryption (aes-256-gcm)... ✓
Output: test.bin (24 bytes)
Time: 0.05s
</code></pre>
<h3 id="step-3-restore-the-file"><a class="header" href="#step-3-restore-the-file">Step 3: Restore the File</a></h3>
<pre><code class="language-bash">pipeline restore \
  --input test.bin \
  --output restored.txt
</code></pre>
<p>Verify the restoration:</p>
<pre><code class="language-bash">diff test.txt restored.txt
# No output = files are identical ✓
</code></pre>
<h2 id="detailed-walkthrough"><a class="header" href="#detailed-walkthrough">Detailed Walkthrough</a></h2>
<p>Let's explore each step in more detail.</p>
<h3 id="creating-pipelines"><a class="header" href="#creating-pipelines">Creating Pipelines</a></h3>
<h4 id="basic-pipeline"><a class="header" href="#basic-pipeline">Basic Pipeline</a></h4>
<pre><code class="language-bash">pipeline create \
  --name basic \
  --stages compression
</code></pre>
<p>This creates a simple compression-only pipeline using default settings (zstd compression).</p>
<h4 id="secure-pipeline"><a class="header" href="#secure-pipeline">Secure Pipeline</a></h4>
<pre><code class="language-bash">pipeline create \
  --name secure \
  --stages compression,encryption,integrity
</code></pre>
<p>This creates a complete security pipeline with:</p>
<ul>
<li>Compression (reduces size)</li>
<li>Encryption (protects data)</li>
<li>Integrity verification (detects tampering)</li>
</ul>
<h4 id="save-pipeline-configuration"><a class="header" href="#save-pipeline-configuration">Save Pipeline Configuration</a></h4>
<pre><code class="language-bash">pipeline create \
  --name archival \
  --stages compression,encryption \
  --output archival-pipeline.toml
</code></pre>
<p>This saves the pipeline configuration to a file for reuse.</p>
<h3 id="processing-files"><a class="header" href="#processing-files">Processing Files</a></h3>
<h4 id="basic-processing"><a class="header" href="#basic-processing">Basic Processing</a></h4>
<pre><code class="language-bash"># Process a file
pipeline process \
  --input large-file.log \
  --output large-file.bin \
  --pipeline secure
</code></pre>
<h4 id="with-performance-options"><a class="header" href="#with-performance-options">With Performance Options</a></h4>
<pre><code class="language-bash"># Process with custom settings
pipeline process \
  --input large-file.log \
  --output large-file.bin \
  --pipeline secure \
  --cpu-threads 8 \
  --chunk-size-mb 32
</code></pre>
<h4 id="with-verbose-logging"><a class="header" href="#with-verbose-logging">With Verbose Logging</a></h4>
<pre><code class="language-bash"># See detailed progress
pipeline --verbose process \
  --input large-file.log \
  --output large-file.bin \
  --pipeline secure
</code></pre>
<h3 id="restoring-files"><a class="header" href="#restoring-files">Restoring Files</a></h3>
<p>The pipeline automatically detects the processing stages from the output file's metadata:</p>
<pre><code class="language-bash"># Restore automatically reverses all stages
pipeline restore \
  --input large-file.bin \
  --output restored-file.log
</code></pre>
<p>The system will:</p>
<ol>
<li>Read metadata from the file header</li>
<li>Apply stages in reverse order</li>
<li>Verify integrity if available</li>
<li>Restore original file</li>
</ol>
<h3 id="managing-pipelines"><a class="header" href="#managing-pipelines">Managing Pipelines</a></h3>
<h4 id="list-all-pipelines"><a class="header" href="#list-all-pipelines">List All Pipelines</a></h4>
<pre><code class="language-bash">pipeline list
</code></pre>
<p>Output:</p>
<pre><code>Available Pipelines:
  - my-first-pipeline (compression, encryption)
  - secure (compression, encryption, integrity)
  - archival (compression, encryption)
</code></pre>
<h4 id="show-pipeline-details-1"><a class="header" href="#show-pipeline-details-1">Show Pipeline Details</a></h4>
<pre><code class="language-bash">pipeline show secure
</code></pre>
<p>Output:</p>
<pre><code>Pipeline: secure
  Stage 1: Compression (zstd)
  Stage 2: Encryption (aes-256-gcm)
  Stage 3: Integrity (sha256)
Created: 2025-01-04 10:30:00
</code></pre>
<h4 id="delete-a-pipeline-1"><a class="header" href="#delete-a-pipeline-1">Delete a Pipeline</a></h4>
<pre><code class="language-bash">pipeline delete my-first-pipeline --force
</code></pre>
<h2 id="understanding-output"><a class="header" href="#understanding-output">Understanding Output</a></h2>
<h3 id="successful-processing"><a class="header" href="#successful-processing">Successful Processing</a></h3>
<p>When processing completes successfully:</p>
<pre><code>Processing: test.txt
Pipeline: my-first-pipeline
  Stage 1/2: Compression (zstd)... ✓
  Stage 2/2: Encryption (aes-256-gcm)... ✓

Statistics:
  Input size:  1,024 KB
  Output size: 512 KB
  Compression ratio: 50%
  Processing time: 0.15s
  Throughput: 6.8 MB/s

Output: test.bin
</code></pre>
<h3 id="performance-metrics"><a class="header" href="#performance-metrics">Performance Metrics</a></h3>
<p>With <code>--verbose</code> flag, you'll see detailed metrics:</p>
<pre><code>Pipeline Execution Metrics:
  Chunks processed: 64
  Parallel workers: 8
  Average chunk time: 2.3ms
  CPU utilization: 87%
  I/O wait: 3%

Stage Breakdown:
  Compression: 0.08s (53%)
  Encryption: 0.05s (33%)
  I/O: 0.02s (14%)
</code></pre>
<h3 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h3>
<h4 id="file-not-found"><a class="header" href="#file-not-found">File Not Found</a></h4>
<pre><code>Error: Input file not found: test.txt
  Check the file path and try again
</code></pre>
<h4 id="permission-denied"><a class="header" href="#permission-denied">Permission Denied</a></h4>
<pre><code>Error: Permission denied: /protected/output.bin
  Ensure you have write access to the output directory
</code></pre>
<h4 id="invalid-pipeline"><a class="header" href="#invalid-pipeline">Invalid Pipeline</a></h4>
<pre><code>Error: Pipeline not found: nonexistent
  Use 'pipeline list' to see available pipelines
</code></pre>
<h2 id="common-scenarios"><a class="header" href="#common-scenarios">Common Scenarios</a></h2>
<h3 id="scenario-1-compress-large-log-files"><a class="header" href="#scenario-1-compress-large-log-files">Scenario 1: Compress Large Log Files</a></h3>
<pre><code class="language-bash"># Create compression pipeline
pipeline create --name logs --stages compression

# Process log files
pipeline process \
  --input app.log \
  --output app.log.bin \
  --pipeline logs \
  --chunk-size-mb 64

# Compression ratio is typically 70-90% for text logs
</code></pre>
<h3 id="scenario-2-secure-sensitive-files"><a class="header" href="#scenario-2-secure-sensitive-files">Scenario 2: Secure Sensitive Files</a></h3>
<pre><code class="language-bash"># Create secure pipeline with all protections
pipeline create --name sensitive --stages compression,encryption,integrity

# Process sensitive file
pipeline process \
  --input customer-data.csv \
  --output customer-data.bin \
  --pipeline sensitive

# File is now compressed, encrypted, and tamper-evident
</code></pre>
<h3 id="scenario-3-high-performance-batch-processing"><a class="header" href="#scenario-3-high-performance-batch-processing">Scenario 3: High-Performance Batch Processing</a></h3>
<pre><code class="language-bash"># Process multiple files with optimized settings
for file in data/*.csv; do
  pipeline process \
    --input "$file" \
    --output "processed/$(basename $file).bin" \
    --pipeline fast \
    --cpu-threads 16 \
    --chunk-size-mb 128 \
    --channel-depth 16
done
</code></pre>
<h3 id="scenario-4-restore-and-verify"><a class="header" href="#scenario-4-restore-and-verify">Scenario 4: Restore and Verify</a></h3>
<pre><code class="language-bash"># Restore file
pipeline restore \
  --input customer-data.bin \
  --output customer-data-restored.csv

# Verify restoration
sha256sum customer-data.csv customer-data-restored.csv
# Both checksums should match
</code></pre>
<h2 id="testing-your-pipeline"><a class="header" href="#testing-your-pipeline">Testing Your Pipeline</a></h2>
<h3 id="create-test-data"><a class="header" href="#create-test-data">Create Test Data</a></h3>
<pre><code class="language-bash"># Create a test file
dd if=/dev/urandom of=test-10mb.bin bs=1M count=10

# Calculate original checksum
sha256sum test-10mb.bin &gt; original.sha256
</code></pre>
<h3 id="process-and-restore"><a class="header" href="#process-and-restore">Process and Restore</a></h3>
<pre><code class="language-bash"># Process the file
pipeline process \
  --input test-10mb.bin \
  --output test-10mb.processed \
  --pipeline my-first-pipeline

# Restore the file
pipeline restore \
  --input test-10mb.processed \
  --output test-10mb.restored
</code></pre>
<h3 id="verify-integrity"><a class="header" href="#verify-integrity">Verify Integrity</a></h3>
<pre><code class="language-bash"># Verify restored file matches original
sha256sum -c original.sha256
# Should output: test-10mb.bin: OK
</code></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Congratulations! You've run your first pipeline. Now you can:</p>
<ul>
<li>
<p><strong>Explore Advanced Features</strong></p>
<ul>
<li><a href="fundamentals/../architecture/overview.html">Architecture Overview</a> - Understand the system design</li>
<li><a href="fundamentals/../implementation/compression.html">Implementation Details</a> - Learn about algorithms</li>
<li><a href="fundamentals/../advanced/performance.html">Performance Tuning</a> - Optimize for your use case</li>
</ul>
</li>
<li>
<p><strong>Learn More About Configuration</strong></p>
<ul>
<li><a href="fundamentals/configuration.html">Configuration Guide</a> - Detailed configuration options</li>
<li><a href="fundamentals/stages.html">Stage Types</a> - Available processing stages</li>
</ul>
</li>
<li>
<p><strong>Build Custom Pipelines</strong></p>
<ul>
<li>Experiment with different stage combinations</li>
<li>Test different algorithms for your workload</li>
<li>Benchmark performance with your data</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>High-level architectural overview of the pipeline system.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>The Optimized Adaptive Pipeline is built on three foundational architectural patterns:</p>
<ol>
<li><strong>Clean Architecture</strong> - Organizing code by dependency direction</li>
<li><strong>Domain-Driven Design (DDD)</strong> - Modeling the business domain</li>
<li><strong>Hexagonal Architecture</strong> - Isolating business logic from infrastructure</li>
</ol>
<p>These patterns work together to create a maintainable, testable, and flexible system.</p>
<h2 id="layered-architecture"><a class="header" href="#layered-architecture">Layered Architecture</a></h2>
<p>The pipeline follows a strict layered architecture where dependencies flow inward:</p>
<p><img src="architecture/../diagrams/layered-architecture.svg" alt="Layered Architecture" /></p>
<h3 id="layer-overview"><a class="header" href="#layer-overview">Layer Overview</a></h3>
<p><strong>Presentation Layer</strong> (Outermost)</p>
<ul>
<li>CLI interface for user interaction</li>
<li>Configuration management</li>
<li>Request/response handling</li>
</ul>
<p><strong>Application Layer</strong></p>
<ul>
<li>Use cases and application services</li>
<li>Pipeline orchestration</li>
<li>File processing coordination</li>
</ul>
<p><strong>Domain Layer</strong> (Core)</p>
<ul>
<li>Business logic and rules</li>
<li>Entities (Pipeline, PipelineStage)</li>
<li>Value objects (FilePath, FileSize, Algorithm)</li>
<li>Domain services</li>
</ul>
<p><strong>Infrastructure Layer</strong> (Outermost)</p>
<ul>
<li>Database implementations (SQLite)</li>
<li>File system operations</li>
<li>External system adapters</li>
<li>Metrics collection</li>
</ul>
<h2 id="clean-architecture"><a class="header" href="#clean-architecture">Clean Architecture</a></h2>
<p>Clean Architecture ensures that business logic doesn't depend on implementation details:</p>
<p><img src="architecture/../diagrams/dependency-flow.svg" alt="Dependency Flow" /></p>
<h3 id="key-principles"><a class="header" href="#key-principles">Key Principles</a></h3>
<p><strong>Dependency Rule</strong>: Source code dependencies point only inward, toward higher-level policies.</p>
<ul>
<li><strong>High-level policy</strong> (Application layer) defines what the system does</li>
<li><strong>Abstractions</strong> (Traits) define how components interact</li>
<li><strong>Low-level details</strong> (Infrastructure) implements the abstractions</li>
</ul>
<p>This means:</p>
<ul>
<li>Domain layer has <strong>zero external dependencies</strong></li>
<li>Application layer depends only on domain traits</li>
<li>Infrastructure implements domain interfaces</li>
</ul>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<p>✅ <strong>Testability</strong>: Business logic can be tested without database or file system
✅ <strong>Flexibility</strong>: Swap implementations (SQLite → PostgreSQL) without changing business logic
✅ <strong>Independence</strong>: Domain logic doesn't know about HTTP, databases, or file formats</p>
<h2 id="hexagonal-architecture-ports-and-adapters"><a class="header" href="#hexagonal-architecture-ports-and-adapters">Hexagonal Architecture (Ports and Adapters)</a></h2>
<p>The pipeline uses Hexagonal Architecture to isolate the core business logic:</p>
<p><img src="architecture/../diagrams/hexagonal-architecture.svg" alt="Hexagonal Architecture" /></p>
<h3 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h3>
<p><strong>Application Core</strong></p>
<ul>
<li>Domain model (entities, value objects)</li>
<li>Business logic (pipeline orchestration)</li>
<li>Ports (trait definitions)</li>
</ul>
<p><strong>Primary Adapters</strong> (Driving)</p>
<ul>
<li>CLI adapter - drives the application</li>
<li>HTTP adapter - future API endpoints</li>
</ul>
<p><strong>Secondary Adapters</strong> (Driven)</p>
<ul>
<li>SQLite repository adapter - driven by the application</li>
<li>File system adapter - driven by the application</li>
<li>Prometheus metrics adapter - driven by the application</li>
</ul>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>User</strong> interacts with <strong>Primary Adapter</strong> (CLI)</li>
<li><strong>Primary Adapter</strong> calls <strong>Application Core</strong> through defined ports</li>
<li><strong>Application Core</strong> uses <strong>Ports</strong> (traits) to interact with infrastructure</li>
<li><strong>Secondary Adapters</strong> implement these ports</li>
<li><strong>Adapters</strong> connect to external systems (database, files)</li>
</ol>
<p><strong>Example Flow</strong>:</p>
<pre><code>CLI → Pipeline Service → Repository Port → SQLite Adapter → Database
</code></pre>
<p>The application core never knows it's using SQLite - it only knows the <code>Repository</code> trait.</p>
<h2 id="architecture-integration"><a class="header" href="#architecture-integration">Architecture Integration</a></h2>
<p>These three patterns work together:</p>
<pre><code class="language-text">Clean Architecture:    Layers with dependency direction
Domain-Driven Design:  Business modeling within layers
Hexagonal Architecture: Ports/Adapters at layer boundaries
</code></pre>
<p><strong>In Practice</strong>:</p>
<ul>
<li><strong>Domain layer</strong> contains pure business logic (DDD entities)</li>
<li><strong>Application layer</strong> orchestrates use cases (Clean Architecture)</li>
<li><strong>Infrastructure</strong> implements ports (Hexagonal Architecture)</li>
</ul>
<p>This combination provides:</p>
<ul>
<li>Clear separation of concerns</li>
<li>Testable business logic</li>
<li>Flexible infrastructure</li>
<li>Maintainable codebase</li>
</ul>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>Continue to:</p>
<ul>
<li><a href="architecture/layers.html">Layered Architecture Details</a> - Deep dive into each layer</li>
<li><a href="architecture/domain-model.html">Domain Model</a> - Understanding entities and value objects</li>
<li><a href="architecture/patterns.html">Design Patterns</a> - Patterns used throughout the codebase</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layered-architecture-1"><a class="header" href="#layered-architecture-1">Layered Architecture</a></h1>
<p><strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner, Claude Code
<strong>Status:</strong> Active</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The pipeline system is organized into four distinct layers, each with specific responsibilities and clear boundaries. This layered architecture provides separation of concerns, testability, and maintainability.</p>
<p><img src="architecture/../diagrams/layered-architecture.svg" alt="Layered Architecture" /></p>
<h2 id="the-four-layers"><a class="header" href="#the-four-layers">The Four Layers</a></h2>
<pre><code class="language-text">┌─────────────────────────────────────────┐
│         Presentation Layer              │  ← User interface (CLI)
│  - CLI commands                         │
│  - User interaction                     │
└─────────────────┬───────────────────────┘
                  │ depends on
┌─────────────────▼───────────────────────┐
│         Application Layer               │  ← Use cases, orchestration
│  - Use cases                            │
│  - Application services                 │
│  - Commands/Queries                     │
└─────────────────┬───────────────────────┘
                  │ depends on
┌─────────────────▼───────────────────────┐
│           Domain Layer                  │  ← Core business logic
│  - Entities                             │
│  - Value objects                        │
│  - Domain services (interfaces)         │
│  - Business rules                       │
└─────────────────△───────────────────────┘
                  │ implements interfaces
┌─────────────────┴───────────────────────┐
│        Infrastructure Layer             │  ← External dependencies
│  - Database repositories                │
│  - File I/O                             │
│  - External services                    │
│  - Encryption/Compression               │
└─────────────────────────────────────────┘
</code></pre>
<h2 id="dependency-rule"><a class="header" href="#dependency-rule">Dependency Rule</a></h2>
<p>The <strong>dependency rule</strong> is the most important principle in layered architecture:</p>
<blockquote>
<p><strong>Dependencies flow inward toward the domain layer.</strong></p>
</blockquote>
<ul>
<li>Presentation depends on Application</li>
<li>Application depends on Domain</li>
<li>Infrastructure depends on Domain (via interfaces)</li>
<li><strong>Domain depends on nothing</strong> (pure business logic)</li>
</ul>
<p>This means:</p>
<ul>
<li>✅ Application can use Domain types</li>
<li>✅ Infrastructure implements Domain interfaces</li>
<li>❌ Domain cannot use Application types</li>
<li>❌ Domain cannot use Infrastructure types</li>
</ul>
<h2 id="domain-layer"><a class="header" href="#domain-layer">Domain Layer</a></h2>
<h3 id="purpose"><a class="header" href="#purpose">Purpose</a></h3>
<p>The domain layer contains the <strong>core business logic</strong> and is the heart of the application. It's completely independent of external concerns like databases, user interfaces, or frameworks.</p>
<h3 id="responsibilities"><a class="header" href="#responsibilities">Responsibilities</a></h3>
<ul>
<li>Define business entities and value objects</li>
<li>Enforce business rules and invariants</li>
<li>Provide domain service interfaces</li>
<li>Emit domain events</li>
<li>Define repository interfaces</li>
</ul>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<pre><code>pipeline-domain/
├── entities/
│   ├── pipeline.rs           # Pipeline entity
│   ├── pipeline_stage.rs     # Stage entity
│   ├── processing_context.rs # Processing state
│   └── security_context.rs   # Security management
├── value_objects/
│   ├── algorithm.rs          # Algorithm value object
│   ├── chunk_size.rs         # Chunk size validation
│   ├── file_path.rs          # Type-safe paths
│   └── pipeline_id.rs        # Type-safe IDs
├── services/
│   ├── compression_service.rs    # Compression interface
│   ├── encryption_service.rs     # Encryption interface
│   └── checksum_service.rs       # Checksum interface
├── repositories/
│   └── pipeline_repository.rs    # Repository interface
├── events/
│   └── domain_events.rs      # Business events
└── error/
    └── pipeline_error.rs     # Domain errors
</code></pre>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain layer - pure business logic
pub struct Pipeline {
    id: PipelineId,
    name: String,
    stages: Vec&lt;PipelineStage&gt;,
    // ... no database or UI dependencies
}

impl Pipeline {
    pub fn new(name: String, stages: Vec&lt;PipelineStage&gt;) -&gt; Result&lt;Self, PipelineError&gt; {
        // Business rule: must have at least one stage
        if stages.is_empty() {
            return Err(PipelineError::InvalidConfiguration(
                "Pipeline must have at least one stage".to_string()
            ));
        }

        // Create pipeline with validated business rules
        Ok(Self {
            id: PipelineId::new(),
            name,
            stages,
            // ...
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-characteristics"><a class="header" href="#key-characteristics">Key Characteristics</a></h3>
<ul>
<li><strong>No external dependencies</strong> - Only standard library and domain types</li>
<li><strong>Highly testable</strong> - Can test without databases or files</li>
<li><strong>Portable</strong> - Can be used in any context (web, CLI, embedded)</li>
<li><strong>Stable</strong> - Rarely changes except for business requirement changes</li>
</ul>
<h2 id="application-layer"><a class="header" href="#application-layer">Application Layer</a></h2>
<h3 id="purpose-1"><a class="header" href="#purpose-1">Purpose</a></h3>
<p>The application layer orchestrates the execution of business use cases. It coordinates domain objects and delegates to domain services to accomplish specific tasks.</p>
<h3 id="responsibilities-1"><a class="header" href="#responsibilities-1">Responsibilities</a></h3>
<ul>
<li>Implement use cases (user actions)</li>
<li>Coordinate domain objects</li>
<li>Manage transactions</li>
<li>Handle application-specific workflows</li>
<li>Emit application events</li>
</ul>
<h3 id="structure-1"><a class="header" href="#structure-1">Structure</a></h3>
<pre><code>pipeline/src/application/
├── use_cases/
│   ├── process_file.rs       # File processing use case
│   ├── restore_file.rs       # File restoration use case
│   └── create_pipeline.rs    # Pipeline creation
├── services/
│   ├── pipeline_service.rs   # Pipeline orchestration
│   ├── file_processor_service.rs  # File processing
│   └── transactional_chunk_writer.rs  # Chunk writing
├── commands/
│   └── commands.rs           # CQRS commands
└── utilities/
    └── generic_service_base.rs  # Service helpers
</code></pre>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Application layer - orchestrates domain objects
pub struct FileProcessorService {
    pipeline_repo: Arc&lt;dyn PipelineRepository&gt;,
    compression: Arc&lt;dyn CompressionService&gt;,
    encryption: Arc&lt;dyn EncryptionService&gt;,
}

impl FileProcessorService {
    pub async fn process_file(
        &amp;self,
        pipeline_id: &amp;PipelineId,
        input_path: &amp;FilePath,
        output_path: &amp;FilePath,
    ) -&gt; Result&lt;ProcessingMetrics, PipelineError&gt; {
        // 1. Fetch pipeline from repository
        let pipeline = self.pipeline_repo
            .find_by_id(pipeline_id)
            .await?
            .ok_or(PipelineError::NotFound)?;

        // 2. Create processing context
        let context = ProcessingContext::new(
            pipeline.id().clone(),
            input_path.clone(),
            output_path.clone(),
        );

        // 3. Process each stage
        for stage in pipeline.stages() {
            match stage.stage_type() {
                StageType::Compression =&gt; {
                    self.compression.compress(/* ... */).await?;
                }
                StageType::Encryption =&gt; {
                    self.encryption.encrypt(/* ... */).await?;
                }
                // ... more stages
            }
        }

        // 4. Return metrics
        Ok(context.metrics().clone())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-characteristics-1"><a class="header" href="#key-characteristics-1">Key Characteristics</a></h3>
<ul>
<li><strong>Thin layer</strong> - Delegates to domain for business logic</li>
<li><strong>Workflow coordination</strong> - Orchestrates multiple domain operations</li>
<li><strong>Transaction management</strong> - Ensures atomic operations</li>
<li><strong>No business logic</strong> - Business rules belong in domain layer</li>
</ul>
<h2 id="infrastructure-layer"><a class="header" href="#infrastructure-layer">Infrastructure Layer</a></h2>
<h3 id="purpose-2"><a class="header" href="#purpose-2">Purpose</a></h3>
<p>The infrastructure layer provides concrete implementations of interfaces defined in the domain layer. It handles all external concerns like databases, file systems, and third-party services.</p>
<h3 id="responsibilities-2"><a class="header" href="#responsibilities-2">Responsibilities</a></h3>
<ul>
<li>Implement repository interfaces</li>
<li>Provide database access</li>
<li>Handle file I/O operations</li>
<li>Implement compression/encryption services</li>
<li>Integrate with external systems</li>
<li>Provide logging and metrics</li>
</ul>
<h3 id="structure-2"><a class="header" href="#structure-2">Structure</a></h3>
<pre><code>pipeline/src/infrastructure/
├── repositories/
│   ├── sqlite_pipeline_repository.rs  # SQLite implementation
│   └── stage_executor.rs              # Stage execution
├── adapters/
│   ├── compression_service_adapter.rs # Compression implementation
│   ├── encryption_service_adapter.rs  # Encryption implementation
│   └── repositories/
│       └── sqlite_repository_adapter.rs  # Repository adapter
├── services/
│   └── binary_format_service.rs       # File format handling
├── metrics/
│   ├── metrics_service.rs             # Prometheus metrics
│   └── metrics_observer.rs            # Metrics collection
├── logging/
│   └── observability_service.rs       # Logging setup
└── config/
    └── config_service.rs              # Configuration management
</code></pre>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Infrastructure layer - implements domain interfaces
pub struct SQLitePipelineRepository {
    pool: SqlitePool,
}

#[async_trait]
impl PipelineRepository for SQLitePipelineRepository {
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt; {
        // Database-specific code
        let row = sqlx::query_as::&lt;_, PipelineRow&gt;(
            "SELECT * FROM pipelines WHERE id = ?"
        )
        .bind(id.to_string())
        .fetch_optional(&amp;self.pool)
        .await
        .map_err(|e| PipelineError::RepositoryError(e.to_string()))?;

        // Map database row to domain entity
        row.map(|r| self.to_domain_entity(r)).transpose()
    }

    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt; {
        // Convert domain entity to database row
        let row = self.to_persistence_model(pipeline);

        // Insert into database
        sqlx::query(
            "INSERT INTO pipelines (id, name, ...) VALUES (?, ?, ...)"
        )
        .bind(&amp;row.id)
        .bind(&amp;row.name)
        .execute(&amp;self.pool)
        .await
        .map_err(|e| PipelineError::RepositoryError(e.to_string()))?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-characteristics-2"><a class="header" href="#key-characteristics-2">Key Characteristics</a></h3>
<ul>
<li><strong>Implements domain interfaces</strong> - Provides concrete implementations</li>
<li><strong>Database access</strong> - Handles all persistence operations</li>
<li><strong>External integrations</strong> - Communicates with external systems</li>
<li><strong>Technology-specific</strong> - Uses specific libraries and frameworks</li>
<li><strong>Replaceable</strong> - Can swap implementations without changing domain</li>
</ul>
<h2 id="presentation-layer"><a class="header" href="#presentation-layer">Presentation Layer</a></h2>
<h3 id="purpose-3"><a class="header" href="#purpose-3">Purpose</a></h3>
<p>The presentation layer handles user interaction and input/output. It translates user commands into application use cases and presents results back to the user.</p>
<h3 id="responsibilities-3"><a class="header" href="#responsibilities-3">Responsibilities</a></h3>
<ul>
<li>Parse and validate user input</li>
<li>Execute application use cases</li>
<li>Format and display output</li>
<li>Handle user interaction</li>
<li>Map errors to user-friendly messages</li>
</ul>
<h3 id="structure-3"><a class="header" href="#structure-3">Structure</a></h3>
<pre><code>pipeline/src/presentation/
├── mod.rs                    # Presentation module
└── (CLI is in main.rs)
</code></pre>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">// Presentation layer - CLI interaction
#[tokio::main]
async fn main() -&gt; std::process::ExitCode {
    // 1. Parse CLI arguments
    let cli = bootstrap::bootstrap_cli()
        .unwrap_or_else(|e| {
            eprintln!("Error: {}", e);
            std::process::exit(65);
        });

    // 2. Set up dependencies (infrastructure)
    let db_pool = create_database_pool().await?;
    let pipeline_repo = Arc::new(SQLitePipelineRepository::new(db_pool));
    let compression = Arc::new(CompressionServiceAdapter::new());
    let file_processor = FileProcessorService::new(pipeline_repo, compression);

    // 3. Execute use case based on command
    let result = match cli.command {
        Commands::Process { input, output, pipeline } =&gt; {
            // Call application service
            file_processor.process_file(&amp;pipeline, &amp;input, &amp;output).await
        }
        Commands::Create { name, stages } =&gt; {
            // Call application service
            create_pipeline_service.create(&amp;name, stages).await
        }
        // ... more commands
    };

    // 4. Handle result and display to user
    match result {
        Ok(_) =&gt; {
            println!("✓ Processing completed successfully");
            ExitCode::SUCCESS
        }
        Err(e) =&gt; {
            eprintln!("✗ Error: {}", e);
            ExitCode::FAILURE
        }
    }
}</code></pre></pre>
<h3 id="key-characteristics-3"><a class="header" href="#key-characteristics-3">Key Characteristics</a></h3>
<ul>
<li><strong>Thin layer</strong> - Minimal logic, delegates to application</li>
<li><strong>User-facing</strong> - Handles all user interaction</li>
<li><strong>Input validation</strong> - Validates user input before processing</li>
<li><strong>Error formatting</strong> - Converts technical errors to user-friendly messages</li>
</ul>
<h2 id="layer-interactions"><a class="header" href="#layer-interactions">Layer Interactions</a></h2>
<h3 id="example-processing-a-file"><a class="header" href="#example-processing-a-file">Example: Processing a File</a></h3>
<p>Here's how the layers work together to process a file:</p>
<pre><code class="language-text">1. Presentation Layer (CLI)
   ↓ User runs: pipeline process --input file.txt --output file.bin --pipeline my-pipeline
   ├─ Parse command-line arguments
   ├─ Validate input parameters
   └─ Call Application Service

2. Application Layer (FileProcessorService)
   ↓ process_file(pipeline_id, input_path, output_path)
   ├─ Fetch Pipeline from Repository (Infrastructure)
   ├─ Create ProcessingContext (Domain)
   ├─ For each stage:
   │  ├─ Call CompressionService (Infrastructure)
   │  ├─ Call EncryptionService (Infrastructure)
   │  └─ Update metrics (Domain)
   └─ Return ProcessingMetrics (Domain)

3. Domain Layer (Pipeline, ProcessingContext)
   ↓ Enforce business rules
   ├─ Validate stage compatibility
   ├─ Enforce chunk sequencing
   └─ Calculate metrics

4. Infrastructure Layer (Repositories, Services)
   ↓ Handle external operations
   ├─ Query SQLite database
   ├─ Read/write files
   ├─ Compress data (brotli, zstd, etc.)
   └─ Encrypt data (AES, ChaCha20)
</code></pre>
<h2 id="benefits-of-layered-architecture"><a class="header" href="#benefits-of-layered-architecture">Benefits of Layered Architecture</a></h2>
<h3 id="separation-of-concerns"><a class="header" href="#separation-of-concerns">Separation of Concerns</a></h3>
<p>Each layer has a single, well-defined responsibility. This makes the code easier to understand and maintain.</p>
<h3 id="testability-1"><a class="header" href="#testability-1">Testability</a></h3>
<ul>
<li><strong>Domain Layer</strong>: Test business logic without any infrastructure</li>
<li><strong>Application Layer</strong>: Test workflows with mock repositories</li>
<li><strong>Infrastructure Layer</strong>: Test database operations independently</li>
<li><strong>Presentation Layer</strong>: Test user interaction separately</li>
</ul>
<h3 id="flexibility"><a class="header" href="#flexibility">Flexibility</a></h3>
<p>You can change infrastructure (e.g., swap SQLite for PostgreSQL) without touching domain or application layers.</p>
<h3 id="maintainability"><a class="header" href="#maintainability">Maintainability</a></h3>
<p>Changes in one layer typically don't affect other layers, reducing the risk of breaking existing functionality.</p>
<h3 id="parallel-development"><a class="header" href="#parallel-development">Parallel Development</a></h3>
<p>Teams can work on different layers simultaneously without conflicts.</p>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="-breaking-the-dependency-rule"><a class="header" href="#-breaking-the-dependency-rule">❌ Breaking the Dependency Rule</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG: Domain depending on infrastructure
pub struct Pipeline {
    id: PipelineId,
    db_connection: SqlitePool,  // ❌ Database dependency in domain!
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CORRECT: Domain independent of infrastructure
pub struct Pipeline {
    id: PipelineId,
    name: String,
    stages: Vec&lt;PipelineStage&gt;,  // ✅ Pure domain types
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-business-logic-in-application-layer"><a class="header" href="#-business-logic-in-application-layer">❌ Business Logic in Application Layer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG: Business logic in application
impl FileProcessorService {
    pub async fn process_file(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), Error&gt; {
        // ❌ Business rule in application layer!
        if pipeline.stages().is_empty() {
            return Err(Error::InvalidPipeline);
        }
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CORRECT: Business logic in domain
impl Pipeline {
    pub fn new(name: String, stages: Vec&lt;PipelineStage&gt;) -&gt; Result&lt;Self, PipelineError&gt; {
        // ✅ Business rule in domain layer
        if stages.is_empty() {
            return Err(PipelineError::InvalidConfiguration(
                "Pipeline must have at least one stage".to_string()
            ));
        }
        Ok(Self { /* ... */ })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-direct-infrastructure-access-from-presentation"><a class="header" href="#-direct-infrastructure-access-from-presentation">❌ Direct Infrastructure Access from Presentation</a></h3>
<pre><pre class="playground"><code class="language-rust">// WRONG: Presentation accessing infrastructure directly
async fn main() {
    let db_pool = create_database_pool().await?;
    // ❌ CLI directly using repository!
    let pipeline = db_pool.query("SELECT * FROM pipelines").await?;
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// CORRECT: Presentation using application services
async fn main() {
    let file_processor = create_file_processor().await?;
    // ✅ CLI using application service
    let result = file_processor.process_file(&amp;pipeline_id, &amp;input, &amp;output).await?;
}</code></pre></pre>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<p>Now that you understand the layered architecture:</p>
<ul>
<li><a href="architecture/adapter-pattern.html">Hexagonal Architecture</a> - Ports and adapters pattern</li>
<li><a href="architecture/dependencies.html">Dependency Inversion</a> - Managing dependencies</li>
<li><a href="architecture/domain-model.html">Domain Model</a> - Deep dive into the domain layer</li>
<li><a href="architecture/repository-pattern.html">Repository Pattern</a> - Data persistence abstraction</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-flow"><a class="header" href="#dependency-flow">Dependency Flow</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Understanding dependency direction and inversion.</p>
<h2 id="dependency-rule-1"><a class="header" href="#dependency-rule-1">Dependency Rule</a></h2>
<p>TODO: Explain dependency direction</p>
<h2 id="dependency-inversion"><a class="header" href="#dependency-inversion">Dependency Inversion</a></h2>
<p>TODO: Explain DIP application</p>
<h2 id="trait-abstractions"><a class="header" href="#trait-abstractions">Trait Abstractions</a></h2>
<p>TODO: Explain trait usage</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-model-1"><a class="header" href="#domain-model-1">Domain Model</a></h1>
<p><strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner, Claude Code
<strong>Status:</strong> Active</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The domain model is the heart of the pipeline system. It captures the core business concepts, rules, and behaviors using Domain-Driven Design (DDD) principles. This chapter explains how the domain model is structured and why it's designed this way.</p>
<p><img src="architecture/../diagrams/domain-model.svg" alt="Domain Model" /></p>
<h2 id="domain-driven-design-principles"><a class="header" href="#domain-driven-design-principles">Domain-Driven Design Principles</a></h2>
<p>Domain-Driven Design (DDD) is a software development approach that emphasizes:</p>
<ol>
<li><strong>Focus on the core domain</strong> - The business logic is the most important part</li>
<li><strong>Model-driven design</strong> - The domain model drives the software design</li>
<li><strong>Ubiquitous language</strong> - Shared vocabulary between developers and domain experts</li>
<li><strong>Bounded contexts</strong> - Clear boundaries between different parts of the system</li>
</ol>
<h3 id="why-ddd"><a class="header" href="#why-ddd">Why DDD?</a></h3>
<p>For a pipeline processing system, DDD provides:</p>
<ul>
<li><strong>Clear separation</strong> between business logic and infrastructure</li>
<li><strong>Testable code</strong> - Domain logic can be tested without databases or files</li>
<li><strong>Flexibility</strong> - Easy to change infrastructure without touching business rules</li>
<li><strong>Maintainability</strong> - Business rules are explicit and well-organized</li>
</ul>
<h2 id="core-domain-concepts"><a class="header" href="#core-domain-concepts">Core Domain Concepts</a></h2>
<h3 id="entities-1"><a class="header" href="#entities-1">Entities</a></h3>
<p><strong>Entities</strong> are objects with a unique identity that persists through time. Two entities are equal if they have the same ID, even if all their other attributes differ.</p>
<h4 id="pipeline-entity"><a class="header" href="#pipeline-entity">Pipeline Entity</a></h4>
<p>The central entity representing a file processing workflow.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Pipeline {
    id: PipelineId,                    // Unique identity
    name: String,                      // Human-readable name
    stages: Vec&lt;PipelineStage&gt;,        // Ordered processing stages
    configuration: HashMap&lt;String, String&gt;,  // Custom settings
    metrics: ProcessingMetrics,        // Performance data
    archived: bool,                    // Lifecycle state
    created_at: DateTime&lt;Utc&gt;,         // Creation timestamp
    updated_at: DateTime&lt;Utc&gt;,         // Last modification
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Has unique <code>PipelineId</code></li>
<li>Can be modified while maintaining identity</li>
<li>Enforces business rules (e.g., must have at least one stage)</li>
<li>Automatically adds integrity verification stages</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pipeline_domain::Pipeline;

// Two pipelines with same ID are equal, even if names differ
let pipeline1 = Pipeline::new("Original Name", stages.clone())?;
let pipeline2 = pipeline1.clone();
pipeline2.set_name("Different Name");

assert_eq!(pipeline1.id(), pipeline2.id());  // Same identity
<span class="boring">}</span></code></pre></pre>
<h4 id="pipelinestage-entity"><a class="header" href="#pipelinestage-entity">PipelineStage Entity</a></h4>
<p>Represents a single processing operation within a pipeline.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PipelineStage {
    id: StageId,                       // Unique identity
    name: String,                      // Stage name
    stage_type: StageType,             // Compression, Encryption, etc.
    configuration: StageConfiguration, // Algorithm and parameters
    order: usize,                      // Execution order
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Stage Types:</strong></p>
<ul>
<li><code>Compression</code> - Data compression</li>
<li><code>Encryption</code> - Data encryption</li>
<li><code>Integrity</code> - Checksum verification</li>
<li><code>Custom</code> - User-defined operations</li>
</ul>
<h4 id="processingcontext-entity"><a class="header" href="#processingcontext-entity">ProcessingContext Entity</a></h4>
<p>Manages the runtime execution state of a pipeline.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProcessingContext {
    id: ProcessingContextId,           // Unique identity
    pipeline_id: PipelineId,           // Associated pipeline
    input_path: FilePath,              // Input file
    output_path: FilePath,             // Output file
    current_stage: usize,              // Current stage index
    status: ProcessingStatus,          // Running, Completed, Failed
    metrics: ProcessingMetrics,        // Runtime metrics
}
<span class="boring">}</span></code></pre></pre>
<h4 id="securitycontext-entity"><a class="header" href="#securitycontext-entity">SecurityContext Entity</a></h4>
<p>Manages security and permissions for pipeline operations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SecurityContext {
    id: SecurityContextId,             // Unique identity
    user_id: UserId,                   // User performing operation
    security_level: SecurityLevel,     // Required security level
    permissions: Vec&lt;Permission&gt;,      // Granted permissions
    encryption_key_id: Option&lt;EncryptionKeyId&gt;,  // Key for encryption
}
<span class="boring">}</span></code></pre></pre>
<h3 id="value-objects-1"><a class="header" href="#value-objects-1">Value Objects</a></h3>
<p><strong>Value Objects</strong> are immutable objects defined by their attributes. Two value objects with the same attributes are considered equal.</p>
<h4 id="algorithm-value-object"><a class="header" href="#algorithm-value-object">Algorithm Value Object</a></h4>
<p>Type-safe representation of processing algorithms.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Algorithm(String);

impl Algorithm {
    // Predefined compression algorithms
    pub fn brotli() -&gt; Self { /* ... */ }
    pub fn gzip() -&gt; Self { /* ... */ }
    pub fn zstd() -&gt; Self { /* ... */ }
    pub fn lz4() -&gt; Self { /* ... */ }

    // Predefined encryption algorithms
    pub fn aes_256_gcm() -&gt; Self { /* ... */ }
    pub fn chacha20_poly1305() -&gt; Self { /* ... */ }

    // Predefined hashing algorithms
    pub fn sha256() -&gt; Self { /* ... */ }
    pub fn blake3() -&gt; Self { /* ... */ }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Immutable after creation</li>
<li>Self-validating (enforces format rules)</li>
<li>Category detection (is_compression(), is_encryption())</li>
<li>Type-safe (can't accidentally use wrong algorithm)</li>
</ul>
<h4 id="chunksize-value-object"><a class="header" href="#chunksize-value-object">ChunkSize Value Object</a></h4>
<p>Represents validated chunk sizes for file processing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ChunkSize(usize);

impl ChunkSize {
    pub fn new(bytes: usize) -&gt; Result&lt;Self, PipelineError&gt; {
        // Validates size is within acceptable range
        if bytes &lt; MIN_CHUNK_SIZE || bytes &gt; MAX_CHUNK_SIZE {
            return Err(PipelineError::InvalidConfiguration(/* ... */));
        }
        Ok(Self(bytes))
    }

    pub fn from_megabytes(mb: usize) -&gt; Result&lt;Self, PipelineError&gt; {
        Self::new(mb * 1024 * 1024)
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="filechunk-value-object"><a class="header" href="#filechunk-value-object">FileChunk Value Object</a></h4>
<p>Immutable representation of a piece of file data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FileChunk {
    id: FileChunkId,                   // Unique chunk identifier
    sequence: usize,                   // Position in file
    data: Vec&lt;u8&gt;,                     // Chunk data
    is_final: bool,                    // Last chunk flag
    checksum: Option&lt;String&gt;,          // Integrity verification
}
<span class="boring">}</span></code></pre></pre>
<h4 id="filepath-value-object"><a class="header" href="#filepath-value-object">FilePath Value Object</a></h4>
<p>Type-safe, validated file paths.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FilePath(PathBuf);

impl FilePath {
    pub fn new(path: impl Into&lt;PathBuf&gt;) -&gt; Result&lt;Self, PipelineError&gt; {
        let path = path.into();
        // Validation:
        // - Path traversal prevention
        // - Null byte checks
        // - Length limits
        // - Encoding validation
        Ok(Self(path))
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="pipelineid-stageid-userid-type-safe-ids"><a class="header" href="#pipelineid-stageid-userid-type-safe-ids">PipelineId, StageId, UserId (Type-Safe IDs)</a></h4>
<p>All identifiers are wrapped in newtype value objects for type safety:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PipelineId(Ulid);  // Can't accidentally use StageId as PipelineId
pub struct StageId(Ulid);
pub struct UserId(Ulid);
pub struct ProcessingContextId(Ulid);
pub struct SecurityContextId(Ulid);
<span class="boring">}</span></code></pre></pre>
<p>This prevents common bugs like passing the wrong ID to a function.</p>
<h3 id="domain-services"><a class="header" href="#domain-services">Domain Services</a></h3>
<p><strong>Domain Services</strong> contain business logic that doesn't naturally fit in an entity or value object. They are stateless and operate on domain objects.</p>
<p>Domain services in our system are defined as traits (interfaces) in the domain layer and implemented in the infrastructure layer.</p>
<h4 id="compressionservice"><a class="header" href="#compressionservice">CompressionService</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait CompressionService: Send + Sync {
    async fn compress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt;;

    async fn decompress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="encryptionservice"><a class="header" href="#encryptionservice">EncryptionService</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait EncryptionService: Send + Sync {
    async fn encrypt(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt;;

    async fn decrypt(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="checksumservice"><a class="header" href="#checksumservice">ChecksumService</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ChecksumService: Send + Sync {
    fn calculate(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;String, PipelineError&gt;;

    fn verify(
        &amp;self,
        data: &amp;[u8],
        expected: &amp;str,
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;bool, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="repositories"><a class="header" href="#repositories">Repositories</a></h3>
<p><strong>Repositories</strong> abstract data persistence, allowing the domain to work with collections without knowing about storage details.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait PipelineRepository: Send + Sync {
    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt;;
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt;;
    async fn find_by_name(&amp;self, name: &amp;str) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt;;
    async fn update(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt;;
    async fn delete(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;(), PipelineError&gt;;
    async fn list_all(&amp;self) -&gt; Result&lt;Vec&lt;Pipeline&gt;, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The repository interface is defined in the domain layer, but implementations live in the infrastructure layer. This follows the Dependency Inversion Principle.</p>
<h3 id="domain-events"><a class="header" href="#domain-events">Domain Events</a></h3>
<p><strong>Domain Events</strong> represent significant business occurrences that other parts of the system might care about.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum DomainEvent {
    PipelineCreated {
        pipeline_id: PipelineId,
        name: String,
        created_at: DateTime&lt;Utc&gt;,
    },
    ProcessingStarted {
        pipeline_id: PipelineId,
        context_id: ProcessingContextId,
        input_path: FilePath,
    },
    ProcessingCompleted {
        pipeline_id: PipelineId,
        context_id: ProcessingContextId,
        metrics: ProcessingMetrics,
    },
    ProcessingFailed {
        pipeline_id: PipelineId,
        context_id: ProcessingContextId,
        error: String,
    },
}
<span class="boring">}</span></code></pre></pre>
<p>Events enable:</p>
<ul>
<li><strong>Loose coupling</strong> - Components don't need direct references</li>
<li><strong>Audit trails</strong> - Track all significant operations</li>
<li><strong>Integration</strong> - External systems can react to events</li>
<li><strong>Event sourcing</strong> - Reconstruct state from event history</li>
</ul>
<h2 id="business-rules-and-invariants"><a class="header" href="#business-rules-and-invariants">Business Rules and Invariants</a></h2>
<p>The domain model enforces critical business rules:</p>
<h3 id="pipeline-rules"><a class="header" href="#pipeline-rules">Pipeline Rules</a></h3>
<ol>
<li>
<p><strong>Pipelines must have at least one user-defined stage</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if user_stages.is_empty() {
    return Err(PipelineError::InvalidConfiguration(
        "Pipeline must have at least one stage".to_string()
    ));
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Stage order must be sequential and valid</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Stages are automatically reordered: 0, 1, 2, 3...
// Input checksum = 0
// User stages = 1, 2, 3...
// Output checksum = final
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Pipeline names must be unique</strong> (enforced by repository)</p>
</li>
</ol>
<h3 id="chunk-processing-rules"><a class="header" href="#chunk-processing-rules">Chunk Processing Rules</a></h3>
<ol>
<li>
<p><strong>Chunks must have non-zero size</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if size == 0 {
    return Err(PipelineError::InvalidChunkSize);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Chunk sequence numbers must be sequential</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Chunks are numbered 0, 1, 2, 3...
// Missing sequences cause processing to fail
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Final chunks must be properly marked</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if chunk.is_final() {
    // No more chunks should follow
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="security-rules"><a class="header" href="#security-rules">Security Rules</a></h3>
<ol>
<li>
<p><strong>Security contexts must be validated</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>security_context.validate()?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Encryption keys must meet strength requirements</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if key.len() &lt; MIN_KEY_LENGTH {
    return Err(PipelineError::WeakEncryptionKey);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Access permissions must be checked</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !security_context.has_permission(Permission::ProcessFile) {
    return Err(PipelineError::PermissionDenied);
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="ubiquitous-language"><a class="header" href="#ubiquitous-language">Ubiquitous Language</a></h2>
<p>The domain model uses consistent terminology shared between developers and domain experts:</p>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Meaning</th></tr></thead><tbody>
<tr><td><strong>Pipeline</strong></td><td>An ordered sequence of processing stages</td></tr>
<tr><td><strong>Stage</strong></td><td>A single processing operation (compress, encrypt, etc.)</td></tr>
<tr><td><strong>Chunk</strong></td><td>A piece of a file processed in parallel</td></tr>
<tr><td><strong>Algorithm</strong></td><td>A specific processing method (zstd, aes-256-gcm, etc.)</td></tr>
<tr><td><strong>Repository</strong></td><td>Storage abstraction for domain objects</td></tr>
<tr><td><strong>Context</strong></td><td>Runtime execution state</td></tr>
<tr><td><strong>Metrics</strong></td><td>Performance and operational measurements</td></tr>
<tr><td><strong>Integrity</strong></td><td>Data verification through checksums</td></tr>
<tr><td><strong>Security Level</strong></td><td>Required protection level (Public, Confidential, Secret)</td></tr>
</tbody></table>
</div>
<h2 id="testing-domain-logic"><a class="header" href="#testing-domain-logic">Testing Domain Logic</a></h2>
<p>Domain objects are designed for easy testing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn pipeline_enforces_minimum_stages() {
        // Domain logic can be tested without any infrastructure
        let result = Pipeline::new("test".to_string(), vec![]);
        assert!(result.is_err());
    }

    #[test]
    fn algorithm_validates_format() {
        // Value objects self-validate
        let result = Algorithm::new("INVALID-NAME".to_string());
        assert!(result.is_err());

        let result = Algorithm::new("valid-name".to_string());
        assert!(result.is_ok());
    }

    #[test]
    fn chunk_size_enforces_limits() {
        // Business rules are explicit and testable
        let too_small = ChunkSize::new(1);
        assert!(too_small.is_err());

        let valid = ChunkSize::from_megabytes(10);
        assert!(valid.is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="benefits-of-this-domain-model"><a class="header" href="#benefits-of-this-domain-model">Benefits of This Domain Model</a></h2>
<ol>
<li><strong>Pure Business Logic</strong> - No infrastructure dependencies</li>
<li><strong>Highly Testable</strong> - Can test without databases, files, or networks</li>
<li><strong>Type Safety</strong> - Strong typing prevents many bugs at compile time</li>
<li><strong>Self-Documenting</strong> - Code structure reflects business concepts</li>
<li><strong>Flexible</strong> - Easy to change infrastructure without touching domain</li>
<li><strong>Maintainable</strong> - Business rules are explicit and centralized</li>
</ol>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<p>Now that you understand the domain model:</p>
<ul>
<li><a href="architecture/layered-architecture.html">Layered Architecture</a> - How the domain fits into the overall architecture</li>
<li><a href="architecture/hexagonal-architecture.html">Hexagonal Architecture</a> - Ports and adapters pattern</li>
<li><a href="architecture/repository-pattern.html">Repository Pattern</a> - Data persistence abstraction</li>
<li><a href="architecture/event-driven.html">Domain Events</a> - Event-driven communication</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities-2"><a class="header" href="#entities-2">Entities</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Understanding entities in the domain model.</p>
<h2 id="what-are-entities"><a class="header" href="#what-are-entities">What are Entities?</a></h2>
<p>TODO: Define entities</p>
<h2 id="pipeline-entity-1"><a class="header" href="#pipeline-entity-1">Pipeline Entity</a></h2>
<p>TODO: Extract from entities/pipeline.rs</p>
<h2 id="stage-entity"><a class="header" href="#stage-entity">Stage Entity</a></h2>
<p>TODO: Extract from entities/pipeline_stage.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-objects-2"><a class="header" href="#value-objects-2">Value Objects</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Understanding value objects in the domain model.</p>
<h2 id="what-are-value-objects"><a class="header" href="#what-are-value-objects">What are Value Objects?</a></h2>
<p>TODO: Define value objects</p>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p>TODO: Explain immutability</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>TODO: List key value objects</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregates-1"><a class="header" href="#aggregates-1">Aggregates</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Understanding aggregates and aggregate roots.</p>
<h2 id="what-are-aggregates"><a class="header" href="#what-are-aggregates">What are Aggregates?</a></h2>
<p>TODO: Define aggregates</p>
<h2 id="aggregate-boundaries"><a class="header" href="#aggregate-boundaries">Aggregate Boundaries</a></h2>
<p>TODO: Explain boundaries</p>
<h2 id="pipeline-aggregate"><a class="header" href="#pipeline-aggregate">Pipeline Aggregate</a></h2>
<p>TODO: Explain pipeline aggregate</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-patterns"><a class="header" href="#design-patterns">Design Patterns</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Design patterns used throughout the pipeline.</p>
<h2 id="pattern-overview"><a class="header" href="#pattern-overview">Pattern Overview</a></h2>
<p>TODO: List patterns</p>
<h2 id="when-to-use-each-pattern"><a class="header" href="#when-to-use-each-pattern">When to Use Each Pattern</a></h2>
<p>TODO: Add guidance</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repository-pattern"><a class="header" href="#repository-pattern">Repository Pattern</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>The Repository pattern for data persistence.</p>
<h2 id="pattern-overview-1"><a class="header" href="#pattern-overview-1">Pattern Overview</a></h2>
<p>The Repository pattern provides an abstraction layer between the domain and data mapping layers. It acts like an in-memory collection of domain objects, hiding the complexities of database operations.</p>
<p><strong>Key Idea</strong>: Your business logic shouldn't know whether data comes from SQLite, PostgreSQL, or a file. It just uses a <code>Repository</code> trait.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p><img src="architecture/../diagrams/repository-pattern.svg" alt="Repository Pattern" /></p>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<p><strong>Repository Trait</strong> (Domain Layer)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait PipelineRepository {
    fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;()&gt;;
    fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;&gt;;
    fn update(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;()&gt;;
    fn delete(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;()&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Repository Adapter</strong> (Infrastructure Layer)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PipelineRepositoryAdapter {
    repository: SQLitePipelineRepository,
}

impl PipelineRepository for PipelineRepositoryAdapter {
    // Implements trait methods
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Concrete Repository</strong> (Infrastructure Layer)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SQLitePipelineRepository {
    pool: SqlitePool,
    mapper: PipelineMapper,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="layer-responsibilities"><a class="header" href="#layer-responsibilities">Layer Responsibilities</a></h2>
<h3 id="domain-layer-1"><a class="header" href="#domain-layer-1">Domain Layer</a></h3>
<p>Defines <strong>what</strong> operations are needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain defines the interface
pub trait PipelineRepository: Send + Sync {
    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;()&gt;;
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;&gt;;
    // ... more methods
}
<span class="boring">}</span></code></pre></pre>
<p>Domain knows:</p>
<ul>
<li>What operations it needs</li>
<li>What domain entities look like</li>
<li>Business rules and validations</li>
</ul>
<p>Domain <strong>doesn't know</strong>:</p>
<ul>
<li>SQL syntax</li>
<li>Database technology</li>
<li>Connection pooling</li>
</ul>
<h3 id="infrastructure-layer-1"><a class="header" href="#infrastructure-layer-1">Infrastructure Layer</a></h3>
<p>Implements <strong>how</strong> to persist data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PipelineRepository for PipelineRepositoryAdapter {
    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;()&gt; {
        // Convert domain entity to database row
        let row = self.mapper.to_persistence(pipeline);

        // Execute SQL
        sqlx::query("INSERT INTO pipelines ...")
            .execute(&amp;self.pool)
            .await?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Infrastructure knows:</p>
<ul>
<li>SQL syntax and queries</li>
<li>Database schema</li>
<li>Connection management</li>
<li>Error handling</li>
</ul>
<h2 id="data-mapping"><a class="header" href="#data-mapping">Data Mapping</a></h2>
<p>The <strong>Mapper</strong> separates domain models from database schema:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PipelineMapper;

impl PipelineMapper {
    // Domain → Database
    fn to_persistence(&amp;self, pipeline: &amp;Pipeline) -&gt; PipelineRow {
        PipelineRow {
            id: pipeline.id().to_string(),
            input_path: pipeline.input_path().to_string(),
            // ... map all fields
        }
    }

    // Database → Domain
    fn to_domain(&amp;self, row: SqliteRow) -&gt; Result&lt;Pipeline&gt; {
        Pipeline::new(
            PipelineId::from_string(&amp;row.id)?,
            FilePath::new(&amp;row.input_path)?,
            FilePath::new(&amp;row.output_path)?,
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why mapping?</strong></p>
<ul>
<li>Domain entities stay pure (no database annotations)</li>
<li>Database schema can change independently</li>
<li>Different databases can use different schemas</li>
<li>Validation happens in domain layer</li>
</ul>
<h2 id="benefits-1"><a class="header" href="#benefits-1">Benefits</a></h2>
<h3 id="1-testability"><a class="header" href="#1-testability">1. Testability</a></h3>
<p>Business logic can be tested without a database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use mockall::mock;

    mock! {
        PipelineRepo {}

        impl PipelineRepository for PipelineRepo {
            async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;()&gt;;
            // ... mock other methods
        }
    }

    #[tokio::test]
    async fn test_pipeline_service() {
        let mut mock_repo = MockPipelineRepo::new();
        mock_repo.expect_create()
            .returning(|_| Ok(()));

        let service = PipelineService::new(Arc::new(mock_repo));
        // Test business logic without database
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-flexibility"><a class="header" href="#2-flexibility">2. Flexibility</a></h3>
<p>Swap implementations without changing business logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start with SQLite
let repo = SQLitePipelineRepositoryAdapter::new(pool);
let service = PipelineService::new(Arc::new(repo));

// Later, switch to PostgreSQL
let repo = PostgresPipelineRepositoryAdapter::new(pool);
let service = PipelineService::new(Arc::new(repo));
// Business logic unchanged!
<span class="boring">}</span></code></pre></pre>
<h3 id="3-centralized-data-access"><a class="header" href="#3-centralized-data-access">3. Centralized Data Access</a></h3>
<p>All database queries in one place:</p>
<ul>
<li>Easier to optimize</li>
<li>Easier to audit</li>
<li>Easier to cache</li>
<li>Easier to add logging</li>
</ul>
<h3 id="4-domain-purity"><a class="header" href="#4-domain-purity">4. Domain Purity</a></h3>
<p>Domain layer stays technology-agnostic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain doesn't import sqlx, postgres, etc.
// Only depends on standard Rust types
pub struct Pipeline {
    id: PipelineId,           // Not i64 or UUID from database
    input_path: FilePath,     // Not String from database
    status: PipelineStatus,   // Not database enum
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h2>
<h3 id="application-layer-1"><a class="header" href="#application-layer-1">Application Layer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PipelineService {
    repository: Arc&lt;dyn PipelineRepository&gt;,
}

impl PipelineService {
    pub async fn create_pipeline(
        &amp;self,
        input: FilePath,
        output: FilePath,
    ) -&gt; Result&lt;Pipeline&gt; {
        // Create domain entity
        let pipeline = Pipeline::new(
            PipelineId::new(),
            input,
            output,
        )?;

        // Persist using repository
        self.repository.create(&amp;pipeline).await?;

        Ok(pipeline)
    }

    pub async fn get_pipeline(
        &amp;self,
        id: PipelineId,
    ) -&gt; Result&lt;Option&lt;Pipeline&gt;&gt; {
        self.repository.find_by_id(&amp;id).await
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The service doesn't know or care:</p>
<ul>
<li>Which database is used</li>
<li>How data is stored</li>
<li>What the SQL looks like</li>
</ul>
<p>It just uses the <code>Repository</code> trait!</p>
<h2 id="implementation-in-pipeline"><a class="header" href="#implementation-in-pipeline">Implementation in Pipeline</a></h2>
<p>Our pipeline uses this pattern for:</p>
<p><strong>PipelineRepository</strong> - Stores pipeline metadata</p>
<ul>
<li><code>pipeline/domain/src/repositories/pipeline_repository.rs</code> (trait)</li>
<li><code>pipeline/src/infrastructure/repositories/sqlite_pipeline_repository.rs</code> (impl)</li>
</ul>
<p><strong>FileChunkRepository</strong> - Stores chunk metadata</p>
<ul>
<li><code>pipeline/domain/src/repositories/file_chunk_repository.rs</code> (trait)</li>
<li><code>pipeline/src/infrastructure/repositories/sqlite_file_chunk_repository.rs</code> (impl)</li>
</ul>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>Continue to:</p>
<ul>
<li><a href="architecture/service-pattern.html">Service Pattern</a> - Business logic organization</li>
<li><a href="architecture/adapter-pattern.html">Adapter Pattern</a> - Infrastructure integration</li>
<li><a href="architecture/../implementation/repositories.html">Implementation: Repositories</a> - Concrete implementations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-pattern"><a class="header" href="#service-pattern">Service Pattern</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>The Service pattern for domain and application logic.</p>
<h2 id="pattern-overview-2"><a class="header" href="#pattern-overview-2">Pattern Overview</a></h2>
<p>TODO: Extract from service files</p>
<h2 id="domain-vs-application-services"><a class="header" href="#domain-vs-application-services">Domain vs Application Services</a></h2>
<p>TODO: Explain distinction</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>TODO: Show examples</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hexagonal-architecture-ports-and-adapters-1"><a class="header" href="#hexagonal-architecture-ports-and-adapters-1">Hexagonal Architecture (Ports and Adapters)</a></h1>
<p><strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner, Claude Code
<strong>Status:</strong> Active</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Hexagonal Architecture, also known as <strong>Ports and Adapters</strong>, is a pattern that isolates the core business logic (domain) from external concerns. The pipeline system uses this pattern to keep the domain pure and infrastructure replaceable.</p>
<p><img src="architecture/../diagrams/hexagonal-architecture.svg" alt="Hexagonal Architecture" /></p>
<h2 id="the-hexagon-metaphor"><a class="header" href="#the-hexagon-metaphor">The Hexagon Metaphor</a></h2>
<p>Think of your application as a hexagon:</p>
<pre><code class="language-text">                     ┌─────────────────┐
                     │   Primary       │
                     │   Adapters      │
                     │  (Drivers)      │
                     └────────┬────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
        │              ┌──────▼──────┐              │
        │              │             │              │
        │              │   Domain    │              │
        │              │    (Core)   │              │
        │              │             │              │
        │              └──────┬──────┘              │
        │                     │                     │
        └─────────────────────┼─────────────────────┘
                              │
                     ┌────────▼────────┐
                     │   Secondary     │
                     │   Adapters      │
                     │  (Driven)       │
                     └─────────────────┘
</code></pre>
<ul>
<li><strong>The Hexagon (Core)</strong>: Your domain logic - completely independent</li>
<li><strong>Ports</strong>: Interfaces that define how to interact with the core</li>
<li><strong>Adapters</strong>: Implementations that connect the core to the outside world</li>
</ul>
<h2 id="ports-the-interfaces"><a class="header" href="#ports-the-interfaces">Ports: The Interfaces</a></h2>
<p><strong>Ports</strong> are interfaces defined by the domain layer. They specify what the domain needs without caring about implementation details.</p>
<h3 id="primary-ports-driving"><a class="header" href="#primary-ports-driving">Primary Ports (Driving)</a></h3>
<p>Primary ports define <strong>use cases</strong> - what the application can do. External systems drive the application through these ports.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain layer defines the interface (port)
#[async_trait]
pub trait FileProcessorService: Send + Sync {
    async fn process_file(
        &amp;self,
        pipeline_id: &amp;PipelineId,
        input_path: &amp;FilePath,
        output_path: &amp;FilePath,
    ) -&gt; Result&lt;ProcessingMetrics, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Examples in our system:</strong></p>
<ul>
<li><code>FileProcessorService</code> - File processing operations</li>
<li><code>PipelineService</code> - Pipeline management operations</li>
</ul>
<h3 id="secondary-ports-driven"><a class="header" href="#secondary-ports-driven">Secondary Ports (Driven)</a></h3>
<p>Secondary ports define <strong>dependencies</strong> - what the domain needs from the outside world. The application drives these external systems.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain layer defines what it needs (port)
#[async_trait]
pub trait PipelineRepository: Send + Sync {
    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt;;
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt;;
    async fn update(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt;;
    async fn delete(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;(), PipelineError&gt;;
}

#[async_trait]
pub trait CompressionService: Send + Sync {
    async fn compress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt;;

    async fn decompress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Examples in our system:</strong></p>
<ul>
<li><code>PipelineRepository</code> - Data persistence</li>
<li><code>CompressionService</code> - Data compression</li>
<li><code>EncryptionService</code> - Data encryption</li>
<li><code>ChecksumService</code> - Integrity verification</li>
</ul>
<h2 id="adapters-the-implementations"><a class="header" href="#adapters-the-implementations">Adapters: The Implementations</a></h2>
<p><strong>Adapters</strong> are concrete implementations of ports. They translate between the domain and external systems.</p>
<h3 id="primary-adapters-driving"><a class="header" href="#primary-adapters-driving">Primary Adapters (Driving)</a></h3>
<p>Primary adapters <strong>drive</strong> the application. They take input from the outside world and call the domain.</p>
<h4 id="cli-adapter-mainrs"><a class="header" href="#cli-adapter-mainrs">CLI Adapter (main.rs)</a></h4>
<pre><pre class="playground"><code class="language-rust">// Primary adapter - drives the application
#[tokio::main]
async fn main() -&gt; std::process::ExitCode {
    // 1. Parse user input
    let cli = bootstrap::bootstrap_cli()?;

    // 2. Set up infrastructure (dependency injection)
    let services = setup_services().await?;

    // 3. Drive the domain through primary port
    match cli.command {
        Commands::Process { input, output, pipeline } =&gt; {
            // Call domain through FileProcessorService port
            services.file_processor
                .process_file(&amp;pipeline, &amp;input, &amp;output)
                .await?
        }
        Commands::Create { name, stages } =&gt; {
            // Call domain through PipelineService port
            services.pipeline_service
                .create_pipeline(&amp;name, stages)
                .await?
        }
        // ... more commands
    }
}</code></pre></pre>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Translates user input to domain operations</li>
<li>Handles presentation concerns (formatting, errors)</li>
<li>Drives the application core</li>
</ul>
<h4 id="http-api-adapter-future"><a class="header" href="#http-api-adapter-future">HTTP API Adapter (future)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Another primary adapter for HTTP API
async fn handle_process_request(
    req: HttpRequest,
    services: Arc&lt;Services&gt;,
) -&gt; HttpResponse {
    // Parse HTTP request
    let body: ProcessFileRequest = req.json().await?;

    // Drive domain through the same port
    let result = services.file_processor
        .process_file(&amp;body.pipeline_id, &amp;body.input, &amp;body.output)
        .await;

    // Convert result to HTTP response
    match result {
        Ok(metrics) =&gt; HttpResponse::Ok().json(metrics),
        Err(e) =&gt; HttpResponse::BadRequest().json(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Notice:</strong> Both CLI and HTTP adapters use the <strong>same domain ports</strong>. The domain doesn't know or care which adapter is calling it.</p>
<h3 id="secondary-adapters-driven"><a class="header" href="#secondary-adapters-driven">Secondary Adapters (Driven)</a></h3>
<p>Secondary adapters are <strong>driven by</strong> the application. They implement the interfaces the domain needs.</p>
<h4 id="sqlite-repository-adapter"><a class="header" href="#sqlite-repository-adapter">SQLite Repository Adapter</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Infrastructure layer - implements domain port
pub struct SQLitePipelineRepository {
    pool: SqlitePool,
}

#[async_trait]
impl PipelineRepository for SQLitePipelineRepository {
    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt; {
        // Convert domain entity to database row
        let row = PipelineRow::from_domain(pipeline);

        // Persist to SQLite
        sqlx::query(
            "INSERT INTO pipelines (id, name, archived, created_at, updated_at)
             VALUES (?, ?, ?, ?, ?)"
        )
        .bind(&amp;row.id)
        .bind(&amp;row.name)
        .bind(row.archived)
        .bind(&amp;row.created_at)
        .bind(&amp;row.updated_at)
        .execute(&amp;self.pool)
        .await
        .map_err(|e| PipelineError::RepositoryError(e.to_string()))?;

        Ok(())
    }

    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt; {
        // Query SQLite
        let row = sqlx::query_as::&lt;_, PipelineRow&gt;(
            "SELECT * FROM pipelines WHERE id = ?"
        )
        .bind(id.to_string())
        .fetch_optional(&amp;self.pool)
        .await
        .map_err(|e| PipelineError::RepositoryError(e.to_string()))?;

        // Convert database row to domain entity
        row.map(|r| Pipeline::from_database(r)).transpose()
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Implements domain-defined interface</li>
<li>Handles database-specific operations</li>
<li>Translates between domain models and database rows</li>
<li>Can be swapped without changing domain</li>
</ul>
<h4 id="compression-service-adapter"><a class="header" href="#compression-service-adapter">Compression Service Adapter</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Infrastructure layer - implements domain port
pub struct CompressionServiceAdapter {
    // Internal state for compression libraries
}

#[async_trait]
impl CompressionService for CompressionServiceAdapter {
    async fn compress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
        // Route to appropriate compression library
        match algorithm.name() {
            "brotli" =&gt; {
                let mut compressed = Vec::new();
                brotli::BrotliCompress(
                    &amp;mut Cursor::new(data),
                    &amp;mut compressed,
                    &amp;Default::default(),
                )?;
                Ok(compressed)
            }
            "zstd" =&gt; {
                let compressed = zstd::encode_all(data, 3)?;
                Ok(compressed)
            }
            "lz4" =&gt; {
                let compressed = lz4::block::compress(data, None, false)?;
                Ok(compressed)
            }
            _ =&gt; Err(PipelineError::UnsupportedAlgorithm(
                algorithm.name().to_string()
            )),
        }
    }

    async fn decompress(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
        // Similar implementation for decompression
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Wraps external libraries (brotli, zstd, lz4)</li>
<li>Implements domain interface</li>
<li>Handles library-specific details</li>
<li>Can be swapped for different implementations</li>
</ul>
<h2 id="benefits-of-hexagonal-architecture"><a class="header" href="#benefits-of-hexagonal-architecture">Benefits of Hexagonal Architecture</a></h2>
<h3 id="1-testability-1"><a class="header" href="#1-testability-1">1. Testability</a></h3>
<p>You can test the domain in isolation using mock adapters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mock adapter for testing
struct MockPipelineRepository {
    pipelines: Mutex&lt;HashMap&lt;PipelineId, Pipeline&gt;&gt;,
}

#[async_trait]
impl PipelineRepository for MockPipelineRepository {
    async fn create(&amp;self, pipeline: &amp;Pipeline) -&gt; Result&lt;(), PipelineError&gt; {
        self.pipelines.lock().unwrap()
            .insert(pipeline.id().clone(), pipeline.clone());
        Ok(())
    }

    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;, PipelineError&gt; {
        Ok(self.pipelines.lock().unwrap().get(id).cloned())
    }
}

#[tokio::test]
async fn test_file_processor_service() {
    // Use mock adapter instead of real database
    let repo = Arc::new(MockPipelineRepository::new());
    let service = FileProcessorService::new(repo);

    // Test domain logic without database
    let result = service.process_file(/* ... */).await;
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-flexibility-1"><a class="header" href="#2-flexibility-1">2. Flexibility</a></h3>
<p>Swap implementations without changing the domain:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start with SQLite
let repo: Arc&lt;dyn PipelineRepository&gt; =
    Arc::new(SQLitePipelineRepository::new(pool));

// Later, switch to PostgreSQL
let repo: Arc&lt;dyn PipelineRepository&gt; =
    Arc::new(PostgresPipelineRepository::new(pool));

// Domain doesn't change - same interface!
let service = FileProcessorService::new(repo);
<span class="boring">}</span></code></pre></pre>
<h3 id="3-multiple-interfaces"><a class="header" href="#3-multiple-interfaces">3. Multiple Interfaces</a></h3>
<p>Support multiple input sources using the same domain:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CLI adapter
async fn cli_handler(cli: Cli, services: Arc&lt;Services&gt;) {
    services.file_processor.process_file(/* ... */).await?;
}

// HTTP adapter
async fn http_handler(req: HttpRequest, services: Arc&lt;Services&gt;) {
    services.file_processor.process_file(/* ... */).await?;
}

// gRPC adapter
async fn grpc_handler(req: GrpcRequest, services: Arc&lt;Services&gt;) {
    services.file_processor.process_file(/* ... */).await?;
}
<span class="boring">}</span></code></pre></pre>
<p>All three adapters use the <strong>same domain logic</strong> through the <strong>same port</strong>.</p>
<h3 id="4-technology-independence"><a class="header" href="#4-technology-independence">4. Technology Independence</a></h3>
<p>The domain doesn't depend on specific technologies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Domain doesn't know about:
// - SQLite, PostgreSQL, or MongoDB
// - HTTP, gRPC, or CLI
// - Brotli, Zstd, or LZ4
// - Any specific framework or library

// It only knows about:
// - Business concepts (Pipeline, Stage, Chunk)
// - Business rules (validation, ordering)
// - Interfaces it needs (Repository, CompressionService)
<span class="boring">}</span></code></pre></pre>
<h2 id="dependency-inversion-1"><a class="header" href="#dependency-inversion-1">Dependency Inversion</a></h2>
<p>Hexagonal Architecture relies on <strong>Dependency Inversion Principle</strong>:</p>
<pre><code class="language-text">Traditional:                    Hexagonal:

┌──────────┐                   ┌──────────┐
│   CLI    │                   │   CLI    │
└────┬─────┘                   └────┬─────┘
     │ depends on                   │ depends on
     ▼                              ▼
┌──────────┐                   ┌──────────┐
│ Domain   │                   │  Port    │ ← Interface
└────┬─────┘                   │ (trait)  │
     │ depends on               └────△─────┘
     ▼                               │ implements
┌──────────┐                   ┌────┴─────┐
│ Database │                   │  Domain  │
└──────────┘                   └──────────┘
                                     △
                                     │ implements
                               ┌─────┴─────┐
                               │ Database  │
                               │ Adapter   │
                               └───────────┘
</code></pre>
<p><strong>Traditional:</strong> Domain depends on Database (tight coupling)
<strong>Hexagonal:</strong> Database depends on Domain interface (loose coupling)</p>
<h2 id="our-adapter-structure"><a class="header" href="#our-adapter-structure">Our Adapter Structure</a></h2>
<pre><code class="language-text">pipeline/src/
├── infrastructure/
│   └── adapters/
│       ├── compression_service_adapter.rs    # Implements CompressionService
│       ├── encryption_service_adapter.rs     # Implements EncryptionService
│       ├── async_compression_adapter.rs      # Async wrapper
│       ├── async_encryption_adapter.rs       # Async wrapper
│       └── repositories/
│           ├── sqlite_repository_adapter.rs  # Implements PipelineRepository
│           └── sqlite_base_repository.rs     # Base repository utilities
</code></pre>
<h2 id="adapter-responsibilities"><a class="header" href="#adapter-responsibilities">Adapter Responsibilities</a></h2>
<h3 id="what-adapters-should-do"><a class="header" href="#what-adapters-should-do">What Adapters Should Do</a></h3>
<p>✅ <strong>Translate</strong> between domain and external systems
✅ <strong>Handle</strong> technology-specific details
✅ <strong>Implement</strong> domain-defined interfaces
✅ <strong>Convert</strong> data formats (domain ↔ database, domain ↔ API)
✅ <strong>Manage</strong> external resources (connections, files, etc.)</p>
<h3 id="what-adapters-should-not-do"><a class="header" href="#what-adapters-should-not-do">What Adapters Should NOT Do</a></h3>
<p>❌ <strong>Contain business logic</strong> - belongs in domain
❌ <strong>Make business decisions</strong> - belongs in domain
❌ <strong>Validate business rules</strong> - belongs in domain
❌ <strong>Know about other adapters</strong> - should be independent
❌ <strong>Expose infrastructure details</strong> to domain</p>
<h2 id="example-complete-flow"><a class="header" href="#example-complete-flow">Example: Complete Flow</a></h2>
<p>Let's trace a complete request through the hexagonal architecture:</p>
<pre><code class="language-text">1. Primary Adapter (CLI)
   ↓ User types: pipeline process --input file.txt --output file.bin

2. Parse and validate input
   ↓ Create FilePath("/path/to/file.txt")

3. Call Primary Port (FileProcessorService)
   ↓ process_file(pipeline_id, input_path, output_path)

4. Domain Logic
   ├─ Fetch Pipeline (via PipelineRepository port)
   │  └─ Secondary Adapter queries SQLite
   ├─ Process each stage
   │  ├─ Compress (via CompressionService port)
   │  │  └─ Secondary Adapter uses brotli library
   │  ├─ Encrypt (via EncryptionService port)
   │  │  └─ Secondary Adapter uses aes-gcm library
   │  └─ Calculate checksum (via ChecksumService port)
   │     └─ Secondary Adapter uses sha2 library
   └─ Return ProcessingMetrics

5. Primary Adapter formats output
   ↓ Display metrics to user
</code></pre>
<h2 id="common-adapter-patterns"><a class="header" href="#common-adapter-patterns">Common Adapter Patterns</a></h2>
<h3 id="repository-adapter-pattern"><a class="header" href="#repository-adapter-pattern">Repository Adapter Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Domain defines interface (port)
pub trait PipelineRepository: Send + Sync {
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;&gt;;
}

// 2. Infrastructure implements adapter
pub struct SQLitePipelineRepository { /* ... */ }

impl PipelineRepository for SQLitePipelineRepository {
    async fn find_by_id(&amp;self, id: &amp;PipelineId) -&gt; Result&lt;Option&lt;Pipeline&gt;&gt; {
        // Database-specific implementation
    }
}

// 3. Application uses through interface
pub struct FileProcessorService {
    repository: Arc&lt;dyn PipelineRepository&gt;,  // Uses interface, not concrete type
}
<span class="boring">}</span></code></pre></pre>
<h3 id="service-adapter-pattern"><a class="header" href="#service-adapter-pattern">Service Adapter Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Domain defines interface
pub trait CompressionService: Send + Sync {
    async fn compress(&amp;self, data: &amp;[u8], algo: &amp;Algorithm) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
}

// 2. Infrastructure implements adapter
pub struct CompressionServiceAdapter { /* ... */ }

impl CompressionService for CompressionServiceAdapter {
    async fn compress(&amp;self, data: &amp;[u8], algo: &amp;Algorithm) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        // Library-specific implementation
    }
}

// 3. Application uses through interface
pub struct StageExecutor {
    compression: Arc&lt;dyn CompressionService&gt;,  // Uses interface
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-with-adapters"><a class="header" href="#testing-with-adapters">Testing with Adapters</a></h2>
<h3 id="unit-tests-domain-layer"><a class="header" href="#unit-tests-domain-layer">Unit Tests (Domain Layer)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test domain logic without any adapters
#[test]
fn test_pipeline_validation() {
    // Pure domain logic - no infrastructure needed
    let result = Pipeline::new("test", vec![]);
    assert!(result.is_err());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests-with-mock-adapters"><a class="header" href="#integration-tests-with-mock-adapters">Integration Tests (With Mock Adapters)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_file_processing() {
    // Use mock adapters
    let mock_repo = Arc::new(MockPipelineRepository::new());
    let mock_compression = Arc::new(MockCompressionService::new());

    let service = FileProcessorService::new(mock_repo, mock_compression);

    // Test without real database or compression
    let result = service.process_file(/* ... */).await;
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="end-to-end-tests-with-real-adapters"><a class="header" href="#end-to-end-tests-with-real-adapters">End-to-End Tests (With Real Adapters)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_real_file_processing() {
    // Use real adapters
    let db_pool = create_test_database().await;
    let real_repo = Arc::new(SQLitePipelineRepository::new(db_pool));
    let real_compression = Arc::new(CompressionServiceAdapter::new());

    let service = FileProcessorService::new(real_repo, real_compression);

    // Test with real infrastructure
    let result = service.process_file(/* ... */).await;
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<p>Now that you understand hexagonal architecture:</p>
<ul>
<li><a href="architecture/dependencies.html">Dependency Inversion</a> - Managing dependencies properly</li>
<li><a href="architecture/layers.html">Layered Architecture</a> - How layers relate to ports/adapters</li>
<li><a href="architecture/repository-pattern.html">Repository Pattern</a> - Detailed repository implementation</li>
<li><a href="architecture/domain-model.html">Domain Model</a> - Understanding the core domain</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observer-pattern"><a class="header" href="#observer-pattern">Observer Pattern</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>The Observer pattern for metrics and events.</p>
<h2 id="pattern-overview-3"><a class="header" href="#pattern-overview-3">Pattern Overview</a></h2>
<p>TODO: Extract from metrics observer</p>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>TODO: Show implementation</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>TODO: List use cases</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-processing"><a class="header" href="#stage-processing">Stage Processing</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>How stages process data in the pipeline.</p>
<h2 id="stage-lifecycle"><a class="header" href="#stage-lifecycle">Stage Lifecycle</a></h2>
<p>TODO: Explain stage lifecycle</p>
<h2 id="stage-interface"><a class="header" href="#stage-interface">Stage Interface</a></h2>
<p>TODO: Show stage trait</p>
<h2 id="stage-execution"><a class="header" href="#stage-execution">Stage Execution</a></h2>
<p>TODO: Explain execution model</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compression"><a class="header" href="#compression">Compression</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Compression algorithms and implementation.</p>
<h2 id="supported-algorithms"><a class="header" href="#supported-algorithms">Supported Algorithms</a></h2>
<p>TODO: Extract from compression service</p>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<p>TODO: Add performance data</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>TODO: Show configuration</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encryption"><a class="header" href="#encryption">Encryption</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Encryption algorithms and security.</p>
<h2 id="supported-algorithms-1"><a class="header" href="#supported-algorithms-1">Supported Algorithms</a></h2>
<p>TODO: Extract from encryption service</p>
<h2 id="key-management"><a class="header" href="#key-management">Key Management</a></h2>
<p>TODO: Explain key management</p>
<h2 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h2>
<p>TODO: Add security guidance</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrity-checking"><a class="header" href="#integrity-checking">Integrity Checking</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Data integrity verification.</p>
<h2 id="checksum-algorithms"><a class="header" href="#checksum-algorithms">Checksum Algorithms</a></h2>
<p>TODO: Extract from checksum service</p>
<h2 id="verification-process"><a class="header" href="#verification-process">Verification Process</a></h2>
<p>TODO: Explain verification</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>TODO: Show error handling</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-persistence"><a class="header" href="#data-persistence">Data Persistence</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>How data is persisted to storage.</p>
<h2 id="storage-architecture"><a class="header" href="#storage-architecture">Storage Architecture</a></h2>
<p>TODO: Explain storage design</p>
<h2 id="database-choice"><a class="header" href="#database-choice">Database Choice</a></h2>
<p>TODO: Explain SQLite usage</p>
<h2 id="transaction-management"><a class="header" href="#transaction-management">Transaction Management</a></h2>
<p>TODO: Explain transactions</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repository-implementation"><a class="header" href="#repository-implementation">Repository Implementation</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Concrete repository implementations.</p>
<h2 id="sqlite-repository"><a class="header" href="#sqlite-repository">SQLite Repository</a></h2>
<p>TODO: Extract from sqlite_pipeline_repository.rs</p>
<h2 id="crud-operations"><a class="header" href="#crud-operations">CRUD Operations</a></h2>
<p>TODO: Show CRUD examples</p>
<h2 id="query-patterns"><a class="header" href="#query-patterns">Query Patterns</a></h2>
<p>TODO: Show query patterns</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema-management"><a class="header" href="#schema-management">Schema Management</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Database schema and migrations.</p>
<h2 id="schema-design"><a class="header" href="#schema-design">Schema Design</a></h2>
<p>TODO: Show database schema</p>
<h2 id="migrations"><a class="header" href="#migrations">Migrations</a></h2>
<p>TODO: Explain sqlx migrations</p>
<h2 id="version-management"><a class="header" href="#version-management">Version Management</a></h2>
<p>TODO: Explain versioning</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-io"><a class="header" href="#file-io">File I/O</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>File input/output operations.</p>
<h2 id="file-reading"><a class="header" href="#file-reading">File Reading</a></h2>
<p>TODO: Extract from file_io_service.rs</p>
<h2 id="file-writing"><a class="header" href="#file-writing">File Writing</a></h2>
<p>TODO: Show writing patterns</p>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>TODO: Show error handling</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chunking-strategy"><a class="header" href="#chunking-strategy">Chunking Strategy</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>How files are split into chunks for processing.</p>
<h2 id="chunk-size-1"><a class="header" href="#chunk-size-1">Chunk Size</a></h2>
<p>TODO: Explain chunk sizing</p>
<h2 id="chunk-processing"><a class="header" href="#chunk-processing">Chunk Processing</a></h2>
<p>TODO: Show chunk processing</p>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<p>TODO: Explain memory efficiency</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-format"><a class="header" href="#binary-format">Binary Format</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>The binary file format specification.</p>
<h2 id="format-overview"><a class="header" href="#format-overview">Format Overview</a></h2>
<p>TODO: Extract from binary_file_format.rs</p>
<h2 id="format-versioning"><a class="header" href="#format-versioning">Format Versioning</a></h2>
<p>TODO: Explain versioning</p>
<h2 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards Compatibility</a></h2>
<p>TODO: Explain compatibility</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observability"><a class="header" href="#observability">Observability</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Observability architecture and implementation.</p>
<h2 id="observability-overview"><a class="header" href="#observability-overview">Observability Overview</a></h2>
<p>TODO: Extract from observability_service.rs</p>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<p>TODO: Link to metrics chapter</p>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>TODO: Link to logging chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>How metrics are collected and exposed.</p>
<h2 id="metrics-architecture"><a class="header" href="#metrics-architecture">Metrics Architecture</a></h2>
<p>TODO: Extract from metrics files</p>
<h2 id="prometheus-integration"><a class="header" href="#prometheus-integration">Prometheus Integration</a></h2>
<p>TODO: Show Prometheus integration</p>
<h2 id="available-metrics"><a class="header" href="#available-metrics">Available Metrics</a></h2>
<p>TODO: List available metrics</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-1"><a class="header" href="#logging-1">Logging</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Logging implementation and best practices.</p>
<h2 id="logging-framework"><a class="header" href="#logging-framework">Logging Framework</a></h2>
<p>TODO: Explain tracing usage</p>
<h2 id="log-levels"><a class="header" href="#log-levels">Log Levels</a></h2>
<p>TODO: Explain log levels</p>
<h2 id="structured-logging"><a class="header" href="#structured-logging">Structured Logging</a></h2>
<p>TODO: Show structured logging</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-model"><a class="header" href="#concurrency-model">Concurrency Model</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Understanding the concurrency model.</p>
<h2 id="asyncawait"><a class="header" href="#asyncawait">Async/Await</a></h2>
<p>TODO: Explain async usage</p>
<h2 id="tokio-runtime"><a class="header" href="#tokio-runtime">Tokio Runtime</a></h2>
<p>TODO: Explain Tokio integration</p>
<h2 id="concurrency-patterns"><a class="header" href="#concurrency-patterns">Concurrency Patterns</a></h2>
<p>TODO: Show patterns</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thread-pooling"><a class="header" href="#thread-pooling">Thread Pooling</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Thread pool configuration and tuning.</p>
<h2 id="thread-pool-architecture"><a class="header" href="#thread-pool-architecture">Thread Pool Architecture</a></h2>
<p>TODO: Explain thread pooling</p>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>TODO: Show configuration</p>
<h2 id="tuning-guidelines"><a class="header" href="#tuning-guidelines">Tuning Guidelines</a></h2>
<p>TODO: Add tuning guidance</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Managing system resources efficiently.</p>
<h2 id="memory-management-1"><a class="header" href="#memory-management-1">Memory Management</a></h2>
<p>TODO: Explain memory usage</p>
<h2 id="file-descriptors"><a class="header" href="#file-descriptors">File Descriptors</a></h2>
<p>TODO: Explain FD management</p>
<h2 id="resource-limits"><a class="header" href="#resource-limits">Resource Limits</a></h2>
<p>TODO: Show limits and tuning</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Performance optimization techniques.</p>
<h2 id="optimization-strategies"><a class="header" href="#optimization-strategies">Optimization Strategies</a></h2>
<p>TODO: List strategies</p>
<h2 id="common-bottlenecks"><a class="header" href="#common-bottlenecks">Common Bottlenecks</a></h2>
<p>TODO: Identify bottlenecks</p>
<h2 id="tuning-parameters"><a class="header" href="#tuning-parameters">Tuning Parameters</a></h2>
<p>TODO: Show tuning options</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Benchmarking the pipeline.</p>
<h2 id="benchmark-suite"><a class="header" href="#benchmark-suite">Benchmark Suite</a></h2>
<p>TODO: Show benchmark suite</p>
<h2 id="running-benchmarks"><a class="header" href="#running-benchmarks">Running Benchmarks</a></h2>
<p>TODO: Show how to run</p>
<h2 id="interpreting-results"><a class="header" href="#interpreting-results">Interpreting Results</a></h2>
<p>TODO: Explain results</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiling"><a class="header" href="#profiling">Profiling</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Profiling tools and techniques.</p>
<h2 id="profiling-tools"><a class="header" href="#profiling-tools">Profiling Tools</a></h2>
<p>TODO: List tools (flamegraph, perf, etc.)</p>
<h2 id="cpu-profiling"><a class="header" href="#cpu-profiling">CPU Profiling</a></h2>
<p>TODO: Show CPU profiling</p>
<h2 id="memory-profiling"><a class="header" href="#memory-profiling">Memory Profiling</a></h2>
<p>TODO: Show memory profiling</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extending-the-pipeline"><a class="header" href="#extending-the-pipeline">Extending the Pipeline</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>How to extend the pipeline with custom functionality.</p>
<h2 id="extension-points"><a class="header" href="#extension-points">Extension Points</a></h2>
<p>TODO: List extension points</p>
<h2 id="plugin-architecture"><a class="header" href="#plugin-architecture">Plugin Architecture</a></h2>
<p>TODO: Explain plugin system (if any)</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>TODO: Add guidance</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-stages"><a class="header" href="#custom-stages">Custom Stages</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Creating custom pipeline stages.</p>
<h2 id="stage-interface-1"><a class="header" href="#stage-interface-1">Stage Interface</a></h2>
<p>TODO: Show stage trait</p>
<h2 id="implementation-example"><a class="header" href="#implementation-example">Implementation Example</a></h2>
<p>TODO: Show complete example</p>
<h2 id="testing-custom-stages"><a class="header" href="#testing-custom-stages">Testing Custom Stages</a></h2>
<p>TODO: Show testing approach</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-algorithms"><a class="header" href="#custom-algorithms">Custom Algorithms</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Adding custom compression or encryption algorithms.</p>
<h2 id="algorithm-interface"><a class="header" href="#algorithm-interface">Algorithm Interface</a></h2>
<p>TODO: Show algorithm trait</p>
<h2 id="compression-example"><a class="header" href="#compression-example">Compression Example</a></h2>
<p>TODO: Show compression algorithm</p>
<h2 id="encryption-example"><a class="header" href="#encryption-example">Encryption Example</a></h2>
<p>TODO: Show encryption algorithm</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-requirements-specification"><a class="header" href="#software-requirements-specification">Software Requirements Specification</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Comprehensive software requirements specification.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>TODO: Add SRS introduction</p>
<h2 id="functional-requirements"><a class="header" href="#functional-requirements">Functional Requirements</a></h2>
<p>TODO: List functional requirements</p>
<h2 id="non-functional-requirements"><a class="header" href="#non-functional-requirements">Non-Functional Requirements</a></h2>
<p>TODO: List non-functional requirements</p>
<h2 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h2>
<p>TODO: List system requirements</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-design-document"><a class="header" href="#software-design-document">Software Design Document</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Comprehensive software design document.</p>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>TODO: Add SDD introduction</p>
<h2 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h2>
<p>TODO: Add detailed architecture</p>
<h2 id="component-design"><a class="header" href="#component-design">Component Design</a></h2>
<p>TODO: Add component designs</p>
<h2 id="data-design"><a class="header" href="#data-design">Data Design</a></h2>
<p>TODO: Add data models</p>
<h2 id="interface-design"><a class="header" href="#interface-design">Interface Design</a></h2>
<p>TODO: Add interface specifications</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-test-plan"><a class="header" href="#software-test-plan">Software Test Plan</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Software test plan and strategy.</p>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>TODO: Add STP introduction</p>
<h2 id="test-strategy"><a class="header" href="#test-strategy">Test Strategy</a></h2>
<p>TODO: Add test strategy</p>
<h2 id="test-levels"><a class="header" href="#test-levels">Test Levels</a></h2>
<p>TODO: List test levels (unit, integration, system)</p>
<h2 id="test-cases"><a class="header" href="#test-cases">Test Cases</a></h2>
<p>TODO: Add key test cases</p>
<h2 id="test-environment"><a class="header" href="#test-environment">Test Environment</a></h2>
<p>TODO: Describe test environment</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-api-reference"><a class="header" href="#public-api-reference">Public API Reference</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Public API documentation and examples.</p>
<h2 id="api-overview"><a class="header" href="#api-overview">API Overview</a></h2>
<p>TODO: Add API overview</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<p>TODO: List core public types</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>TODO: Add usage examples</p>
<h2 id="generated-documentation"><a class="header" href="#generated-documentation">Generated Documentation</a></h2>
<p>See <a href="api/../../../target/doc/pipeline/index.html">rustdoc API documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-apis"><a class="header" href="#internal-apis">Internal APIs</a></h1>
<p><strong>Version:</strong> 0.1.0
<strong>Date:</strong> October 2025
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner
<strong>Status:</strong> Draft</p>
<p>Internal API documentation for contributors.</p>
<h2 id="internal-architecture"><a class="header" href="#internal-architecture">Internal Architecture</a></h2>
<p>TODO: Add internal API overview</p>
<h2 id="module-organization"><a class="header" href="#module-organization">Module Organization</a></h2>
<p>TODO: Explain module structure</p>
<h2 id="extension-points-1"><a class="header" href="#extension-points-1">Extension Points</a></h2>
<p>TODO: List internal extension points</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
