<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Encryption - Pipeline Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pipeline Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="encryption-implementation"><a class="header" href="#encryption-implementation">Encryption Implementation</a></h1>
<p><strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-01-04
<strong>SPDX-License-Identifier:</strong> BSD-3-Clause
<strong>License File:</strong> See the LICENSE file in the project root.
<strong>Copyright:</strong> © 2025 Michael Gardner, A Bit of Help, Inc.
<strong>Authors:</strong> Michael Gardner, Claude Code
<strong>Status:</strong> Active</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The encryption service provides authenticated encryption with multiple algorithms, secure key management, and automatic integrity verification. It's implemented as an infrastructure adapter that implements the domain's <code>EncryptionService</code> trait.</p>
<p><strong>File:</strong> <code>pipeline/src/infrastructure/adapters/encryption_service_adapter.rs</code></p>
<h2 id="supported-algorithms"><a class="header" href="#supported-algorithms">Supported Algorithms</a></h2>
<h3 id="aes-256-gcm-advanced-encryption-standard"><a class="header" href="#aes-256-gcm-advanced-encryption-standard">AES-256-GCM (Advanced Encryption Standard)</a></h3>
<ul>
<li><strong>Key size:</strong> 256 bits (32 bytes)</li>
<li><strong>Nonce size:</strong> 96 bits (12 bytes)</li>
<li><strong>Security:</strong> Industry standard, FIPS 140-2 approved</li>
<li><strong>Performance:</strong> Excellent with AES-NI hardware acceleration</li>
<li><strong>Library:</strong> <code>aes-gcm</code> crate</li>
</ul>
<p><strong>Best for:</strong></p>
<ul>
<li>Compliance requirements (FIPS, government)</li>
<li>Systems with AES-NI support</li>
<li>Maximum security requirements</li>
<li>Long-term data protection</li>
</ul>
<p><strong>Performance characteristics:</strong></p>
<pre><code class="language-text">Operation   | With AES-NI | Without AES-NI
------------|-------------|----------------
Encryption  | 2-3 GB/s    | 100-200 MB/s
Decryption  | 2-3 GB/s    | 100-200 MB/s
Key setup   | &lt; 1 μs      | &lt; 1 μs
Memory      | Low         | Low
</code></pre>
<h3 id="chacha20-poly1305-stream-cipher"><a class="header" href="#chacha20-poly1305-stream-cipher">ChaCha20-Poly1305 (Stream Cipher)</a></h3>
<ul>
<li><strong>Key size:</strong> 256 bits (32 bytes)</li>
<li><strong>Nonce size:</strong> 96 bits (12 bytes)</li>
<li><strong>Security:</strong> Modern, constant-time implementation</li>
<li><strong>Performance:</strong> Consistent across all platforms</li>
<li><strong>Library:</strong> <code>chacha20poly1305</code> crate</li>
</ul>
<p><strong>Best for:</strong></p>
<ul>
<li>Systems without AES-NI</li>
<li>Mobile/embedded devices</li>
<li>Constant-time requirements</li>
<li>Side-channel attack resistance</li>
</ul>
<p><strong>Performance characteristics:</strong></p>
<pre><code class="language-text">Operation   | Any Platform
------------|-------------
Encryption  | 500-800 MB/s
Decryption  | 500-800 MB/s
Key setup   | &lt; 1 μs
Memory      | Low
</code></pre>
<h3 id="aes-128-gcm-faster-aes-variant"><a class="header" href="#aes-128-gcm-faster-aes-variant">AES-128-GCM (Faster AES Variant)</a></h3>
<ul>
<li><strong>Key size:</strong> 128 bits (16 bytes)</li>
<li><strong>Nonce size:</strong> 96 bits (12 bytes)</li>
<li><strong>Security:</strong> Very secure, faster than AES-256</li>
<li><strong>Performance:</strong> ~30% faster than AES-256</li>
<li><strong>Library:</strong> <code>aes-gcm</code> crate</li>
</ul>
<p><strong>Best for:</strong></p>
<ul>
<li>High-performance requirements</li>
<li>Short-term data protection</li>
<li>Real-time encryption</li>
<li>Bandwidth-constrained systems</li>
</ul>
<p><strong>Performance characteristics:</strong></p>
<pre><code class="language-text">Operation   | With AES-NI | Without AES-NI
------------|-------------|----------------
Encryption  | 3-4 GB/s    | 150-250 MB/s
Decryption  | 3-4 GB/s    | 150-250 MB/s
Key setup   | &lt; 1 μs      | &lt; 1 μs
Memory      | Low         | Low
</code></pre>
<h2 id="security-features"><a class="header" href="#security-features">Security Features</a></h2>
<h3 id="authenticated-encryption-aead"><a class="header" href="#authenticated-encryption-aead">Authenticated Encryption (AEAD)</a></h3>
<p>All algorithms provide Authenticated Encryption with Associated Data (AEAD):</p>
<pre><code class="language-text">Plaintext → Encrypt → Ciphertext + Authentication Tag
                ↓
            Detects tampering
</code></pre>
<p><strong>Properties:</strong></p>
<ul>
<li><strong>Confidentiality:</strong> Data is encrypted and unreadable</li>
<li><strong>Integrity:</strong> Any modification is detected</li>
<li><strong>Authentication:</strong> Verifies data origin</li>
</ul>
<h3 id="nonce-management"><a class="header" href="#nonce-management">Nonce Management</a></h3>
<p>Each encryption operation requires a unique nonce (number used once):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Nonces are automatically generated for each chunk
pub struct EncryptionContext {
    key: SecretKey,
    nonce_counter: AtomicU64,  // Incrementing counter
}

impl EncryptionContext {
    fn next_nonce(&amp;self) -&gt; Nonce {
        let counter = self.nonce_counter.fetch_add(1, Ordering::SeqCst);

        // Generate nonce from counter
        let mut nonce = [0u8; 12];
        nonce[0..8].copy_from_slice(&amp;counter.to_le_bytes());

        Nonce::from_slice(&amp;nonce)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Important:</strong> Never reuse a nonce with the same key!</p>
<h3 id="key-derivation"><a class="header" href="#key-derivation">Key Derivation</a></h3>
<p>Derive encryption keys from passwords using secure KDFs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum KeyDerivationFunction {
    Argon2,   // Memory-hard, GPU-resistant
    Scrypt,   // Memory-hard, tunable
    PBKDF2,   // Standard, widely supported
}

// Derive key from password
pub fn derive_key(
    password: &amp;[u8],
    salt: &amp;[u8],
    kdf: KeyDerivationFunction,
) -&gt; Result&lt;SecretKey, PipelineError&gt; {
    match kdf {
        KeyDerivationFunction::Argon2 =&gt; {
            // Memory: 64 MB, Iterations: 3, Parallelism: 4
            argon2::hash_raw(password, salt, &amp;argon2::Config::default())
        }
        KeyDerivationFunction::Scrypt =&gt; {
            // N=16384, r=8, p=1
            scrypt::scrypt(password, salt, &amp;scrypt::Params::new(14, 8, 1)?)
        }
        KeyDerivationFunction::PBKDF2 =&gt; {
            // 100,000 iterations
            pbkdf2::pbkdf2_hmac::&lt;sha2::Sha256&gt;(password, salt, 100_000)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<h3 id="service-interface-domain-layer"><a class="header" href="#service-interface-domain-layer">Service Interface (Domain Layer)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// pipeline-domain/src/services/encryption_service.rs
use async_trait::async_trait;
use crate::value_objects::Algorithm;
use crate::error::PipelineError;

#[async_trait]
pub trait EncryptionService: Send + Sync {
    /// Encrypt data using the specified algorithm
    async fn encrypt(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;EncryptedData, PipelineError&gt;;

    /// Decrypt data using the specified algorithm
    async fn decrypt(
        &amp;self,
        encrypted: &amp;EncryptedData,
        algorithm: &amp;Algorithm,
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt;;
}

/// Encrypted data with nonce and authentication tag
pub struct EncryptedData {
    pub ciphertext: Vec&lt;u8&gt;,
    pub nonce: Vec&lt;u8&gt;,        // 12 bytes
    pub tag: Vec&lt;u8&gt;,          // 16 bytes (authentication tag)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="service-implementation-infrastructure-layer"><a class="header" href="#service-implementation-infrastructure-layer">Service Implementation (Infrastructure Layer)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// pipeline/src/infrastructure/adapters/encryption_service_adapter.rs
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};
use chacha20poly1305::ChaCha20Poly1305;

pub struct EncryptionServiceAdapter {
    // Secure key storage
    key_store: Arc&lt;RwLock&lt;KeyStore&gt;&gt;,
}

#[async_trait]
impl EncryptionService for EncryptionServiceAdapter {
    async fn encrypt(
        &amp;self,
        data: &amp;[u8],
        algorithm: &amp;Algorithm,
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;EncryptedData, PipelineError&gt; {
        match algorithm.name() {
            "aes-256-gcm" =&gt; self.encrypt_aes_256_gcm(data, key),
            "chacha20-poly1305" =&gt; self.encrypt_chacha20(data, key),
            "aes-128-gcm" =&gt; self.encrypt_aes_128_gcm(data, key),
            _ =&gt; Err(PipelineError::UnsupportedAlgorithm(
                algorithm.name().to_string()
            )),
        }
    }

    async fn decrypt(
        &amp;self,
        encrypted: &amp;EncryptedData,
        algorithm: &amp;Algorithm,
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
        match algorithm.name() {
            "aes-256-gcm" =&gt; self.decrypt_aes_256_gcm(encrypted, key),
            "chacha20-poly1305" =&gt; self.decrypt_chacha20(encrypted, key),
            "aes-128-gcm" =&gt; self.decrypt_aes_128_gcm(encrypted, key),
            _ =&gt; Err(PipelineError::UnsupportedAlgorithm(
                algorithm.name().to_string()
            )),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="algorithm-implementations"><a class="header" href="#algorithm-implementations">Algorithm Implementations</a></h2>
<h3 id="aes-256-gcm-implementation"><a class="header" href="#aes-256-gcm-implementation">AES-256-GCM Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EncryptionServiceAdapter {
    fn encrypt_aes_256_gcm(
        &amp;self,
        data: &amp;[u8],
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;EncryptedData, PipelineError&gt; {
        use aes_gcm::{Aes256Gcm, Key, Nonce};
        use aes_gcm::aead::{Aead, NewAead};

        // Create cipher from key
        let key = Key::from_slice(key.as_bytes());
        let cipher = Aes256Gcm::new(key);

        // Generate unique nonce
        let nonce = self.generate_nonce();
        let nonce_obj = Nonce::from_slice(&amp;nonce);

        // Encrypt with authentication
        let ciphertext = cipher
            .encrypt(nonce_obj, data)
            .map_err(|e| PipelineError::EncryptionError(e.to_string()))?;

        // Split ciphertext and tag
        let (ciphertext_bytes, tag) = ciphertext.split_at(ciphertext.len() - 16);

        Ok(EncryptedData {
            ciphertext: ciphertext_bytes.to_vec(),
            nonce: nonce.to_vec(),
            tag: tag.to_vec(),
        })
    }

    fn decrypt_aes_256_gcm(
        &amp;self,
        encrypted: &amp;EncryptedData,
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
        use aes_gcm::{Aes256Gcm, Key, Nonce};
        use aes_gcm::aead::{Aead, NewAead};

        // Create cipher from key
        let key = Key::from_slice(key.as_bytes());
        let cipher = Aes256Gcm::new(key);

        // Reconstruct nonce
        let nonce = Nonce::from_slice(&amp;encrypted.nonce);

        // Combine ciphertext and tag
        let mut combined = encrypted.ciphertext.clone();
        combined.extend_from_slice(&amp;encrypted.tag);

        // Decrypt and verify authentication
        let plaintext = cipher
            .decrypt(nonce, combined.as_slice())
            .map_err(|e| PipelineError::DecryptionError(
                format!("Decryption failed (possibly tampered): {}", e)
            ))?;

        Ok(plaintext)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="chacha20-poly1305-implementation"><a class="header" href="#chacha20-poly1305-implementation">ChaCha20-Poly1305 Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EncryptionServiceAdapter {
    fn encrypt_chacha20(
        &amp;self,
        data: &amp;[u8],
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;EncryptedData, PipelineError&gt; {
        use chacha20poly1305::{ChaCha20Poly1305, Key, Nonce};
        use chacha20poly1305::aead::{Aead, NewAead};

        // Create cipher from key
        let key = Key::from_slice(key.as_bytes());
        let cipher = ChaCha20Poly1305::new(key);

        // Generate unique nonce
        let nonce = self.generate_nonce();
        let nonce_obj = Nonce::from_slice(&amp;nonce);

        // Encrypt with authentication
        let ciphertext = cipher
            .encrypt(nonce_obj, data)
            .map_err(|e| PipelineError::EncryptionError(e.to_string()))?;

        // Split ciphertext and tag
        let (ciphertext_bytes, tag) = ciphertext.split_at(ciphertext.len() - 16);

        Ok(EncryptedData {
            ciphertext: ciphertext_bytes.to_vec(),
            nonce: nonce.to_vec(),
            tag: tag.to_vec(),
        })
    }

    fn decrypt_chacha20(
        &amp;self,
        encrypted: &amp;EncryptedData,
        key: &amp;EncryptionKey,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
        use chacha20poly1305::{ChaCha20Poly1305, Key, Nonce};
        use chacha20poly1305::aead::{Aead, NewAead};

        // Create cipher from key
        let key = Key::from_slice(key.as_bytes());
        let cipher = ChaCha20Poly1305::new(key);

        // Reconstruct nonce
        let nonce = Nonce::from_slice(&amp;encrypted.nonce);

        // Combine ciphertext and tag
        let mut combined = encrypted.ciphertext.clone();
        combined.extend_from_slice(&amp;encrypted.tag);

        // Decrypt and verify authentication
        let plaintext = cipher
            .decrypt(nonce, combined.as_slice())
            .map_err(|e| PipelineError::DecryptionError(
                format!("Decryption failed (possibly tampered): {}", e)
            ))?;

        Ok(plaintext)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-management"><a class="header" href="#key-management">Key Management</a></h2>
<h3 id="secure-key-storage"><a class="header" href="#secure-key-storage">Secure Key Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use zeroize::Zeroize;

/// Secure key that zeroizes on drop
pub struct SecretKey {
    bytes: Vec&lt;u8&gt;,
}

impl SecretKey {
    pub fn new(bytes: Vec&lt;u8&gt;) -&gt; Self {
        Self { bytes }
    }

    pub fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        &amp;self.bytes
    }

    /// Generate random key
    pub fn generate(size: usize) -&gt; Self {
        use rand::RngCore;
        let mut bytes = vec![0u8; size];
        rand::thread_rng().fill_bytes(&amp;mut bytes);
        Self::new(bytes)
    }
}

impl Drop for SecretKey {
    fn drop(&amp;mut self) {
        // Securely wipe key from memory
        self.bytes.zeroize();
    }
}

impl Zeroize for SecretKey {
    fn zeroize(&amp;mut self) {
        self.bytes.zeroize();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-rotation"><a class="header" href="#key-rotation">Key Rotation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct KeyRotation {
    current_key: SecretKey,
    previous_key: Option&lt;SecretKey&gt;,
    rotation_interval: Duration,
    last_rotation: Instant,
}

impl KeyRotation {
    pub fn rotate(&amp;mut self) -&gt; Result&lt;(), PipelineError&gt; {
        // Save current key as previous
        let old_key = std::mem::replace(
            &amp;mut self.current_key,
            SecretKey::generate(32),
        );
        self.previous_key = Some(old_key);
        self.last_rotation = Instant::now();

        Ok(())
    }

    pub fn should_rotate(&amp;self) -&gt; bool {
        self.last_rotation.elapsed() &gt;= self.rotation_interval
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance Optimizations</a></h2>
<h3 id="parallel-chunk-encryption"><a class="header" href="#parallel-chunk-encryption">Parallel Chunk Encryption</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rayon::prelude::*;

pub async fn encrypt_chunks(
    chunks: Vec&lt;FileChunk&gt;,
    algorithm: &amp;Algorithm,
    key: &amp;SecretKey,
    encryption_service: &amp;Arc&lt;dyn EncryptionService&gt;,
) -&gt; Result&lt;Vec&lt;EncryptedChunk&gt;, PipelineError&gt; {
    // Encrypt chunks in parallel
    chunks.par_iter()
        .map(|chunk| {
            let encrypted = encryption_service
                .encrypt(&amp;chunk.data, algorithm, key)?;

            Ok(EncryptedChunk {
                sequence: chunk.sequence,
                data: encrypted,
                original_size: chunk.data.len(),
            })
        })
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="hardware-acceleration"><a class="header" href="#hardware-acceleration">Hardware Acceleration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detect AES-NI support
pub fn has_aes_ni() -&gt; bool {
    #[cfg(target_arch = "x86_64")]
    {
        use std::arch::x86_64::*;
        is_x86_feature_detected!("aes")
    }
    #[cfg(not(target_arch = "x86_64"))]
    {
        false
    }
}

// Select algorithm based on hardware
pub fn select_algorithm() -&gt; Algorithm {
    if has_aes_ni() {
        Algorithm::aes_256_gcm()  // Fast with hardware support
    } else {
        Algorithm::chacha20_poly1305()  // Consistent without hardware
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="encryption-configuration"><a class="header" href="#encryption-configuration">Encryption Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EncryptionConfig {
    pub algorithm: Algorithm,
    pub key_derivation: KeyDerivationFunction,
    pub key_rotation_interval: Duration,
    pub nonce_reuse_prevention: bool,
}

impl EncryptionConfig {
    pub fn maximum_security() -&gt; Self {
        Self {
            algorithm: Algorithm::aes_256_gcm(),
            key_derivation: KeyDerivationFunction::Argon2,
            key_rotation_interval: Duration::from_secs(86400), // 24 hours
            nonce_reuse_prevention: true,
        }
    }

    pub fn balanced() -&gt; Self {
        Self {
            algorithm: if has_aes_ni() {
                Algorithm::aes_256_gcm()
            } else {
                Algorithm::chacha20_poly1305()
            },
            key_derivation: KeyDerivationFunction::Scrypt,
            key_rotation_interval: Duration::from_secs(604800), // 7 days
            nonce_reuse_prevention: true,
        }
    }

    pub fn high_performance() -&gt; Self {
        Self {
            algorithm: if has_aes_ni() {
                Algorithm::aes_128_gcm()
            } else {
                Algorithm::chacha20_poly1305()
            },
            key_derivation: KeyDerivationFunction::PBKDF2,
            key_rotation_interval: Duration::from_secs(2592000), // 30 days
            nonce_reuse_prevention: true,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum EncryptionError {
    #[error("Encryption failed: {0}")]
    EncryptionFailed(String),

    #[error("Decryption failed: {0}")]
    DecryptionFailed(String),

    #[error("Authentication failed - data may be tampered")]
    AuthenticationFailed,

    #[error("Invalid key length: expected {expected}, got {actual}")]
    InvalidKeyLength { expected: usize, actual: usize },

    #[error("Nonce reuse detected")]
    NonceReuse,

    #[error("Key derivation failed: {0}")]
    KeyDerivationFailed(String),
}

impl From&lt;EncryptionError&gt; for PipelineError {
    fn from(err: EncryptionError) -&gt; Self {
        match err {
            EncryptionError::EncryptionFailed(msg) =&gt;
                PipelineError::EncryptionError(msg),
            EncryptionError::DecryptionFailed(msg) =&gt;
                PipelineError::DecryptionError(msg),
            EncryptionError::AuthenticationFailed =&gt;
                PipelineError::IntegrityError("Authentication failed".to_string()),
            _ =&gt; PipelineError::EncryptionError(err.to_string()),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="basic-encryption"><a class="header" href="#basic-encryption">Basic Encryption</a></h3>
<pre><pre class="playground"><code class="language-rust">use adaptive_pipeline::infrastructure::adapters::EncryptionServiceAdapter;
use adaptive_pipeline_domain::services::EncryptionService;
use adaptive_pipeline_domain::value_objects::Algorithm;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create encryption service
    let encryption = EncryptionServiceAdapter::new();

    // Generate encryption key
    let key = SecretKey::generate(32); // 256 bits

    // Encrypt data
    let data = b"Sensitive information";
    let encrypted = encryption.encrypt(
        data,
        &amp;Algorithm::aes_256_gcm(),
        &amp;key
    ).await?;

    println!("Original size: {} bytes", data.len());
    println!("Encrypted size: {} bytes", encrypted.ciphertext.len());
    println!("Nonce: {} bytes", encrypted.nonce.len());
    println!("Tag: {} bytes", encrypted.tag.len());

    // Decrypt data
    let decrypted = encryption.decrypt(
        &amp;encrypted,
        &amp;Algorithm::aes_256_gcm(),
        &amp;key
    ).await?;

    assert_eq!(data, decrypted.as_slice());
    println!("✓ Decryption successful");

    Ok(())
}</code></pre></pre>
<h3 id="password-based-encryption"><a class="header" href="#password-based-encryption">Password-Based Encryption</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn encrypt_with_password(
    data: &amp;[u8],
    password: &amp;str,
) -&gt; Result&lt;EncryptedData, PipelineError&gt; {
    // Generate random salt
    let salt = SecretKey::generate(16);

    // Derive key from password
    let key = derive_key(
        password.as_bytes(),
        salt.as_bytes(),
        KeyDerivationFunction::Argon2,
    )?;

    // Encrypt data
    let encryption = EncryptionServiceAdapter::new();
    let encrypted = encryption.encrypt(
        data,
        &amp;Algorithm::aes_256_gcm(),
        &amp;key,
    ).await?;

    // Store salt with encrypted data
    encrypted.salt = salt.as_bytes().to_vec();

    Ok(encrypted)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tamper-detection"><a class="header" href="#tamper-detection">Tamper Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn decrypt_with_verification(
    encrypted: &amp;EncryptedData,
    key: &amp;SecretKey,
) -&gt; Result&lt;Vec&lt;u8&gt;, PipelineError&gt; {
    let encryption = EncryptionServiceAdapter::new();

    // Attempt decryption (will fail if tampered)
    match encryption.decrypt(encrypted, &amp;Algorithm::aes_256_gcm(), key).await {
        Ok(plaintext) =&gt; {
            println!("✓ Data is authentic and unmodified");
            Ok(plaintext)
        }
        Err(PipelineError::DecryptionError(_)) =&gt; {
            eprintln!("✗ Data has been tampered with!");
            Err(PipelineError::IntegrityError(
                "Authentication failed - data may be tampered".to_string()
            ))
        }
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>Typical performance on modern systems:</p>
<pre><code class="language-text">Algorithm          | File Size | Encrypt Time | Decrypt Time | Throughput
-------------------|-----------|--------------|--------------|------------
AES-256-GCM (NI)   | 100 MB    | 0.04s        | 0.04s        | 2.5 GB/s
AES-256-GCM (SW)   | 100 MB    | 0.8s         | 0.8s         | 125 MB/s
ChaCha20-Poly1305  | 100 MB    | 0.15s        | 0.15s        | 670 MB/s
AES-128-GCM (NI)   | 100 MB    | 0.03s        | 0.03s        | 3.3 GB/s
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="algorithm-selection"><a class="header" href="#algorithm-selection">Algorithm Selection</a></h3>
<p><strong>Use AES-256-GCM when:</strong></p>
<ul>
<li>Compliance requires FIPS-approved encryption</li>
<li>Long-term data protection is needed</li>
<li>Hardware has AES-NI support</li>
<li>Maximum security is required</li>
</ul>
<p><strong>Use ChaCha20-Poly1305 when:</strong></p>
<ul>
<li>Running on platforms without AES-NI</li>
<li>Constant-time execution is critical</li>
<li>Side-channel resistance is needed</li>
<li>Mobile/embedded deployment</li>
</ul>
<p><strong>Use AES-128-GCM when:</strong></p>
<ul>
<li>Maximum performance is required</li>
<li>Short-term data protection is sufficient</li>
<li>Hardware has AES-NI support</li>
</ul>
<h3 id="key-management-1"><a class="header" href="#key-management-1">Key Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Secure key handling
let key = SecretKey::generate(32);
let encrypted = encrypt(data, &amp;key)?;
// Key is automatically zeroized on drop

// ❌ BAD: Exposing key in logs
println!("Key: {:?}", key);  // Never log keys!

// ✅ GOOD: Key derivation from password
let key = derive_key(password, salt, KeyDerivationFunction::Argon2)?;

// ❌ BAD: Weak key derivation
let key = sha256(password);  // Not secure!
<span class="boring">}</span></code></pre></pre>
<h3 id="nonce-management-1"><a class="header" href="#nonce-management-1">Nonce Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Unique nonce per encryption
let nonce = generate_unique_nonce();

// ❌ BAD: Reusing nonces
let nonce = [0u8; 12];  // NEVER reuse nonces!

// ✅ GOOD: Counter-based nonces
let nonce_counter = AtomicU64::new(0);
let nonce = generate_nonce_from_counter(nonce_counter.fetch_add(1));
<span class="boring">}</span></code></pre></pre>
<h3 id="authentication-verification"><a class="header" href="#authentication-verification">Authentication Verification</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Always verify authentication
match decrypt(encrypted, key) {
    Ok(data) =&gt; process(data),
    Err(e) =&gt; {
        log::error!("Decryption failed - possible tampering");
        return Err(e);
    }
}

// ❌ BAD: Ignoring authentication failures
let data = decrypt(encrypted, key).unwrap_or_default();  // Dangerous!
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="nonce-uniqueness"><a class="header" href="#nonce-uniqueness">Nonce Uniqueness</a></h3>
<ul>
<li><strong>Critical:</strong> Never reuse a nonce with the same key</li>
<li>Use counter-based or random nonces</li>
<li>Rotate keys after 2^32 encryptions (GCM limit)</li>
</ul>
<h3 id="key-strength"><a class="header" href="#key-strength">Key Strength</a></h3>
<ul>
<li>Minimum 256 bits for long-term security</li>
<li>Use cryptographically secure random number generators</li>
<li>Derive keys properly from passwords (use Argon2)</li>
</ul>
<h3 id="memory-security"><a class="header" href="#memory-security">Memory Security</a></h3>
<ul>
<li>Keys are automatically zeroized on drop</li>
<li>Avoid cloning keys unnecessarily</li>
<li>Don't log or print keys</li>
</ul>
<h3 id="side-channel-attacks"><a class="header" href="#side-channel-attacks">Side-Channel Attacks</a></h3>
<ul>
<li>ChaCha20 provides constant-time execution</li>
<li>AES requires AES-NI for timing attack resistance</li>
<li>Validate all inputs before decryption</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand encryption implementation:</p>
<ul>
<li><a href="integrity.html">Integrity Verification</a> - Checksum and hashing</li>
<li><a href="../advanced/key-management.html">Key Management</a> - Advanced key handling</li>
<li><a href="../advanced/security.html">Security Best Practices</a> - Comprehensive security guide</li>
<li><a href="compression.html">Compression</a> - Data compression before encryption</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../implementation/compression.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../implementation/integrity.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../implementation/compression.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../implementation/integrity.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
